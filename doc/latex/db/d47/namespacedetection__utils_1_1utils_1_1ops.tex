\doxysection{detection\+\_\+utils.\+utils.\+ops Namespace Reference}
\hypertarget{namespacedetection__utils_1_1utils_1_1ops}{}\label{namespacedetection__utils_1_1utils_1_1ops}\index{detection\_utils.utils.ops@{detection\_utils.utils.ops}}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1utils_1_1ops_a361f89dc99c799c108b569851f420be2}{expanded\+\_\+shape}} (orig\+\_\+shape, start\+\_\+dim, num\+\_\+dims)
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1utils_1_1ops_adc866ef74c28004b32df8315d34c8805}{normalized\+\_\+to\+\_\+image\+\_\+coordinates}} (normalized\+\_\+boxes, image\+\_\+shape, parallel\+\_\+iterations=32)
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1utils_1_1ops_af311e77e054cb389029fd2e4a40c2955}{meshgrid}} (x, y)
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1utils_1_1ops_a516b301f1397988c4021aec757b16d2d}{fixed\+\_\+padding}} (inputs, kernel\+\_\+size, rate=1)
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1utils_1_1ops_afcdac23eebee9bb6a17790afbdf223d9}{pad\+\_\+to\+\_\+multiple}} (tensor, multiple)
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1utils_1_1ops_afe923c1879971de61ca2630119d56287}{padded\+\_\+one\+\_\+hot\+\_\+encoding}} (indices, depth, left\+\_\+pad)
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1utils_1_1ops_addc98bd6fb2ea843a7e291c1f4f761d2}{dense\+\_\+to\+\_\+sparse\+\_\+boxes}} (dense\+\_\+locations, dense\+\_\+num\+\_\+boxes, num\+\_\+classes)
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1utils_1_1ops_a9fad235f916265ec93571df2b5269b46}{indices\+\_\+to\+\_\+dense\+\_\+vector}} (indices, size, indices\+\_\+value=1., default\+\_\+value=0, dtype=tf.\+float32)
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1utils_1_1ops_a8c5e626e71f1d4e2bf1a4693b1035984}{reduce\+\_\+sum\+\_\+trailing\+\_\+dimensions}} (tensor, ndims)
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1utils_1_1ops_af4c44e343c3cb222937eb3e496ce68e6}{retain\+\_\+groundtruth}} (tensor\+\_\+dict, valid\+\_\+indices)
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1utils_1_1ops_ae6ecd4d38671df8c284d9a856f1d603f}{retain\+\_\+groundtruth\+\_\+with\+\_\+positive\+\_\+classes}} (tensor\+\_\+dict)
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1utils_1_1ops_ae9ea79fd4a604caa7430abce7d10bcef}{replace\+\_\+nan\+\_\+groundtruth\+\_\+label\+\_\+scores\+\_\+with\+\_\+ones}} (label\+\_\+scores)
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1utils_1_1ops_a14259559c91fbe3753ef93fd614eebd8}{filter\+\_\+groundtruth\+\_\+with\+\_\+crowd\+\_\+boxes}} (tensor\+\_\+dict)
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1utils_1_1ops_a9caa9fbd25912b008f9dfbe9ca636567}{filter\+\_\+groundtruth\+\_\+with\+\_\+nan\+\_\+box\+\_\+coordinates}} (tensor\+\_\+dict)
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1utils_1_1ops_a391c9d74117ad32ba170f1df7be9efc9}{filter\+\_\+unrecognized\+\_\+classes}} (tensor\+\_\+dict)
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1utils_1_1ops_a427d2293178f37f8f3030837d3813b65}{normalize\+\_\+to\+\_\+target}} (inputs, target\+\_\+norm\+\_\+value, dim, epsilon=1e-\/7, trainable=True, scope=\textquotesingle{}Normalize\+To\+Target\textquotesingle{}, summarize=True)
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1utils_1_1ops_a8dc56974f34bbceff44a4dc9f4dace05}{batch\+\_\+position\+\_\+sensitive\+\_\+crop\+\_\+regions}} (images, boxes, crop\+\_\+size, num\+\_\+spatial\+\_\+bins, global\+\_\+pool, parallel\+\_\+iterations=64)
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1utils_1_1ops_a674b91c79c0575b09d5b79114912a8fa}{position\+\_\+sensitive\+\_\+crop\+\_\+regions}} (image, boxes, crop\+\_\+size, num\+\_\+spatial\+\_\+bins, global\+\_\+pool)
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1utils_1_1ops_ae862e7f24dbb83f231c678895bfdf766}{reframe\+\_\+box\+\_\+masks\+\_\+to\+\_\+image\+\_\+masks}} (box\+\_\+masks, boxes, image\+\_\+height, image\+\_\+width)
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1utils_1_1ops_aa05d5979ad4881e4f972be53d5b4200d}{merge\+\_\+boxes\+\_\+with\+\_\+multiple\+\_\+labels}} (boxes, classes, confidences, num\+\_\+classes, quantization\+\_\+bins=10000)
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1utils_1_1ops_adc950a7496c9cea7a96d5fe6acd77d82}{nearest\+\_\+neighbor\+\_\+upsampling}} (input\+\_\+tensor, scale=None, height\+\_\+scale=None, width\+\_\+scale=None)
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1utils_1_1ops_a6323da655ab0d0f545c213c5b0382b7f}{matmul\+\_\+gather\+\_\+on\+\_\+zeroth\+\_\+axis}} (params, indices, scope=None)
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1utils_1_1ops_a140f2d38716d4f6f82081e7a6dfc38c7}{fpn\+\_\+feature\+\_\+levels}} (num\+\_\+levels, unit\+\_\+scale\+\_\+index, image\+\_\+ratio, boxes)
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1utils_1_1ops_ab995660ac802c5af8c902b336a138b2b}{bfloat16\+\_\+to\+\_\+float32\+\_\+nested}} (tensor\+\_\+nested)
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1utils_1_1ops_a4f2f992f354f09d7235817f9787a6454}{gather\+\_\+with\+\_\+padding\+\_\+values}} (input\+\_\+tensor, indices, padding\+\_\+value)
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1utils_1_1ops_a33f64e9ecb63a23af0c998ebb402c533}{matmul\+\_\+crop\+\_\+and\+\_\+resize}} = spatial\+\_\+ops.\+matmul\+\_\+crop\+\_\+and\+\_\+resize
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1utils_1_1ops_af020a014cef7a2230e195b6b6a02e88f}{multilevel\+\_\+roi\+\_\+align}} = spatial\+\_\+ops.\+multilevel\+\_\+roi\+\_\+align
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1utils_1_1ops_a3c7872f0750bfae89334d4e6073caabf}{native\+\_\+crop\+\_\+and\+\_\+resize}} = spatial\+\_\+ops.\+native\+\_\+crop\+\_\+and\+\_\+resize
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1utils_1_1ops_a82ed092503588fcc71b43646a1100dac}{Equalization\+Loss\+Config}}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\begin{DoxyVerb}A module for helper tensorflow ops.\end{DoxyVerb}
 

\doxysubsection{Function Documentation}
\Hypertarget{namespacedetection__utils_1_1utils_1_1ops_a8dc56974f34bbceff44a4dc9f4dace05}\label{namespacedetection__utils_1_1utils_1_1ops_a8dc56974f34bbceff44a4dc9f4dace05} 
\index{detection\_utils.utils.ops@{detection\_utils.utils.ops}!batch\_position\_sensitive\_crop\_regions@{batch\_position\_sensitive\_crop\_regions}}
\index{batch\_position\_sensitive\_crop\_regions@{batch\_position\_sensitive\_crop\_regions}!detection\_utils.utils.ops@{detection\_utils.utils.ops}}
\doxysubsubsection{\texorpdfstring{batch\_position\_sensitive\_crop\_regions()}{batch\_position\_sensitive\_crop\_regions()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+utils.\+ops.\+batch\+\_\+position\+\_\+sensitive\+\_\+crop\+\_\+regions (\begin{DoxyParamCaption}\item[{}]{images,  }\item[{}]{boxes,  }\item[{}]{crop\+\_\+size,  }\item[{}]{num\+\_\+spatial\+\_\+bins,  }\item[{}]{global\+\_\+pool,  }\item[{}]{parallel\+\_\+iterations = {\ttfamily 64} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Position sensitive crop with batches of images and boxes.

This op is exactly like `position_sensitive_crop_regions` below but operates
on batches of images and boxes. See `position_sensitive_crop_regions` function
below for the operation applied per batch element.

Args:
  images: A `Tensor`. Must be one of the following types: `uint8`, `int8`,
    `int16`, `int32`, `int64`, `half`, `float32`, `float64`.
    A 4-D tensor of shape `[batch, image_height, image_width, depth]`.
    Both `image_height` and `image_width` need to be positive.
  boxes: A `Tensor` of type `float32`.
    A 3-D tensor of shape `[batch, num_boxes, 4]`. Each box is specified in
    normalized coordinates `[y1, x1, y2, x2]`. A normalized coordinate value
    of `y` is mapped to the image coordinate at `y * (image_height - 1)`, so
    as the `[0, 1]` interval of normalized image height is mapped to
    `[0, image_height - 1] in image height coordinates. We do allow y1 > y2,
    in which case the sampled crop is an up-down flipped version of the
    original image. The width dimension is treated similarly.
  crop_size: See `position_sensitive_crop_regions` below.
  num_spatial_bins: See `position_sensitive_crop_regions` below.
  global_pool: See `position_sensitive_crop_regions` below.
  parallel_iterations: Number of batch items to process in parallel.

Returns:
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{ops_8py_source_l00604}{604}} of file \mbox{\hyperlink{ops_8py_source}{ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00609\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ parallel\_iterations=64):}
\DoxyCodeLine{00610\ \ \ \textcolor{stringliteral}{"{}"{}"{}Position\ sensitive\ crop\ with\ batches\ of\ images\ and\ boxes.}}
\DoxyCodeLine{00611\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00612\ \textcolor{stringliteral}{\ \ This\ op\ }\textcolor{keywordflow}{is}\ exactly\ like\ \`{}position\_sensitive\_crop\_regions\`{}\ below\ but\ operates}
\DoxyCodeLine{00613\ \ \ on\ batches\ of\ images\ \textcolor{keywordflow}{and}\ boxes.\ See\ \`{}position\_sensitive\_crop\_regions\`{}\ function}
\DoxyCodeLine{00614\ \ \ below\ \textcolor{keywordflow}{for}\ the\ operation\ applied\ per\ batch\ element.}
\DoxyCodeLine{00615\ }
\DoxyCodeLine{00616\ \ \ Args:}
\DoxyCodeLine{00617\ \ \ \ \ images:\ A\ \`{}Tensor\`{}.\ Must\ be\ one\ of\ the\ following\ types:\ \`{}uint8\`{},\ \`{}int8\`{},}
\DoxyCodeLine{00618\ \ \ \ \ \ \ \`{}int16\`{},\ \`{}int32\`{},\ \`{}int64\`{},\ \`{}half\`{},\ \`{}float32\`{},\ \`{}float64\`{}.}
\DoxyCodeLine{00619\ \ \ \ \ \ \ A\ 4-\/D\ tensor\ of\ shape\ \`{}[batch,\ image\_height,\ image\_width,\ depth]\`{}.}
\DoxyCodeLine{00620\ \ \ \ \ \ \ Both\ \`{}image\_height\`{}\ \textcolor{keywordflow}{and}\ \`{}image\_width\`{}\ need\ to\ be\ positive.}
\DoxyCodeLine{00621\ \ \ \ \ boxes:\ A\ \`{}Tensor\`{}\ of\ type\ \`{}float32\`{}.}
\DoxyCodeLine{00622\ \ \ \ \ \ \ A\ 3-\/D\ tensor\ of\ shape\ \`{}[batch,\ num\_boxes,\ 4]\`{}.\ Each\ box\ \textcolor{keywordflow}{is}\ specified\ \textcolor{keywordflow}{in}}
\DoxyCodeLine{00623\ \ \ \ \ \ \ normalized\ coordinates\ \`{}[y1,\ x1,\ y2,\ x2]\`{}.\ A\ normalized\ coordinate\ value}
\DoxyCodeLine{00624\ \ \ \ \ \ \ of\ \`{}y\`{}\ \textcolor{keywordflow}{is}\ mapped\ to\ the\ image\ coordinate\ at\ \`{}y\ *\ (image\_height\ -\/\ 1)\`{},\ so}
\DoxyCodeLine{00625\ \ \ \ \ \ \ \textcolor{keyword}{as}\ the\ \`{}[0,\ 1]\`{}\ interval\ of\ normalized\ image\ height\ \textcolor{keywordflow}{is}\ mapped\ to}
\DoxyCodeLine{00626\ \ \ \ \ \ \ \`{}[0,\ image\_height\ -\/\ 1]\ \textcolor{keywordflow}{in}\ image\ height\ coordinates.\ We\ do\ allow\ y1\ >\ y2,}
\DoxyCodeLine{00627\ \ \ \ \ \ \ \textcolor{keywordflow}{in}\ which\ case\ the\ sampled\ crop\ \textcolor{keywordflow}{is}\ an\ up-\/down\ flipped\ version\ of\ the}
\DoxyCodeLine{00628\ \ \ \ \ \ \ original\ image.\ The\ width\ dimension\ \textcolor{keywordflow}{is}\ treated\ similarly.}
\DoxyCodeLine{00629\ \ \ \ \ crop\_size:\ See\ \`{}position\_sensitive\_crop\_regions\`{}\ below.}
\DoxyCodeLine{00630\ \ \ \ \ num\_spatial\_bins:\ See\ \`{}position\_sensitive\_crop\_regions\`{}\ below.}
\DoxyCodeLine{00631\ \ \ \ \ global\_pool:\ See\ \`{}position\_sensitive\_crop\_regions\`{}\ below.}
\DoxyCodeLine{00632\ \ \ \ \ parallel\_iterations:\ Number\ of\ batch\ items\ to\ process\ \textcolor{keywordflow}{in}\ parallel.}
\DoxyCodeLine{00633\ }
\DoxyCodeLine{00634\ \ \ Returns:}
\DoxyCodeLine{00635\ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{00636\ \textcolor{stringliteral}{\ \ }\textcolor{keyword}{def\ }\_position\_sensitive\_crop\_fn(inputs):}
\DoxyCodeLine{00637\ \ \ \ \ images,\ boxes\ =\ inputs}
\DoxyCodeLine{00638\ \ \ \ \ \textcolor{keywordflow}{return}\ position\_sensitive\_crop\_regions(}
\DoxyCodeLine{00639\ \ \ \ \ \ \ \ \ images,}
\DoxyCodeLine{00640\ \ \ \ \ \ \ \ \ boxes,}
\DoxyCodeLine{00641\ \ \ \ \ \ \ \ \ crop\_size=crop\_size,}
\DoxyCodeLine{00642\ \ \ \ \ \ \ \ \ num\_spatial\_bins=num\_spatial\_bins,}
\DoxyCodeLine{00643\ \ \ \ \ \ \ \ \ global\_pool=global\_pool)}
\DoxyCodeLine{00644\ }
\DoxyCodeLine{00645\ \ \ \textcolor{keywordflow}{return}\ shape\_utils.static\_or\_dynamic\_map\_fn(}
\DoxyCodeLine{00646\ \ \ \ \ \ \ \_position\_sensitive\_crop\_fn,}
\DoxyCodeLine{00647\ \ \ \ \ \ \ elems=[images,\ boxes],}
\DoxyCodeLine{00648\ \ \ \ \ \ \ dtype=tf.float32,}
\DoxyCodeLine{00649\ \ \ \ \ \ \ parallel\_iterations=parallel\_iterations)}
\DoxyCodeLine{00650\ }
\DoxyCodeLine{00651\ }

\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{db/d47/namespacedetection__utils_1_1utils_1_1ops_a8dc56974f34bbceff44a4dc9f4dace05_cgraph}
\end{center}
\end{figure}
\Hypertarget{namespacedetection__utils_1_1utils_1_1ops_ab995660ac802c5af8c902b336a138b2b}\label{namespacedetection__utils_1_1utils_1_1ops_ab995660ac802c5af8c902b336a138b2b} 
\index{detection\_utils.utils.ops@{detection\_utils.utils.ops}!bfloat16\_to\_float32\_nested@{bfloat16\_to\_float32\_nested}}
\index{bfloat16\_to\_float32\_nested@{bfloat16\_to\_float32\_nested}!detection\_utils.utils.ops@{detection\_utils.utils.ops}}
\doxysubsubsection{\texorpdfstring{bfloat16\_to\_float32\_nested()}{bfloat16\_to\_float32\_nested()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+utils.\+ops.\+bfloat16\+\_\+to\+\_\+float32\+\_\+nested (\begin{DoxyParamCaption}\item[{}]{tensor\+\_\+nested }\end{DoxyParamCaption})}

\begin{DoxyVerb}Convert float32 tensors in a nested structure to bfloat16.

Args:
  tensor_nested: A Python dict, values being Tensor or Python list/tuple of
    Tensor.

Returns:
  A Python dict with the same structure as `tensor_dict`,
  with all bfloat16 tensors converted to float32.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{ops_8py_source_l01038}{1038}} of file \mbox{\hyperlink{ops_8py_source}{ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{01038\ \textcolor{keyword}{def\ }bfloat16\_to\_float32\_nested(tensor\_nested):}
\DoxyCodeLine{01039\ \ \ \textcolor{stringliteral}{"{}"{}"{}Convert\ float32\ tensors\ in\ a\ nested\ structure\ to\ bfloat16.}}
\DoxyCodeLine{01040\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01041\ \textcolor{stringliteral}{\ \ Args:}}
\DoxyCodeLine{01042\ \textcolor{stringliteral}{\ \ \ \ tensor\_nested:\ A\ Python\ dict,\ values\ being\ Tensor\ }\textcolor{keywordflow}{or}\ Python\ list/tuple\ of}
\DoxyCodeLine{01043\ \ \ \ \ \ \ Tensor.}
\DoxyCodeLine{01044\ }
\DoxyCodeLine{01045\ \ \ Returns:}
\DoxyCodeLine{01046\ \ \ \ \ A\ Python\ dict\ \textcolor{keyword}{with}\ the\ same\ structure\ \textcolor{keyword}{as}\ \`{}tensor\_dict\`{},}
\DoxyCodeLine{01047\ \ \ \ \ \textcolor{keyword}{with}\ all\ bfloat16\ tensors\ converted\ to\ float32.}
\DoxyCodeLine{01048\ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{01049\ \textcolor{stringliteral}{\ \ }\textcolor{keywordflow}{if}\ isinstance(tensor\_nested,\ tf.Tensor):}
\DoxyCodeLine{01050\ \ \ \ \ \textcolor{keywordflow}{if}\ tensor\_nested.dtype\ ==\ tf.bfloat16:}
\DoxyCodeLine{01051\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ tf.cast(tensor\_nested,\ dtype=tf.float32)}
\DoxyCodeLine{01052\ \ \ \ \ \textcolor{keywordflow}{else}:}
\DoxyCodeLine{01053\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ tensor\_nested}
\DoxyCodeLine{01054\ \ \ \textcolor{keywordflow}{elif}\ isinstance(tensor\_nested,\ (list,\ tuple)):}
\DoxyCodeLine{01055\ \ \ \ \ out\_tensor\_dict\ =\ [bfloat16\_to\_float32\_nested(t)\ \textcolor{keywordflow}{for}\ t\ \textcolor{keywordflow}{in}\ tensor\_nested]}
\DoxyCodeLine{01056\ \ \ \textcolor{keywordflow}{elif}\ isinstance(tensor\_nested,\ dict):}
\DoxyCodeLine{01057\ \ \ \ \ out\_tensor\_dict\ =\ \{}
\DoxyCodeLine{01058\ \ \ \ \ \ \ \ \ k:\ bfloat16\_to\_float32\_nested(v)\ \textcolor{keywordflow}{for}\ k,\ v\ \textcolor{keywordflow}{in}\ tensor\_nested.items()}
\DoxyCodeLine{01059\ \ \ \ \ \}}
\DoxyCodeLine{01060\ \ \ \textcolor{keywordflow}{return}\ out\_tensor\_dict}
\DoxyCodeLine{01061\ }
\DoxyCodeLine{01062\ }

\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=236pt]{db/d47/namespacedetection__utils_1_1utils_1_1ops_ab995660ac802c5af8c902b336a138b2b_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=236pt]{db/d47/namespacedetection__utils_1_1utils_1_1ops_ab995660ac802c5af8c902b336a138b2b_icgraph}
\end{center}
\end{figure}
\Hypertarget{namespacedetection__utils_1_1utils_1_1ops_addc98bd6fb2ea843a7e291c1f4f761d2}\label{namespacedetection__utils_1_1utils_1_1ops_addc98bd6fb2ea843a7e291c1f4f761d2} 
\index{detection\_utils.utils.ops@{detection\_utils.utils.ops}!dense\_to\_sparse\_boxes@{dense\_to\_sparse\_boxes}}
\index{dense\_to\_sparse\_boxes@{dense\_to\_sparse\_boxes}!detection\_utils.utils.ops@{detection\_utils.utils.ops}}
\doxysubsubsection{\texorpdfstring{dense\_to\_sparse\_boxes()}{dense\_to\_sparse\_boxes()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+utils.\+ops.\+dense\+\_\+to\+\_\+sparse\+\_\+boxes (\begin{DoxyParamCaption}\item[{}]{dense\+\_\+locations,  }\item[{}]{dense\+\_\+num\+\_\+boxes,  }\item[{}]{num\+\_\+classes }\end{DoxyParamCaption})}

\begin{DoxyVerb}Converts bounding boxes from dense to sparse form.

Args:
  dense_locations:  a [max_num_boxes, 4] tensor in which only the first k rows
    are valid bounding box location coordinates, where k is the sum of
    elements in dense_num_boxes.
  dense_num_boxes: a [max_num_classes] tensor indicating the counts of
     various bounding box classes e.g. [1, 0, 0, 2] means that the first
     bounding box is of class 0 and the second and third bounding boxes are
     of class 3. The sum of elements in this tensor is the number of valid
     bounding boxes.
  num_classes: number of classes

Returns:
  box_locations: a [num_boxes, 4] tensor containing only valid bounding
     boxes (i.e. the first num_boxes rows of dense_locations)
  box_classes: a [num_boxes] tensor containing the classes of each bounding
     box (e.g. dense_num_boxes = [1, 0, 0, 2] => box_classes = [0, 3, 3]
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{ops_8py_source_l00275}{275}} of file \mbox{\hyperlink{ops_8py_source}{ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00275\ \textcolor{keyword}{def\ }dense\_to\_sparse\_boxes(dense\_locations,\ dense\_num\_boxes,\ num\_classes):}
\DoxyCodeLine{00276\ \ \ \textcolor{stringliteral}{"{}"{}"{}Converts\ bounding\ boxes\ from\ dense\ to\ sparse\ form.}}
\DoxyCodeLine{00277\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00278\ \textcolor{stringliteral}{\ \ Args:}}
\DoxyCodeLine{00279\ \textcolor{stringliteral}{\ \ \ \ dense\_locations:\ \ a\ [max\_num\_boxes,\ 4]\ tensor\ }\textcolor{keywordflow}{in}\ which\ only\ the\ first\ k\ rows}
\DoxyCodeLine{00280\ \ \ \ \ \ \ are\ valid\ bounding\ box\ location\ coordinates,\ where\ k\ \textcolor{keywordflow}{is}\ the\ sum\ of}
\DoxyCodeLine{00281\ \ \ \ \ \ \ elements\ \textcolor{keywordflow}{in}\ dense\_num\_boxes.}
\DoxyCodeLine{00282\ \ \ \ \ dense\_num\_boxes:\ a\ [max\_num\_classes]\ tensor\ indicating\ the\ counts\ of}
\DoxyCodeLine{00283\ \ \ \ \ \ \ \ various\ bounding\ box\ classes\ e.g.\ [1,\ 0,\ 0,\ 2]\ means\ that\ the\ first}
\DoxyCodeLine{00284\ \ \ \ \ \ \ \ bounding\ box\ \textcolor{keywordflow}{is}\ of\ \textcolor{keyword}{class\ }0\ \textcolor{keywordflow}{and}\ the\ second\ \textcolor{keywordflow}{and}\ third\ bounding\ boxes\ are}
\DoxyCodeLine{00285\ \ \ \ \ \ \ \ of\ \textcolor{keyword}{class\ }3.\ The\ sum\ of\ elements\ \textcolor{keywordflow}{in}\ this\ tensor\ \textcolor{keywordflow}{is}\ the\ number\ of\ valid}
\DoxyCodeLine{00286\ \ \ \ \ \ \ \ bounding\ boxes.}
\DoxyCodeLine{00287\ \ \ \ \ num\_classes:\ number\ of\ classes}
\DoxyCodeLine{00288\ }
\DoxyCodeLine{00289\ \ \ Returns:}
\DoxyCodeLine{00290\ \ \ \ \ box\_locations:\ a\ [num\_boxes,\ 4]\ tensor\ containing\ only\ valid\ bounding}
\DoxyCodeLine{00291\ \ \ \ \ \ \ \ boxes\ (i.e.\ the\ first\ num\_boxes\ rows\ of\ dense\_locations)}
\DoxyCodeLine{00292\ \ \ \ \ box\_classes:\ a\ [num\_boxes]\ tensor\ containing\ the\ classes\ of\ each\ bounding}
\DoxyCodeLine{00293\ \ \ \ \ \ \ \ box\ (e.g.\ dense\_num\_boxes\ =\ [1,\ 0,\ 0,\ 2]\ =>\ box\_classes\ =\ [0,\ 3,\ 3]}
\DoxyCodeLine{00294\ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{00295\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00296\ \textcolor{stringliteral}{\ \ num\_valid\_boxes\ =\ tf.reduce\_sum(dense\_num\_boxes)}}
\DoxyCodeLine{00297\ \textcolor{stringliteral}{\ \ box\_locations\ =\ tf.slice(dense\_locations,}}
\DoxyCodeLine{00298\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ tf.constant([0,\ 0]),\ tf.stack([num\_valid\_boxes,\ 4]))}}
\DoxyCodeLine{00299\ \textcolor{stringliteral}{\ \ tiled\_classes\ =\ [tf.tile([i],\ tf.expand\_dims(dense\_num\_boxes[i],\ 0))}}
\DoxyCodeLine{00300\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ }\textcolor{keywordflow}{for}\ i\ \textcolor{keywordflow}{in}\ range(num\_classes)]}
\DoxyCodeLine{00301\ \ \ box\_classes\ =\ tf.concat(tiled\_classes,\ 0)}
\DoxyCodeLine{00302\ \ \ box\_locations.set\_shape([\textcolor{keywordtype}{None},\ 4])}
\DoxyCodeLine{00303\ \ \ \textcolor{keywordflow}{return}\ box\_locations,\ box\_classes}
\DoxyCodeLine{00304\ }
\DoxyCodeLine{00305\ }

\end{DoxyCode}
\Hypertarget{namespacedetection__utils_1_1utils_1_1ops_a361f89dc99c799c108b569851f420be2}\label{namespacedetection__utils_1_1utils_1_1ops_a361f89dc99c799c108b569851f420be2} 
\index{detection\_utils.utils.ops@{detection\_utils.utils.ops}!expanded\_shape@{expanded\_shape}}
\index{expanded\_shape@{expanded\_shape}!detection\_utils.utils.ops@{detection\_utils.utils.ops}}
\doxysubsubsection{\texorpdfstring{expanded\_shape()}{expanded\_shape()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+utils.\+ops.\+expanded\+\_\+shape (\begin{DoxyParamCaption}\item[{}]{orig\+\_\+shape,  }\item[{}]{start\+\_\+dim,  }\item[{}]{num\+\_\+dims }\end{DoxyParamCaption})}

\begin{DoxyVerb}Inserts multiple ones into a shape vector.

Inserts an all-1 vector of length num_dims at position start_dim into a shape.
Can be combined with tf.reshape to generalize tf.expand_dims.

Args:
  orig_shape: the shape into which the all-1 vector is added (int32 vector)
  start_dim: insertion position (int scalar)
  num_dims: length of the inserted all-1 vector (int scalar)
Returns:
  An int32 vector of length tf.size(orig_shape) + num_dims.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{ops_8py_source_l00040}{40}} of file \mbox{\hyperlink{ops_8py_source}{ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00040\ \textcolor{keyword}{def\ }expanded\_shape(orig\_shape,\ start\_dim,\ num\_dims):}
\DoxyCodeLine{00041\ \ \ \textcolor{stringliteral}{"{}"{}"{}Inserts\ multiple\ ones\ into\ a\ shape\ vector.}}
\DoxyCodeLine{00042\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00043\ \textcolor{stringliteral}{\ \ Inserts\ an\ all-\/1\ vector\ of\ length\ num\_dims\ at\ position\ start\_dim\ into\ a\ shape.}}
\DoxyCodeLine{00044\ \textcolor{stringliteral}{\ \ Can\ be\ combined\ }\textcolor{keyword}{with}\ tf.reshape\ to\ generalize\ tf.expand\_dims.}
\DoxyCodeLine{00045\ }
\DoxyCodeLine{00046\ \ \ Args:}
\DoxyCodeLine{00047\ \ \ \ \ orig\_shape:\ the\ shape\ into\ which\ the\ all-\/1\ vector\ \textcolor{keywordflow}{is}\ added\ (int32\ vector)}
\DoxyCodeLine{00048\ \ \ \ \ start\_dim:\ insertion\ position\ (int\ scalar)}
\DoxyCodeLine{00049\ \ \ \ \ num\_dims:\ length\ of\ the\ inserted\ all-\/1\ vector\ (int\ scalar)}
\DoxyCodeLine{00050\ \ \ Returns:}
\DoxyCodeLine{00051\ \ \ \ \ An\ int32\ vector\ of\ length\ tf.size(orig\_shape)\ +\ num\_dims.}
\DoxyCodeLine{00052\ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{00053\ \textcolor{stringliteral}{\ \ }\textcolor{keyword}{with}\ tf.name\_scope(\textcolor{stringliteral}{'ExpandedShape'}):}
\DoxyCodeLine{00054\ \ \ \ \ start\_dim\ =\ tf.expand\_dims(start\_dim,\ 0)\ \ \textcolor{comment}{\#\ scalar\ to\ rank-\/1}}
\DoxyCodeLine{00055\ \ \ \ \ before\ =\ tf.slice(orig\_shape,\ [0],\ start\_dim)}
\DoxyCodeLine{00056\ \ \ \ \ add\_shape\ =\ tf.ones(tf.reshape(num\_dims,\ [1]),\ dtype=tf.int32)}
\DoxyCodeLine{00057\ \ \ \ \ after\ =\ tf.slice(orig\_shape,\ start\_dim,\ [-\/1])}
\DoxyCodeLine{00058\ \ \ \ \ new\_shape\ =\ tf.concat([before,\ add\_shape,\ after],\ 0)}
\DoxyCodeLine{00059\ \ \ \ \ \textcolor{keywordflow}{return}\ new\_shape}
\DoxyCodeLine{00060\ }
\DoxyCodeLine{00061\ }

\end{DoxyCode}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{db/d47/namespacedetection__utils_1_1utils_1_1ops_a361f89dc99c799c108b569851f420be2_icgraph}
\end{center}
\end{figure}
\Hypertarget{namespacedetection__utils_1_1utils_1_1ops_a14259559c91fbe3753ef93fd614eebd8}\label{namespacedetection__utils_1_1utils_1_1ops_a14259559c91fbe3753ef93fd614eebd8} 
\index{detection\_utils.utils.ops@{detection\_utils.utils.ops}!filter\_groundtruth\_with\_crowd\_boxes@{filter\_groundtruth\_with\_crowd\_boxes}}
\index{filter\_groundtruth\_with\_crowd\_boxes@{filter\_groundtruth\_with\_crowd\_boxes}!detection\_utils.utils.ops@{detection\_utils.utils.ops}}
\doxysubsubsection{\texorpdfstring{filter\_groundtruth\_with\_crowd\_boxes()}{filter\_groundtruth\_with\_crowd\_boxes()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+utils.\+ops.\+filter\+\_\+groundtruth\+\_\+with\+\_\+crowd\+\_\+boxes (\begin{DoxyParamCaption}\item[{}]{tensor\+\_\+dict }\end{DoxyParamCaption})}

\begin{DoxyVerb}Filters out groundtruth with boxes corresponding to crowd.

Args:
  tensor_dict: a dictionary of following groundtruth tensors -
    fields.InputDataFields.groundtruth_boxes
    fields.InputDataFields.groundtruth_classes
    fields.InputDataFields.groundtruth_confidences
    fields.InputDataFields.groundtruth_keypoints
    fields.InputDataFields.groundtruth_instance_masks
    fields.InputDataFields.groundtruth_is_crowd
    fields.InputDataFields.groundtruth_area
    fields.InputDataFields.groundtruth_label_types

Returns:
  a dictionary of tensors containing only the groundtruth that have bounding
  boxes.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{ops_8py_source_l00445}{445}} of file \mbox{\hyperlink{ops_8py_source}{ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00445\ \textcolor{keyword}{def\ }filter\_groundtruth\_with\_crowd\_boxes(tensor\_dict):}
\DoxyCodeLine{00446\ \ \ \textcolor{stringliteral}{"{}"{}"{}Filters\ out\ groundtruth\ with\ boxes\ corresponding\ to\ crowd.}}
\DoxyCodeLine{00447\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00448\ \textcolor{stringliteral}{\ \ Args:}}
\DoxyCodeLine{00449\ \textcolor{stringliteral}{\ \ \ \ tensor\_dict:\ a\ dictionary\ of\ following\ groundtruth\ tensors\ -\/}}
\DoxyCodeLine{00450\ \textcolor{stringliteral}{\ \ \ \ \ \ fields.InputDataFields.groundtruth\_boxes}}
\DoxyCodeLine{00451\ \textcolor{stringliteral}{\ \ \ \ \ \ fields.InputDataFields.groundtruth\_classes}}
\DoxyCodeLine{00452\ \textcolor{stringliteral}{\ \ \ \ \ \ fields.InputDataFields.groundtruth\_confidences}}
\DoxyCodeLine{00453\ \textcolor{stringliteral}{\ \ \ \ \ \ fields.InputDataFields.groundtruth\_keypoints}}
\DoxyCodeLine{00454\ \textcolor{stringliteral}{\ \ \ \ \ \ fields.InputDataFields.groundtruth\_instance\_masks}}
\DoxyCodeLine{00455\ \textcolor{stringliteral}{\ \ \ \ \ \ fields.InputDataFields.groundtruth\_is\_crowd}}
\DoxyCodeLine{00456\ \textcolor{stringliteral}{\ \ \ \ \ \ fields.InputDataFields.groundtruth\_area}}
\DoxyCodeLine{00457\ \textcolor{stringliteral}{\ \ \ \ \ \ fields.InputDataFields.groundtruth\_label\_types}}
\DoxyCodeLine{00458\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00459\ \textcolor{stringliteral}{\ \ Returns:}}
\DoxyCodeLine{00460\ \textcolor{stringliteral}{\ \ \ \ a\ dictionary\ of\ tensors\ containing\ only\ the\ groundtruth\ that\ have\ bounding}}
\DoxyCodeLine{00461\ \textcolor{stringliteral}{\ \ \ \ boxes.}}
\DoxyCodeLine{00462\ \textcolor{stringliteral}{\ \ "{}"{}"{}}}
\DoxyCodeLine{00463\ \textcolor{stringliteral}{\ \ }\textcolor{keywordflow}{if}\ fields.InputDataFields.groundtruth\_is\_crowd\ \textcolor{keywordflow}{in}\ tensor\_dict:}
\DoxyCodeLine{00464\ \ \ \ \ is\_crowd\ =\ tensor\_dict[fields.InputDataFields.groundtruth\_is\_crowd]}
\DoxyCodeLine{00465\ \ \ \ \ is\_not\_crowd\ =\ tf.logical\_not(is\_crowd)}
\DoxyCodeLine{00466\ \ \ \ \ is\_not\_crowd\_indices\ =\ tf.where(is\_not\_crowd)}
\DoxyCodeLine{00467\ \ \ \ \ tensor\_dict\ =\ retain\_groundtruth(tensor\_dict,\ is\_not\_crowd\_indices)}
\DoxyCodeLine{00468\ \ \ \textcolor{keywordflow}{return}\ tensor\_dict}
\DoxyCodeLine{00469\ }
\DoxyCodeLine{00470\ }

\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{db/d47/namespacedetection__utils_1_1utils_1_1ops_a14259559c91fbe3753ef93fd614eebd8_cgraph}
\end{center}
\end{figure}
\Hypertarget{namespacedetection__utils_1_1utils_1_1ops_a9caa9fbd25912b008f9dfbe9ca636567}\label{namespacedetection__utils_1_1utils_1_1ops_a9caa9fbd25912b008f9dfbe9ca636567} 
\index{detection\_utils.utils.ops@{detection\_utils.utils.ops}!filter\_groundtruth\_with\_nan\_box\_coordinates@{filter\_groundtruth\_with\_nan\_box\_coordinates}}
\index{filter\_groundtruth\_with\_nan\_box\_coordinates@{filter\_groundtruth\_with\_nan\_box\_coordinates}!detection\_utils.utils.ops@{detection\_utils.utils.ops}}
\doxysubsubsection{\texorpdfstring{filter\_groundtruth\_with\_nan\_box\_coordinates()}{filter\_groundtruth\_with\_nan\_box\_coordinates()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+utils.\+ops.\+filter\+\_\+groundtruth\+\_\+with\+\_\+nan\+\_\+box\+\_\+coordinates (\begin{DoxyParamCaption}\item[{}]{tensor\+\_\+dict }\end{DoxyParamCaption})}

\begin{DoxyVerb}Filters out groundtruth with no bounding boxes.

Args:
  tensor_dict: a dictionary of following groundtruth tensors -
    fields.InputDataFields.groundtruth_boxes
    fields.InputDataFields.groundtruth_classes
    fields.InputDataFields.groundtruth_confidences
    fields.InputDataFields.groundtruth_keypoints
    fields.InputDataFields.groundtruth_instance_masks
    fields.InputDataFields.groundtruth_is_crowd
    fields.InputDataFields.groundtruth_area
    fields.InputDataFields.groundtruth_label_types

Returns:
  a dictionary of tensors containing only the groundtruth that have bounding
  boxes.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{ops_8py_source_l00471}{471}} of file \mbox{\hyperlink{ops_8py_source}{ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00471\ \textcolor{keyword}{def\ }filter\_groundtruth\_with\_nan\_box\_coordinates(tensor\_dict):}
\DoxyCodeLine{00472\ \ \ \textcolor{stringliteral}{"{}"{}"{}Filters\ out\ groundtruth\ with\ no\ bounding\ boxes.}}
\DoxyCodeLine{00473\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00474\ \textcolor{stringliteral}{\ \ Args:}}
\DoxyCodeLine{00475\ \textcolor{stringliteral}{\ \ \ \ tensor\_dict:\ a\ dictionary\ of\ following\ groundtruth\ tensors\ -\/}}
\DoxyCodeLine{00476\ \textcolor{stringliteral}{\ \ \ \ \ \ fields.InputDataFields.groundtruth\_boxes}}
\DoxyCodeLine{00477\ \textcolor{stringliteral}{\ \ \ \ \ \ fields.InputDataFields.groundtruth\_classes}}
\DoxyCodeLine{00478\ \textcolor{stringliteral}{\ \ \ \ \ \ fields.InputDataFields.groundtruth\_confidences}}
\DoxyCodeLine{00479\ \textcolor{stringliteral}{\ \ \ \ \ \ fields.InputDataFields.groundtruth\_keypoints}}
\DoxyCodeLine{00480\ \textcolor{stringliteral}{\ \ \ \ \ \ fields.InputDataFields.groundtruth\_instance\_masks}}
\DoxyCodeLine{00481\ \textcolor{stringliteral}{\ \ \ \ \ \ fields.InputDataFields.groundtruth\_is\_crowd}}
\DoxyCodeLine{00482\ \textcolor{stringliteral}{\ \ \ \ \ \ fields.InputDataFields.groundtruth\_area}}
\DoxyCodeLine{00483\ \textcolor{stringliteral}{\ \ \ \ \ \ fields.InputDataFields.groundtruth\_label\_types}}
\DoxyCodeLine{00484\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00485\ \textcolor{stringliteral}{\ \ Returns:}}
\DoxyCodeLine{00486\ \textcolor{stringliteral}{\ \ \ \ a\ dictionary\ of\ tensors\ containing\ only\ the\ groundtruth\ that\ have\ bounding}}
\DoxyCodeLine{00487\ \textcolor{stringliteral}{\ \ \ \ boxes.}}
\DoxyCodeLine{00488\ \textcolor{stringliteral}{\ \ "{}"{}"{}}}
\DoxyCodeLine{00489\ \textcolor{stringliteral}{\ \ groundtruth\_boxes\ =\ tensor\_dict[fields.InputDataFields.groundtruth\_boxes]}}
\DoxyCodeLine{00490\ \textcolor{stringliteral}{\ \ nan\_indicator\_vector\ =\ tf.greater(tf.reduce\_sum(tf.cast(}}
\DoxyCodeLine{00491\ \textcolor{stringliteral}{\ \ \ \ \ \ tf.is\_nan(groundtruth\_boxes),\ dtype=tf.int32),\ reduction\_indices=[1]),\ 0)}}
\DoxyCodeLine{00492\ \textcolor{stringliteral}{\ \ valid\_indicator\_vector\ =\ tf.logical\_not(nan\_indicator\_vector)}}
\DoxyCodeLine{00493\ \textcolor{stringliteral}{\ \ valid\_indices\ =\ tf.where(valid\_indicator\_vector)}}
\DoxyCodeLine{00494\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00495\ \textcolor{stringliteral}{\ \ }\textcolor{keywordflow}{return}\ retain\_groundtruth(tensor\_dict,\ valid\_indices)}
\DoxyCodeLine{00496\ }
\DoxyCodeLine{00497\ }

\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{db/d47/namespacedetection__utils_1_1utils_1_1ops_a9caa9fbd25912b008f9dfbe9ca636567_cgraph}
\end{center}
\end{figure}
\Hypertarget{namespacedetection__utils_1_1utils_1_1ops_a391c9d74117ad32ba170f1df7be9efc9}\label{namespacedetection__utils_1_1utils_1_1ops_a391c9d74117ad32ba170f1df7be9efc9} 
\index{detection\_utils.utils.ops@{detection\_utils.utils.ops}!filter\_unrecognized\_classes@{filter\_unrecognized\_classes}}
\index{filter\_unrecognized\_classes@{filter\_unrecognized\_classes}!detection\_utils.utils.ops@{detection\_utils.utils.ops}}
\doxysubsubsection{\texorpdfstring{filter\_unrecognized\_classes()}{filter\_unrecognized\_classes()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+utils.\+ops.\+filter\+\_\+unrecognized\+\_\+classes (\begin{DoxyParamCaption}\item[{}]{tensor\+\_\+dict }\end{DoxyParamCaption})}

\begin{DoxyVerb}Filters out class labels that are not unrecognized by the labelmap.

Decoder would parse unrecognized classes (not included in the labelmap) to
a label of value -1. Such targets are unecessary for training, and causes
issue for evaluation, due to labeling mapping logic. This function filters
those labels out for both training and evaluation.

Args:
  tensor_dict: dictionary containing input tensors keyed by
    fields.InputDataFields.

Returns:
  A dictionary keyed by fields.InputDataFields containing the tensors
  obtained after applying the filtering.

Raises:
  ValueError: If groundtruth_classes tensor is not in tensor_dict.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{ops_8py_source_l00498}{498}} of file \mbox{\hyperlink{ops_8py_source}{ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00498\ \textcolor{keyword}{def\ }filter\_unrecognized\_classes(tensor\_dict):}
\DoxyCodeLine{00499\ \ \ \textcolor{stringliteral}{"{}"{}"{}Filters\ out\ class\ labels\ that\ are\ not\ unrecognized\ by\ the\ labelmap.}}
\DoxyCodeLine{00500\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00501\ \textcolor{stringliteral}{\ \ Decoder\ would\ parse\ unrecognized\ classes\ (}\textcolor{keywordflow}{not}\ included\ \textcolor{keywordflow}{in}\ the\ labelmap)\ to}
\DoxyCodeLine{00502\ \ \ a\ label\ of\ value\ -\/1.\ Such\ targets\ are\ unecessary\ \textcolor{keywordflow}{for}\ training,\ \textcolor{keywordflow}{and}\ causes}
\DoxyCodeLine{00503\ \ \ issue\ \textcolor{keywordflow}{for}\ evaluation,\ due\ to\ labeling\ mapping\ logic.\ This\ function\ filters}
\DoxyCodeLine{00504\ \ \ those\ labels\ out\ \textcolor{keywordflow}{for}\ both\ training\ \textcolor{keywordflow}{and}\ evaluation.}
\DoxyCodeLine{00505\ }
\DoxyCodeLine{00506\ \ \ Args:}
\DoxyCodeLine{00507\ \ \ \ \ tensor\_dict:\ dictionary\ containing\ input\ tensors\ keyed\ by}
\DoxyCodeLine{00508\ \ \ \ \ \ \ fields.InputDataFields.}
\DoxyCodeLine{00509\ }
\DoxyCodeLine{00510\ \ \ Returns:}
\DoxyCodeLine{00511\ \ \ \ \ A\ dictionary\ keyed\ by\ fields.InputDataFields\ containing\ the\ tensors}
\DoxyCodeLine{00512\ \ \ \ \ obtained\ after\ applying\ the\ filtering.}
\DoxyCodeLine{00513\ }
\DoxyCodeLine{00514\ \ \ Raises:}
\DoxyCodeLine{00515\ \ \ \ \ ValueError:\ If\ groundtruth\_classes\ tensor\ \textcolor{keywordflow}{is}\ \textcolor{keywordflow}{not}\ \textcolor{keywordflow}{in}\ tensor\_dict.}
\DoxyCodeLine{00516\ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{00517\ \textcolor{stringliteral}{\ \ }\textcolor{keywordflow}{if}\ fields.InputDataFields.groundtruth\_classes\ \textcolor{keywordflow}{not}\ \textcolor{keywordflow}{in}\ tensor\_dict:}
\DoxyCodeLine{00518\ \ \ \ \ \textcolor{keywordflow}{raise}\ ValueError(\textcolor{stringliteral}{'\`{}groundtruth\ classes`\ not\ in\ tensor\_dict.'})}
\DoxyCodeLine{00519\ \ \ \textcolor{comment}{\#\ Refer\ to\ tf\_example\_decoder\ for\ how\ unrecognized\ labels\ are\ handled.}}
\DoxyCodeLine{00520\ \ \ unrecognized\_label\ =\ -\/1}
\DoxyCodeLine{00521\ \ \ recognized\_indices\ =\ tf.where(}
\DoxyCodeLine{00522\ \ \ \ \ \ \ tf.greater(tensor\_dict[fields.InputDataFields.groundtruth\_classes],}
\DoxyCodeLine{00523\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ unrecognized\_label))}
\DoxyCodeLine{00524\ }
\DoxyCodeLine{00525\ \ \ \textcolor{keywordflow}{return}\ retain\_groundtruth(tensor\_dict,\ recognized\_indices)}
\DoxyCodeLine{00526\ }
\DoxyCodeLine{00527\ }

\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{db/d47/namespacedetection__utils_1_1utils_1_1ops_a391c9d74117ad32ba170f1df7be9efc9_cgraph}
\end{center}
\end{figure}
\Hypertarget{namespacedetection__utils_1_1utils_1_1ops_a516b301f1397988c4021aec757b16d2d}\label{namespacedetection__utils_1_1utils_1_1ops_a516b301f1397988c4021aec757b16d2d} 
\index{detection\_utils.utils.ops@{detection\_utils.utils.ops}!fixed\_padding@{fixed\_padding}}
\index{fixed\_padding@{fixed\_padding}!detection\_utils.utils.ops@{detection\_utils.utils.ops}}
\doxysubsubsection{\texorpdfstring{fixed\_padding()}{fixed\_padding()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+utils.\+ops.\+fixed\+\_\+padding (\begin{DoxyParamCaption}\item[{}]{inputs,  }\item[{}]{kernel\+\_\+size,  }\item[{}]{rate = {\ttfamily 1} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Pads the input along the spatial dimensions independently of input size.

Args:
  inputs: A tensor of size [batch, height_in, width_in, channels].
  kernel_size: The kernel to be used in the conv2d or max_pool2d operation.
               Should be a positive integer.
  rate: An integer, rate for atrous convolution.

Returns:
  output: A tensor of size [batch, height_out, width_out, channels] with the
    input, either intact (if kernel_size == 1) or padded (if kernel_size > 1).
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{ops_8py_source_l00138}{138}} of file \mbox{\hyperlink{ops_8py_source}{ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00138\ \textcolor{keyword}{def\ }fixed\_padding(inputs,\ kernel\_size,\ rate=1):}
\DoxyCodeLine{00139\ \ \ \textcolor{stringliteral}{"{}"{}"{}Pads\ the\ input\ along\ the\ spatial\ dimensions\ independently\ of\ input\ size.}}
\DoxyCodeLine{00140\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00141\ \textcolor{stringliteral}{\ \ Args:}}
\DoxyCodeLine{00142\ \textcolor{stringliteral}{\ \ \ \ inputs:\ A\ tensor\ of\ size\ [batch,\ height\_in,\ width\_in,\ channels].}}
\DoxyCodeLine{00143\ \textcolor{stringliteral}{\ \ \ \ kernel\_size:\ The\ kernel\ to\ be\ used\ }\textcolor{keywordflow}{in}\ the\ conv2d\ \textcolor{keywordflow}{or}\ max\_pool2d\ operation.}
\DoxyCodeLine{00144\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Should\ be\ a\ positive\ integer.}
\DoxyCodeLine{00145\ \ \ \ \ rate:\ An\ integer,\ rate\ \textcolor{keywordflow}{for}\ atrous\ convolution.}
\DoxyCodeLine{00146\ }
\DoxyCodeLine{00147\ \ \ Returns:}
\DoxyCodeLine{00148\ \ \ \ \ output:\ A\ tensor\ of\ size\ [batch,\ height\_out,\ width\_out,\ channels]\ \textcolor{keyword}{with}\ the}
\DoxyCodeLine{00149\ \ \ \ \ \ \ input,\ either\ intact\ (\textcolor{keywordflow}{if}\ kernel\_size\ ==\ 1)\ \textcolor{keywordflow}{or}\ padded\ (\textcolor{keywordflow}{if}\ kernel\_size\ >\ 1).}
\DoxyCodeLine{00150\ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{00151\ \textcolor{stringliteral}{\ \ kernel\_size\_effective\ =\ kernel\_size\ +\ (kernel\_size\ -\/\ 1)\ *\ (rate\ -\/\ 1)}}
\DoxyCodeLine{00152\ \textcolor{stringliteral}{\ \ pad\_total\ =\ kernel\_size\_effective\ -\/\ 1}}
\DoxyCodeLine{00153\ \textcolor{stringliteral}{\ \ pad\_beg\ =\ pad\_total\ //\ 2}}
\DoxyCodeLine{00154\ \textcolor{stringliteral}{\ \ pad\_end\ =\ pad\_total\ -\/\ pad\_beg}}
\DoxyCodeLine{00155\ \textcolor{stringliteral}{\ \ padded\_inputs\ =\ tf.pad(inputs,\ [[0,\ 0],\ [pad\_beg,\ pad\_end],}}
\DoxyCodeLine{00156\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ [pad\_beg,\ pad\_end],\ [0,\ 0]])}}
\DoxyCodeLine{00157\ \textcolor{stringliteral}{\ \ }\textcolor{keywordflow}{return}\ padded\_inputs}
\DoxyCodeLine{00158\ }
\DoxyCodeLine{00159\ }

\end{DoxyCode}
\Hypertarget{namespacedetection__utils_1_1utils_1_1ops_a140f2d38716d4f6f82081e7a6dfc38c7}\label{namespacedetection__utils_1_1utils_1_1ops_a140f2d38716d4f6f82081e7a6dfc38c7} 
\index{detection\_utils.utils.ops@{detection\_utils.utils.ops}!fpn\_feature\_levels@{fpn\_feature\_levels}}
\index{fpn\_feature\_levels@{fpn\_feature\_levels}!detection\_utils.utils.ops@{detection\_utils.utils.ops}}
\doxysubsubsection{\texorpdfstring{fpn\_feature\_levels()}{fpn\_feature\_levels()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+utils.\+ops.\+fpn\+\_\+feature\+\_\+levels (\begin{DoxyParamCaption}\item[{}]{num\+\_\+levels,  }\item[{}]{unit\+\_\+scale\+\_\+index,  }\item[{}]{image\+\_\+ratio,  }\item[{}]{boxes }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns fpn feature level for each box based on its area.

See section 4.2 of https://arxiv.org/pdf/1612.03144.pdf for details.

Args:
  num_levels: An integer indicating the number of feature levels to crop boxes
    from.
  unit_scale_index: An 0-based integer indicating the index of feature map
    which most closely matches the resolution of the pretrained model.
  image_ratio: A float indicating the ratio of input image area to pretraining
    image area.
  boxes: A float tensor of shape [batch, num_boxes, 4] containing boxes of the
    form [ymin, xmin, ymax, xmax] in normalized coordinates.

Returns:
  An int32 tensor of shape [batch_size, num_boxes] containing feature indices.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{ops_8py_source_l01003}{1003}} of file \mbox{\hyperlink{ops_8py_source}{ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{01003\ \textcolor{keyword}{def\ }fpn\_feature\_levels(num\_levels,\ unit\_scale\_index,\ image\_ratio,\ boxes):}
\DoxyCodeLine{01004\ \ \ \textcolor{stringliteral}{"{}"{}"{}Returns\ fpn\ feature\ level\ for\ each\ box\ based\ on\ its\ area.}}
\DoxyCodeLine{01005\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01006\ \textcolor{stringliteral}{\ \ See\ section\ 4.2\ of\ https://arxiv.org/pdf/1612.03144.pdf\ }\textcolor{keywordflow}{for}\ details.}
\DoxyCodeLine{01007\ }
\DoxyCodeLine{01008\ \ \ Args:}
\DoxyCodeLine{01009\ \ \ \ \ num\_levels:\ An\ integer\ indicating\ the\ number\ of\ feature\ levels\ to\ crop\ boxes}
\DoxyCodeLine{01010\ \ \ \ \ \ \ \textcolor{keyword}{from}.}
\DoxyCodeLine{01011\ \ \ \ \ unit\_scale\_index:\ An\ 0-\/based\ integer\ indicating\ the\ index\ of\ feature\ map}
\DoxyCodeLine{01012\ \ \ \ \ \ \ which\ most\ closely\ matches\ the\ resolution\ of\ the\ pretrained\ model.}
\DoxyCodeLine{01013\ \ \ \ \ image\_ratio:\ A\ float\ indicating\ the\ ratio\ of\ input\ image\ area\ to\ pretraining}
\DoxyCodeLine{01014\ \ \ \ \ \ \ image\ area.}
\DoxyCodeLine{01015\ \ \ \ \ boxes:\ A\ float\ tensor\ of\ shape\ [batch,\ num\_boxes,\ 4]\ containing\ boxes\ of\ the}
\DoxyCodeLine{01016\ \ \ \ \ \ \ form\ [ymin,\ xmin,\ ymax,\ xmax]\ \textcolor{keywordflow}{in}\ normalized\ coordinates.}
\DoxyCodeLine{01017\ }
\DoxyCodeLine{01018\ \ \ Returns:}
\DoxyCodeLine{01019\ \ \ \ \ An\ int32\ tensor\ of\ shape\ [batch\_size,\ num\_boxes]\ containing\ feature\ indices.}
\DoxyCodeLine{01020\ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{01021\ \textcolor{stringliteral}{\ \ }\textcolor{keyword}{assert}\ num\_levels\ >\ 0,\ (}
\DoxyCodeLine{01022\ \ \ \ \ \ \ \textcolor{stringliteral}{'\`{}num\_levels`\ must\ be\ >\ 0.\ Found\ \{\}'}.format(num\_levels))}
\DoxyCodeLine{01023\ \ \ \textcolor{keyword}{assert}\ unit\_scale\_index\ <\ num\_levels\ \textcolor{keywordflow}{and}\ unit\_scale\_index\ >=\ 0,\ (}
\DoxyCodeLine{01024\ \ \ \ \ \ \ \textcolor{stringliteral}{'\`{}unit\_scale\_index`\ must\ be\ in\ [0,\ \{\}).\ Found\ \{\}.'}.format(}
\DoxyCodeLine{01025\ \ \ \ \ \ \ \ \ \ \ num\_levels,\ unit\_scale\_index))}
\DoxyCodeLine{01026\ \ \ box\_height\_width\ =\ boxes[:,\ :,\ 2:4]\ -\/\ boxes[:,\ :,\ 0:2]}
\DoxyCodeLine{01027\ \ \ areas\_sqrt\ =\ tf.sqrt(tf.reduce\_prod(box\_height\_width,\ axis=2))}
\DoxyCodeLine{01028\ \ \ log\_2\ =\ tf.cast(tf.log(2.0),\ dtype=boxes.dtype)}
\DoxyCodeLine{01029\ \ \ levels\ =\ tf.cast(}
\DoxyCodeLine{01030\ \ \ \ \ \ \ tf.floordiv(tf.log(areas\_sqrt\ *\ image\_ratio),\ log\_2)}
\DoxyCodeLine{01031\ \ \ \ \ \ \ +}
\DoxyCodeLine{01032\ \ \ \ \ \ \ unit\_scale\_index,}
\DoxyCodeLine{01033\ \ \ \ \ \ \ dtype=tf.int32)}
\DoxyCodeLine{01034\ \ \ levels\ =\ tf.maximum(0,\ tf.minimum(num\_levels\ -\/\ 1,\ levels))}
\DoxyCodeLine{01035\ \ \ \textcolor{keywordflow}{return}\ levels}
\DoxyCodeLine{01036\ }
\DoxyCodeLine{01037\ }

\end{DoxyCode}
\Hypertarget{namespacedetection__utils_1_1utils_1_1ops_a4f2f992f354f09d7235817f9787a6454}\label{namespacedetection__utils_1_1utils_1_1ops_a4f2f992f354f09d7235817f9787a6454} 
\index{detection\_utils.utils.ops@{detection\_utils.utils.ops}!gather\_with\_padding\_values@{gather\_with\_padding\_values}}
\index{gather\_with\_padding\_values@{gather\_with\_padding\_values}!detection\_utils.utils.ops@{detection\_utils.utils.ops}}
\doxysubsubsection{\texorpdfstring{gather\_with\_padding\_values()}{gather\_with\_padding\_values()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+utils.\+ops.\+gather\+\_\+with\+\_\+padding\+\_\+values (\begin{DoxyParamCaption}\item[{}]{input\+\_\+tensor,  }\item[{}]{indices,  }\item[{}]{padding\+\_\+value }\end{DoxyParamCaption})}

\begin{DoxyVerb}Gathers elements from tensor and pads `padding_value` for ignore indices.

Gathers elements from `input_tensor` based on `indices`. If there are ignore
indices (which are "-1"s) in `indices`, `padding_value` will be gathered for
those positions.

Args:
  input_tensor: A N-D tensor of shape [M, d_1, d_2 .. d_(N-1)] to gather
    values from.
  indices: A 1-D tensor in which each element is either an index in the
    first dimension of input_tensor or -1.
  padding_value: A (N-1)-D tensor of shape [d_1, d_2 .. d_(N-1)] which will be
    used as gathered value for each ignore index in `indices`.

Returns:
  gathered_tensor: A tensor of shape [L, d_1, d_2 .. d_(N-1)] containing
    values gathered from input_tensor. The first dimension L is equal to the
    length of `indices`.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{ops_8py_source_l01063}{1063}} of file \mbox{\hyperlink{ops_8py_source}{ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{01063\ \textcolor{keyword}{def\ }gather\_with\_padding\_values(input\_tensor,\ indices,\ padding\_value):}
\DoxyCodeLine{01064\ \ \ \textcolor{stringliteral}{"{}"{}"{}Gathers\ elements\ from\ tensor\ and\ pads\ \`{}padding\_value\`{}\ for\ ignore\ indices.}}
\DoxyCodeLine{01065\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01066\ \textcolor{stringliteral}{\ \ Gathers\ elements\ }\textcolor{keyword}{from}\ \`{}input\_tensor\`{}\ based\ on\ \`{}indices\`{}.\ If\ there\ are\ ignore}
\DoxyCodeLine{01067\ \ \ indices\ (which\ are\ \textcolor{stringliteral}{"{}-\/1"{}}s)\ \textcolor{keywordflow}{in}\ \`{}indices\`{},\ \`{}padding\_value\`{}\ will\ be\ gathered\ \textcolor{keywordflow}{for}}
\DoxyCodeLine{01068\ \ \ those\ positions.}
\DoxyCodeLine{01069\ }
\DoxyCodeLine{01070\ \ \ Args:}
\DoxyCodeLine{01071\ \ \ \ \ input\_tensor:\ A\ N-\/D\ tensor\ of\ shape\ [M,\ d\_1,\ d\_2\ ..\ d\_(N-\/1)]\ to\ gather}
\DoxyCodeLine{01072\ \ \ \ \ \ \ values\ \textcolor{keyword}{from}.}
\DoxyCodeLine{01073\ \ \ \ \ indices:\ A\ 1-\/D\ tensor\ \textcolor{keywordflow}{in}\ which\ each\ element\ \textcolor{keywordflow}{is}\ either\ an\ index\ \textcolor{keywordflow}{in}\ the}
\DoxyCodeLine{01074\ \ \ \ \ \ \ first\ dimension\ of\ input\_tensor\ \textcolor{keywordflow}{or}\ -\/1.}
\DoxyCodeLine{01075\ \ \ \ \ padding\_value:\ A\ (N-\/1)-\/D\ tensor\ of\ shape\ [d\_1,\ d\_2\ ..\ d\_(N-\/1)]\ which\ will\ be}
\DoxyCodeLine{01076\ \ \ \ \ \ \ used\ \textcolor{keyword}{as}\ gathered\ value\ \textcolor{keywordflow}{for}\ each\ ignore\ index\ \textcolor{keywordflow}{in}\ \`{}indices\`{}.}
\DoxyCodeLine{01077\ }
\DoxyCodeLine{01078\ \ \ Returns:}
\DoxyCodeLine{01079\ \ \ \ \ gathered\_tensor:\ A\ tensor\ of\ shape\ [L,\ d\_1,\ d\_2\ ..\ d\_(N-\/1)]\ containing}
\DoxyCodeLine{01080\ \ \ \ \ \ \ values\ gathered\ \textcolor{keyword}{from}\ input\_tensor.\ The\ first\ dimension\ L\ \textcolor{keywordflow}{is}\ equal\ to\ the}
\DoxyCodeLine{01081\ \ \ \ \ \ \ length\ of\ \`{}indices\`{}.}
\DoxyCodeLine{01082\ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{01083\ \textcolor{stringliteral}{\ \ padding\_value\ =\ tf.expand\_dims(padding\_value,\ axis=0)}}
\DoxyCodeLine{01084\ \textcolor{stringliteral}{\ \ input\_tensor\ =\ tf.concat([padding\_value,\ input\_tensor],\ axis=0)}}
\DoxyCodeLine{01085\ \textcolor{stringliteral}{\ \ gather\_indices\ =\ indices\ +\ 1}}
\DoxyCodeLine{01086\ \textcolor{stringliteral}{\ \ gathered\_tensor\ =\ tf.gather(input\_tensor,\ gather\_indices)}}
\DoxyCodeLine{01087\ \textcolor{stringliteral}{\ \ }\textcolor{keywordflow}{return}\ gathered\_tensor}
\DoxyCodeLine{01088\ }
\DoxyCodeLine{01089\ }
\DoxyCodeLine{01090\ }
\DoxyCodeLine{01091\ }
\DoxyCodeLine{01092\ }

\end{DoxyCode}
\Hypertarget{namespacedetection__utils_1_1utils_1_1ops_a9fad235f916265ec93571df2b5269b46}\label{namespacedetection__utils_1_1utils_1_1ops_a9fad235f916265ec93571df2b5269b46} 
\index{detection\_utils.utils.ops@{detection\_utils.utils.ops}!indices\_to\_dense\_vector@{indices\_to\_dense\_vector}}
\index{indices\_to\_dense\_vector@{indices\_to\_dense\_vector}!detection\_utils.utils.ops@{detection\_utils.utils.ops}}
\doxysubsubsection{\texorpdfstring{indices\_to\_dense\_vector()}{indices\_to\_dense\_vector()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+utils.\+ops.\+indices\+\_\+to\+\_\+dense\+\_\+vector (\begin{DoxyParamCaption}\item[{}]{indices,  }\item[{}]{size,  }\item[{}]{indices\+\_\+value = {\ttfamily 1.},  }\item[{}]{default\+\_\+value = {\ttfamily 0},  }\item[{}]{dtype = {\ttfamily tf.float32} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Creates dense vector with indices set to specific value and rest to zeros.

This function exists because it is unclear if it is safe to use
  tf.sparse_to_dense(indices, [size], 1, validate_indices=False)
with indices which are not ordered.
This function accepts a dynamic size (e.g. tf.shape(tensor)[0])

Args:
  indices: 1d Tensor with integer indices which are to be set to
      indices_values.
  size: scalar with size (integer) of output Tensor.
  indices_value: values of elements specified by indices in the output vector
  default_value: values of other elements in the output vector.
  dtype: data type.

Returns:
  dense 1D Tensor of shape [size] with indices set to indices_values and the
      rest set to default_value.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{ops_8py_source_l00306}{306}} of file \mbox{\hyperlink{ops_8py_source}{ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00310\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ dtype=tf.float32):}
\DoxyCodeLine{00311\ \ \ \textcolor{stringliteral}{"{}"{}"{}Creates\ dense\ vector\ with\ indices\ set\ to\ specific\ value\ and\ rest\ to\ zeros.}}
\DoxyCodeLine{00312\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00313\ \textcolor{stringliteral}{\ \ This\ function\ exists\ because\ it\ }\textcolor{keywordflow}{is}\ unclear\ \textcolor{keywordflow}{if}\ it\ \textcolor{keywordflow}{is}\ safe\ to\ use}
\DoxyCodeLine{00314\ \ \ \ \ tf.sparse\_to\_dense(indices,\ [size],\ 1,\ validate\_indices=\textcolor{keyword}{False})}
\DoxyCodeLine{00315\ \ \ \textcolor{keyword}{with}\ indices\ which\ are\ \textcolor{keywordflow}{not}\ ordered.}
\DoxyCodeLine{00316\ \ \ This\ function\ accepts\ a\ dynamic\ size\ (e.g.\ tf.shape(tensor)[0])}
\DoxyCodeLine{00317\ }
\DoxyCodeLine{00318\ \ \ Args:}
\DoxyCodeLine{00319\ \ \ \ \ indices:\ 1d\ Tensor\ \textcolor{keyword}{with}\ integer\ indices\ which\ are\ to\ be\ set\ to}
\DoxyCodeLine{00320\ \ \ \ \ \ \ \ \ indices\_values.}
\DoxyCodeLine{00321\ \ \ \ \ size:\ scalar\ \textcolor{keyword}{with}\ size\ (integer)\ of\ output\ Tensor.}
\DoxyCodeLine{00322\ \ \ \ \ indices\_value:\ values\ of\ elements\ specified\ by\ indices\ \textcolor{keywordflow}{in}\ the\ output\ vector}
\DoxyCodeLine{00323\ \ \ \ \ default\_value:\ values\ of\ other\ elements\ \textcolor{keywordflow}{in}\ the\ output\ vector.}
\DoxyCodeLine{00324\ \ \ \ \ dtype:\ data\ type.}
\DoxyCodeLine{00325\ }
\DoxyCodeLine{00326\ \ \ Returns:}
\DoxyCodeLine{00327\ \ \ \ \ dense\ 1D\ Tensor\ of\ shape\ [size]\ \textcolor{keyword}{with}\ indices\ set\ to\ indices\_values\ \textcolor{keywordflow}{and}\ the}
\DoxyCodeLine{00328\ \ \ \ \ \ \ \ \ rest\ set\ to\ default\_value.}
\DoxyCodeLine{00329\ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{00330\ \textcolor{stringliteral}{\ \ size\ =\ tf.cast(size,\ dtype=tf.int32)}}
\DoxyCodeLine{00331\ \textcolor{stringliteral}{\ \ zeros\ =\ tf.ones([size],\ dtype=dtype)\ *\ default\_value}}
\DoxyCodeLine{00332\ \textcolor{stringliteral}{\ \ values\ =\ tf.ones\_like(indices,\ dtype=dtype)\ *\ indices\_value}}
\DoxyCodeLine{00333\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00334\ \textcolor{stringliteral}{\ \ }\textcolor{keywordflow}{return}\ tf.dynamic\_stitch([tf.range(size),\ tf.cast(indices,\ dtype=tf.int32)],}
\DoxyCodeLine{00335\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ [zeros,\ values])}
\DoxyCodeLine{00336\ }
\DoxyCodeLine{00337\ }

\end{DoxyCode}
\Hypertarget{namespacedetection__utils_1_1utils_1_1ops_a6323da655ab0d0f545c213c5b0382b7f}\label{namespacedetection__utils_1_1utils_1_1ops_a6323da655ab0d0f545c213c5b0382b7f} 
\index{detection\_utils.utils.ops@{detection\_utils.utils.ops}!matmul\_gather\_on\_zeroth\_axis@{matmul\_gather\_on\_zeroth\_axis}}
\index{matmul\_gather\_on\_zeroth\_axis@{matmul\_gather\_on\_zeroth\_axis}!detection\_utils.utils.ops@{detection\_utils.utils.ops}}
\doxysubsubsection{\texorpdfstring{matmul\_gather\_on\_zeroth\_axis()}{matmul\_gather\_on\_zeroth\_axis()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+utils.\+ops.\+matmul\+\_\+gather\+\_\+on\+\_\+zeroth\+\_\+axis (\begin{DoxyParamCaption}\item[{}]{params,  }\item[{}]{indices,  }\item[{}]{scope = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Matrix multiplication based implementation of tf.gather on zeroth axis.

TODO(rathodv, jonathanhuang): enable sparse matmul option.

Args:
  params: A float32 Tensor. The tensor from which to gather values.
    Must be at least rank 1.
  indices: A Tensor. Must be one of the following types: int32, int64.
    Must be in range [0, params.shape[0])
  scope: A name for the operation (optional).

Returns:
  A Tensor. Has the same type as params. Values from params gathered
  from indices given by indices, with shape indices.shape + params.shape[1:].
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{ops_8py_source_l00977}{977}} of file \mbox{\hyperlink{ops_8py_source}{ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00977\ \textcolor{keyword}{def\ }matmul\_gather\_on\_zeroth\_axis(params,\ indices,\ scope=None):}
\DoxyCodeLine{00978\ \ \ \textcolor{stringliteral}{"{}"{}"{}Matrix\ multiplication\ based\ implementation\ of\ tf.gather\ on\ zeroth\ axis.}}
\DoxyCodeLine{00979\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00980\ \textcolor{stringliteral}{\ \ TODO(rathodv,\ jonathanhuang):\ enable\ sparse\ matmul\ option.}}
\DoxyCodeLine{00981\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00982\ \textcolor{stringliteral}{\ \ Args:}}
\DoxyCodeLine{00983\ \textcolor{stringliteral}{\ \ \ \ params:\ A\ float32\ Tensor.\ The\ tensor\ }\textcolor{keyword}{from}\ which\ to\ gather\ values.}
\DoxyCodeLine{00984\ \ \ \ \ \ \ Must\ be\ at\ least\ rank\ 1.}
\DoxyCodeLine{00985\ \ \ \ \ indices:\ A\ Tensor.\ Must\ be\ one\ of\ the\ following\ types:\ int32,\ int64.}
\DoxyCodeLine{00986\ \ \ \ \ \ \ Must\ be\ \textcolor{keywordflow}{in}\ range\ [0,\ params.shape[0])}
\DoxyCodeLine{00987\ \ \ \ \ scope:\ A\ name\ \textcolor{keywordflow}{for}\ the\ operation\ (optional).}
\DoxyCodeLine{00988\ }
\DoxyCodeLine{00989\ \ \ Returns:}
\DoxyCodeLine{00990\ \ \ \ \ A\ Tensor.\ Has\ the\ same\ type\ \textcolor{keyword}{as}\ params.\ Values\ \textcolor{keyword}{from}\ params\ gathered}
\DoxyCodeLine{00991\ \ \ \ \ \textcolor{keyword}{from}\ indices\ given\ by\ indices,\ \textcolor{keyword}{with}\ shape\ indices.shape\ +\ params.shape[1:].}
\DoxyCodeLine{00992\ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{00993\ \textcolor{stringliteral}{\ \ }\textcolor{keyword}{with}\ tf.name\_scope(scope,\ \textcolor{stringliteral}{'MatMulGather'}):}
\DoxyCodeLine{00994\ \ \ \ \ params\_shape\ =\ shape\_utils.combined\_static\_and\_dynamic\_shape(params)}
\DoxyCodeLine{00995\ \ \ \ \ indices\_shape\ =\ shape\_utils.combined\_static\_and\_dynamic\_shape(indices)}
\DoxyCodeLine{00996\ \ \ \ \ params2d\ =\ tf.reshape(params,\ [params\_shape[0],\ -\/1])}
\DoxyCodeLine{00997\ \ \ \ \ indicator\_matrix\ =\ tf.one\_hot(indices,\ params\_shape[0])}
\DoxyCodeLine{00998\ \ \ \ \ gathered\_result\_flattened\ =\ tf.matmul(indicator\_matrix,\ params2d)}
\DoxyCodeLine{00999\ \ \ \ \ \textcolor{keywordflow}{return}\ tf.reshape(gathered\_result\_flattened,}
\DoxyCodeLine{01000\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ tf.stack(indices\_shape\ +\ params\_shape[1:]))}
\DoxyCodeLine{01001\ }
\DoxyCodeLine{01002\ }

\end{DoxyCode}
\Hypertarget{namespacedetection__utils_1_1utils_1_1ops_aa05d5979ad4881e4f972be53d5b4200d}\label{namespacedetection__utils_1_1utils_1_1ops_aa05d5979ad4881e4f972be53d5b4200d} 
\index{detection\_utils.utils.ops@{detection\_utils.utils.ops}!merge\_boxes\_with\_multiple\_labels@{merge\_boxes\_with\_multiple\_labels}}
\index{merge\_boxes\_with\_multiple\_labels@{merge\_boxes\_with\_multiple\_labels}!detection\_utils.utils.ops@{detection\_utils.utils.ops}}
\doxysubsubsection{\texorpdfstring{merge\_boxes\_with\_multiple\_labels()}{merge\_boxes\_with\_multiple\_labels()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+utils.\+ops.\+merge\+\_\+boxes\+\_\+with\+\_\+multiple\+\_\+labels (\begin{DoxyParamCaption}\item[{}]{boxes,  }\item[{}]{classes,  }\item[{}]{confidences,  }\item[{}]{num\+\_\+classes,  }\item[{}]{quantization\+\_\+bins = {\ttfamily 10000} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Merges boxes with same coordinates and returns K-hot encoded classes.

Args:
  boxes: A tf.float32 tensor with shape [N, 4] holding N boxes. Only
    normalized coordinates are allowed.
  classes: A tf.int32 tensor with shape [N] holding class indices.
    The class index starts at 0.
  confidences: A tf.float32 tensor with shape [N] holding class confidences.
  num_classes: total number of classes to use for K-hot encoding.
  quantization_bins: the number of bins used to quantize the box coordinate.

Returns:
  merged_boxes: A tf.float32 tensor with shape [N', 4] holding boxes,
    where N' <= N.
  class_encodings: A tf.int32 tensor with shape [N', num_classes] holding
    K-hot encodings for the merged boxes.
  confidence_encodings: A tf.float32 tensor with shape [N', num_classes]
    holding encodings of confidences for the merged boxes.
  merged_box_indices: A tf.int32 tensor with shape [N'] holding original
    indices of the boxes.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{ops_8py_source_l00849}{849}} of file \mbox{\hyperlink{ops_8py_source}{ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00853\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ quantization\_bins=10000):}
\DoxyCodeLine{00854\ \ \ \textcolor{stringliteral}{"{}"{}"{}Merges\ boxes\ with\ same\ coordinates\ and\ returns\ K-\/hot\ encoded\ classes.}}
\DoxyCodeLine{00855\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00856\ \textcolor{stringliteral}{\ \ Args:}}
\DoxyCodeLine{00857\ \textcolor{stringliteral}{\ \ \ \ boxes:\ A\ tf.float32\ tensor\ }\textcolor{keyword}{with}\ shape\ [N,\ 4]\ holding\ N\ boxes.\ Only}
\DoxyCodeLine{00858\ \ \ \ \ \ \ normalized\ coordinates\ are\ allowed.}
\DoxyCodeLine{00859\ \ \ \ \ classes:\ A\ tf.int32\ tensor\ \textcolor{keyword}{with}\ shape\ [N]\ holding\ \textcolor{keyword}{class\ }indices.}
\DoxyCodeLine{00860\ \ \ \ \ \ \ The\ \textcolor{keyword}{class\ }index\ starts\ at\ 0.}
\DoxyCodeLine{00861\ \ \ \ \ confidences:\ A\ tf.float32\ tensor\ \textcolor{keyword}{with}\ shape\ [N]\ holding\ \textcolor{keyword}{class\ }confidences.}
\DoxyCodeLine{00862\ \ \ \ \ num\_classes:\ total\ number\ of\ classes\ to\ use\ \textcolor{keywordflow}{for}\ K-\/hot\ encoding.}
\DoxyCodeLine{00863\ \ \ \ \ quantization\_bins:\ the\ number\ of\ bins\ used\ to\ quantize\ the\ box\ coordinate.}
\DoxyCodeLine{00864\ }
\DoxyCodeLine{00865\ \ \ Returns:}
\DoxyCodeLine{00866\ \ \ \ \ merged\_boxes:\ A\ tf.float32\ tensor\ \textcolor{keyword}{with}\ shape\ [N\textcolor{stringliteral}{',\ 4]\ holding\ boxes,}}
\DoxyCodeLine{00867\ \textcolor{stringliteral}{\ \ \ \ \ \ where\ N'\ <=\ N.}}
\DoxyCodeLine{00868\ \textcolor{stringliteral}{\ \ \ \ class\_encodings:\ A\ tf.int32\ tensor\ }\textcolor{keyword}{with}\ shape\ [N\textcolor{stringliteral}{',\ num\_classes]\ holding}}
\DoxyCodeLine{00869\ \textcolor{stringliteral}{\ \ \ \ \ \ K-\/hot\ encodings\ }\textcolor{keywordflow}{for}\ the\ merged\ boxes.}
\DoxyCodeLine{00870\ \ \ \ \ confidence\_encodings:\ A\ tf.float32\ tensor\ \textcolor{keyword}{with}\ shape\ [N\textcolor{stringliteral}{',\ num\_classes]}}
\DoxyCodeLine{00871\ \textcolor{stringliteral}{\ \ \ \ \ \ holding\ encodings\ of\ confidences\ }\textcolor{keywordflow}{for}\ the\ merged\ boxes.}
\DoxyCodeLine{00872\ \ \ \ \ merged\_box\_indices:\ A\ tf.int32\ tensor\ \textcolor{keyword}{with}\ shape\ [N\textcolor{stringliteral}{']\ holding\ original}}
\DoxyCodeLine{00873\ \textcolor{stringliteral}{\ \ \ \ \ \ indices\ of\ the\ boxes.}}
\DoxyCodeLine{00874\ \textcolor{stringliteral}{\ \ "{}"{}"{}}}
\DoxyCodeLine{00875\ \textcolor{stringliteral}{\ \ boxes\_shape\ =\ tf.shape(boxes)}}
\DoxyCodeLine{00876\ \textcolor{stringliteral}{\ \ classes\_shape\ =\ tf.shape(classes)}}
\DoxyCodeLine{00877\ \textcolor{stringliteral}{\ \ confidences\_shape\ =\ tf.shape(confidences)}}
\DoxyCodeLine{00878\ \textcolor{stringliteral}{\ \ box\_class\_shape\_assert\ =\ shape\_utils.assert\_shape\_equal\_along\_first\_dimension(}}
\DoxyCodeLine{00879\ \textcolor{stringliteral}{\ \ \ \ \ \ boxes\_shape,\ classes\_shape)}}
\DoxyCodeLine{00880\ \textcolor{stringliteral}{\ \ box\_confidence\_shape\_assert\ =\ (}}
\DoxyCodeLine{00881\ \textcolor{stringliteral}{\ \ \ \ \ \ shape\_utils.assert\_shape\_equal\_along\_first\_dimension(}}
\DoxyCodeLine{00882\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ boxes\_shape,\ confidences\_shape))}}
\DoxyCodeLine{00883\ \textcolor{stringliteral}{\ \ box\_dimension\_assert\ =\ tf.assert\_equal(boxes\_shape[1],\ 4)}}
\DoxyCodeLine{00884\ \textcolor{stringliteral}{\ \ box\_normalized\_assert\ =\ shape\_utils.assert\_box\_normalized(boxes)}}
\DoxyCodeLine{00885\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00886\ \textcolor{stringliteral}{\ \ }\textcolor{keyword}{with}\ tf.control\_dependencies(}
\DoxyCodeLine{00887\ \ \ \ \ \ \ [box\_class\_shape\_assert,\ box\_confidence\_shape\_assert,}
\DoxyCodeLine{00888\ \ \ \ \ \ \ \ box\_dimension\_assert,\ box\_normalized\_assert]):}
\DoxyCodeLine{00889\ \ \ \ \ quantized\_boxes\ =\ tf.to\_int64(boxes\ *\ (quantization\_bins\ -\/\ 1))}
\DoxyCodeLine{00890\ \ \ \ \ ymin,\ xmin,\ ymax,\ xmax\ =\ tf.unstack(quantized\_boxes,\ axis=1)}
\DoxyCodeLine{00891\ \ \ \ \ hashcodes\ =\ (}
\DoxyCodeLine{00892\ \ \ \ \ \ \ \ \ ymin\ +}
\DoxyCodeLine{00893\ \ \ \ \ \ \ \ \ xmin\ *\ quantization\_bins\ +}
\DoxyCodeLine{00894\ \ \ \ \ \ \ \ \ ymax\ *\ quantization\_bins\ *\ quantization\_bins\ +}
\DoxyCodeLine{00895\ \ \ \ \ \ \ \ \ xmax\ *\ quantization\_bins\ *\ quantization\_bins\ *\ quantization\_bins)}
\DoxyCodeLine{00896\ \ \ \ \ unique\_hashcodes,\ unique\_indices\ =\ tf.unique(hashcodes)}
\DoxyCodeLine{00897\ \ \ \ \ num\_boxes\ =\ tf.shape(boxes)[0]}
\DoxyCodeLine{00898\ \ \ \ \ num\_unique\_boxes\ =\ tf.shape(unique\_hashcodes)[0]}
\DoxyCodeLine{00899\ \ \ \ \ merged\_box\_indices\ =\ tf.unsorted\_segment\_min(}
\DoxyCodeLine{00900\ \ \ \ \ \ \ \ \ tf.range(num\_boxes),\ unique\_indices,\ num\_unique\_boxes)}
\DoxyCodeLine{00901\ \ \ \ \ merged\_boxes\ =\ tf.gather(boxes,\ merged\_box\_indices)}
\DoxyCodeLine{00902\ \ \ \ \ unique\_indices\ =\ tf.to\_int64(unique\_indices)}
\DoxyCodeLine{00903\ \ \ \ \ classes\ =\ tf.to\_int64(classes)}
\DoxyCodeLine{00904\ }
\DoxyCodeLine{00905\ \ \ \ \ \textcolor{keyword}{def\ }map\_box\_encodings(i):}
\DoxyCodeLine{00906\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}"{}"{}Produces\ box\ K-\/hot\ and\ score\ encodings\ for\ each\ class\ index."{}"{}"{}}}
\DoxyCodeLine{00907\ \ \ \ \ \ \ box\_mask\ =\ tf.equal(}
\DoxyCodeLine{00908\ \ \ \ \ \ \ \ \ \ \ unique\_indices,\ i\ *\ tf.ones(num\_boxes,\ dtype=tf.int64))}
\DoxyCodeLine{00909\ \ \ \ \ \ \ box\_mask\ =\ tf.reshape(box\_mask,\ [-\/1])}
\DoxyCodeLine{00910\ \ \ \ \ \ \ box\_indices\ =\ tf.boolean\_mask(classes,\ box\_mask)}
\DoxyCodeLine{00911\ \ \ \ \ \ \ box\_confidences\ =\ tf.boolean\_mask(confidences,\ box\_mask)}
\DoxyCodeLine{00912\ \ \ \ \ \ \ box\_class\_encodings\ =\ tf.sparse\_to\_dense(}
\DoxyCodeLine{00913\ \ \ \ \ \ \ \ \ \ \ box\_indices,\ [num\_classes],\ tf.constant(1,\ dtype=tf.int64),}
\DoxyCodeLine{00914\ \ \ \ \ \ \ \ \ \ \ validate\_indices=\textcolor{keyword}{False})}
\DoxyCodeLine{00915\ \ \ \ \ \ \ box\_confidence\_encodings\ =\ tf.sparse\_to\_dense(}
\DoxyCodeLine{00916\ \ \ \ \ \ \ \ \ \ \ box\_indices,\ [num\_classes],\ box\_confidences,\ validate\_indices=\textcolor{keyword}{False})}
\DoxyCodeLine{00917\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ box\_class\_encodings,\ box\_confidence\_encodings}
\DoxyCodeLine{00918\ }
\DoxyCodeLine{00919\ \ \ \ \ \textcolor{comment}{\#\ Important\ to\ avoid\ int32\ here\ since\ there\ is\ no\ GPU\ kernel\ for\ int32.}}
\DoxyCodeLine{00920\ \ \ \ \ \textcolor{comment}{\#\ int64\ and\ float32\ are\ fine.}}
\DoxyCodeLine{00921\ \ \ \ \ class\_encodings,\ confidence\_encodings\ =\ tf.map\_fn(}
\DoxyCodeLine{00922\ \ \ \ \ \ \ \ \ map\_box\_encodings,}
\DoxyCodeLine{00923\ \ \ \ \ \ \ \ \ tf.range(tf.to\_int64(num\_unique\_boxes)),}
\DoxyCodeLine{00924\ \ \ \ \ \ \ \ \ back\_prop=\textcolor{keyword}{False},}
\DoxyCodeLine{00925\ \ \ \ \ \ \ \ \ dtype=(tf.int64,\ tf.float32))}
\DoxyCodeLine{00926\ }
\DoxyCodeLine{00927\ \ \ \ \ merged\_boxes\ =\ tf.reshape(merged\_boxes,\ [-\/1,\ 4])}
\DoxyCodeLine{00928\ \ \ \ \ class\_encodings\ =\ tf.cast(class\_encodings,\ dtype=tf.int32)}
\DoxyCodeLine{00929\ \ \ \ \ class\_encodings\ =\ tf.reshape(class\_encodings,\ [-\/1,\ num\_classes])}
\DoxyCodeLine{00930\ \ \ \ \ confidence\_encodings\ =\ tf.reshape(confidence\_encodings,\ [-\/1,\ num\_classes])}
\DoxyCodeLine{00931\ \ \ \ \ merged\_box\_indices\ =\ tf.reshape(merged\_box\_indices,\ [-\/1])}
\DoxyCodeLine{00932\ \ \ \ \ \textcolor{keywordflow}{return}\ (merged\_boxes,\ class\_encodings,\ confidence\_encodings,}
\DoxyCodeLine{00933\ \ \ \ \ \ \ \ \ \ \ \ \ merged\_box\_indices)}
\DoxyCodeLine{00934\ }
\DoxyCodeLine{00935\ }

\end{DoxyCode}
\Hypertarget{namespacedetection__utils_1_1utils_1_1ops_af311e77e054cb389029fd2e4a40c2955}\label{namespacedetection__utils_1_1utils_1_1ops_af311e77e054cb389029fd2e4a40c2955} 
\index{detection\_utils.utils.ops@{detection\_utils.utils.ops}!meshgrid@{meshgrid}}
\index{meshgrid@{meshgrid}!detection\_utils.utils.ops@{detection\_utils.utils.ops}}
\doxysubsubsection{\texorpdfstring{meshgrid()}{meshgrid()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+utils.\+ops.\+meshgrid (\begin{DoxyParamCaption}\item[{}]{x,  }\item[{}]{y }\end{DoxyParamCaption})}

\begin{DoxyVerb}Tiles the contents of x and y into a pair of grids.

Multidimensional analog of numpy.meshgrid, giving the same behavior if x and y
are vectors. Generally, this will give:

xgrid(i1, ..., i_m, j_1, ..., j_n) = x(j_1, ..., j_n)
ygrid(i1, ..., i_m, j_1, ..., j_n) = y(i_1, ..., i_m)

Keep in mind that the order of the arguments and outputs is reverse relative
to the order of the indices they go into, done for compatibility with numpy.
The output tensors have the same shapes.  Specifically:

xgrid.get_shape() = y.get_shape().concatenate(x.get_shape())
ygrid.get_shape() = y.get_shape().concatenate(x.get_shape())

Args:
  x: A tensor of arbitrary shape and rank. xgrid will contain these values
     varying in its last dimensions.
  y: A tensor of arbitrary shape and rank. ygrid will contain these values
     varying in its first dimensions.
Returns:
  A tuple of tensors (xgrid, ygrid).
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{ops_8py_source_l00099}{99}} of file \mbox{\hyperlink{ops_8py_source}{ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00099\ \textcolor{keyword}{def\ }meshgrid(x,\ y):}
\DoxyCodeLine{00100\ \ \ \textcolor{stringliteral}{"{}"{}"{}Tiles\ the\ contents\ of\ x\ and\ y\ into\ a\ pair\ of\ grids.}}
\DoxyCodeLine{00101\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00102\ \textcolor{stringliteral}{\ \ Multidimensional\ analog\ of\ numpy.meshgrid,\ giving\ the\ same\ behavior\ }\textcolor{keywordflow}{if}\ x\ \textcolor{keywordflow}{and}\ y}
\DoxyCodeLine{00103\ \ \ are\ vectors.\ Generally,\ this\ will\ give:}
\DoxyCodeLine{00104\ }
\DoxyCodeLine{00105\ \ \ xgrid(i1,\ ...,\ i\_m,\ j\_1,\ ...,\ j\_n)\ =\ x(j\_1,\ ...,\ j\_n)}
\DoxyCodeLine{00106\ \ \ ygrid(i1,\ ...,\ i\_m,\ j\_1,\ ...,\ j\_n)\ =\ y(i\_1,\ ...,\ i\_m)}
\DoxyCodeLine{00107\ }
\DoxyCodeLine{00108\ \ \ Keep\ \textcolor{keywordflow}{in}\ mind\ that\ the\ order\ of\ the\ arguments\ \textcolor{keywordflow}{and}\ outputs\ \textcolor{keywordflow}{is}\ reverse\ relative}
\DoxyCodeLine{00109\ \ \ to\ the\ order\ of\ the\ indices\ they\ go\ into,\ done\ \textcolor{keywordflow}{for}\ compatibility\ \textcolor{keyword}{with}\ numpy.}
\DoxyCodeLine{00110\ \ \ The\ output\ tensors\ have\ the\ same\ shapes.\ \ Specifically:}
\DoxyCodeLine{00111\ }
\DoxyCodeLine{00112\ \ \ xgrid.get\_shape()\ =\ y.get\_shape().concatenate(x.get\_shape())}
\DoxyCodeLine{00113\ \ \ ygrid.get\_shape()\ =\ y.get\_shape().concatenate(x.get\_shape())}
\DoxyCodeLine{00114\ }
\DoxyCodeLine{00115\ \ \ Args:}
\DoxyCodeLine{00116\ \ \ \ \ x:\ A\ tensor\ of\ arbitrary\ shape\ \textcolor{keywordflow}{and}\ rank.\ xgrid\ will\ contain\ these\ values}
\DoxyCodeLine{00117\ \ \ \ \ \ \ \ varying\ \textcolor{keywordflow}{in}\ its\ last\ dimensions.}
\DoxyCodeLine{00118\ \ \ \ \ y:\ A\ tensor\ of\ arbitrary\ shape\ \textcolor{keywordflow}{and}\ rank.\ ygrid\ will\ contain\ these\ values}
\DoxyCodeLine{00119\ \ \ \ \ \ \ \ varying\ \textcolor{keywordflow}{in}\ its\ first\ dimensions.}
\DoxyCodeLine{00120\ \ \ Returns:}
\DoxyCodeLine{00121\ \ \ \ \ A\ tuple\ of\ tensors\ (xgrid,\ ygrid).}
\DoxyCodeLine{00122\ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{00123\ \textcolor{stringliteral}{\ \ }\textcolor{keyword}{with}\ tf.name\_scope(\textcolor{stringliteral}{'Meshgrid'}):}
\DoxyCodeLine{00124\ \ \ \ \ x\ =\ tf.convert\_to\_tensor(x)}
\DoxyCodeLine{00125\ \ \ \ \ y\ =\ tf.convert\_to\_tensor(y)}
\DoxyCodeLine{00126\ \ \ \ \ x\_exp\_shape\ =\ expanded\_shape(tf.shape(x),\ 0,\ tf.rank(y))}
\DoxyCodeLine{00127\ \ \ \ \ y\_exp\_shape\ =\ expanded\_shape(tf.shape(y),\ tf.rank(y),\ tf.rank(x))}
\DoxyCodeLine{00128\ }
\DoxyCodeLine{00129\ \ \ \ \ xgrid\ =\ tf.tile(tf.reshape(x,\ x\_exp\_shape),\ y\_exp\_shape)}
\DoxyCodeLine{00130\ \ \ \ \ ygrid\ =\ tf.tile(tf.reshape(y,\ y\_exp\_shape),\ x\_exp\_shape)}
\DoxyCodeLine{00131\ \ \ \ \ new\_shape\ =\ y.get\_shape().concatenate(x.get\_shape())}
\DoxyCodeLine{00132\ \ \ \ \ xgrid.set\_shape(new\_shape)}
\DoxyCodeLine{00133\ \ \ \ \ ygrid.set\_shape(new\_shape)}
\DoxyCodeLine{00134\ }
\DoxyCodeLine{00135\ \ \ \ \ \textcolor{keywordflow}{return}\ xgrid,\ ygrid}
\DoxyCodeLine{00136\ }
\DoxyCodeLine{00137\ }

\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{db/d47/namespacedetection__utils_1_1utils_1_1ops_af311e77e054cb389029fd2e4a40c2955_cgraph}
\end{center}
\end{figure}
\Hypertarget{namespacedetection__utils_1_1utils_1_1ops_adc950a7496c9cea7a96d5fe6acd77d82}\label{namespacedetection__utils_1_1utils_1_1ops_adc950a7496c9cea7a96d5fe6acd77d82} 
\index{detection\_utils.utils.ops@{detection\_utils.utils.ops}!nearest\_neighbor\_upsampling@{nearest\_neighbor\_upsampling}}
\index{nearest\_neighbor\_upsampling@{nearest\_neighbor\_upsampling}!detection\_utils.utils.ops@{detection\_utils.utils.ops}}
\doxysubsubsection{\texorpdfstring{nearest\_neighbor\_upsampling()}{nearest\_neighbor\_upsampling()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+utils.\+ops.\+nearest\+\_\+neighbor\+\_\+upsampling (\begin{DoxyParamCaption}\item[{}]{input\+\_\+tensor,  }\item[{}]{scale = {\ttfamily None},  }\item[{}]{height\+\_\+scale = {\ttfamily None},  }\item[{}]{width\+\_\+scale = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Nearest neighbor upsampling implementation.

Nearest neighbor upsampling function that maps input tensor with shape
[batch_size, height, width, channels] to [batch_size, height * scale
, width * scale, channels]. This implementation only uses reshape and
broadcasting to make it TPU compatible.

Args:
  input_tensor: A float32 tensor of size [batch, height_in, width_in,
    channels].
  scale: An integer multiple to scale resolution of input data in both height
    and width dimensions.
  height_scale: An integer multiple to scale the height of input image. This
    option when provided overrides `scale` option.
  width_scale: An integer multiple to scale the width of input image. This
    option when provided overrides `scale` option.
Returns:
  data_up: A float32 tensor of size
    [batch, height_in*scale, width_in*scale, channels].

Raises:
  ValueError: If both scale and height_scale or if both scale and width_scale
    are None.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{ops_8py_source_l00936}{936}} of file \mbox{\hyperlink{ops_8py_source}{ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00937\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ width\_scale=\textcolor{keywordtype}{None}):}
\DoxyCodeLine{00938\ \ \ \textcolor{stringliteral}{"{}"{}"{}Nearest\ neighbor\ upsampling\ implementation.}}
\DoxyCodeLine{00939\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00940\ \textcolor{stringliteral}{\ \ Nearest\ neighbor\ upsampling\ function\ that\ maps\ input\ tensor\ }\textcolor{keyword}{with}\ shape}
\DoxyCodeLine{00941\ \ \ [batch\_size,\ height,\ width,\ channels]\ to\ [batch\_size,\ height\ *\ scale}
\DoxyCodeLine{00942\ \ \ ,\ width\ *\ scale,\ channels].\ This\ implementation\ only\ uses\ reshape\ \textcolor{keywordflow}{and}}
\DoxyCodeLine{00943\ \ \ broadcasting\ to\ make\ it\ TPU\ compatible.}
\DoxyCodeLine{00944\ }
\DoxyCodeLine{00945\ \ \ Args:}
\DoxyCodeLine{00946\ \ \ \ \ input\_tensor:\ A\ float32\ tensor\ of\ size\ [batch,\ height\_in,\ width\_in,}
\DoxyCodeLine{00947\ \ \ \ \ \ \ channels].}
\DoxyCodeLine{00948\ \ \ \ \ scale:\ An\ integer\ multiple\ to\ scale\ resolution\ of\ input\ data\ \textcolor{keywordflow}{in}\ both\ height}
\DoxyCodeLine{00949\ \ \ \ \ \ \ \textcolor{keywordflow}{and}\ width\ dimensions.}
\DoxyCodeLine{00950\ \ \ \ \ height\_scale:\ An\ integer\ multiple\ to\ scale\ the\ height\ of\ input\ image.\ This}
\DoxyCodeLine{00951\ \ \ \ \ \ \ option\ when\ provided\ overrides\ \`{}scale\`{}\ option.}
\DoxyCodeLine{00952\ \ \ \ \ width\_scale:\ An\ integer\ multiple\ to\ scale\ the\ width\ of\ input\ image.\ This}
\DoxyCodeLine{00953\ \ \ \ \ \ \ option\ when\ provided\ overrides\ \`{}scale\`{}\ option.}
\DoxyCodeLine{00954\ \ \ Returns:}
\DoxyCodeLine{00955\ \ \ \ \ data\_up:\ A\ float32\ tensor\ of\ size}
\DoxyCodeLine{00956\ \ \ \ \ \ \ [batch,\ height\_in*scale,\ width\_in*scale,\ channels].}
\DoxyCodeLine{00957\ }
\DoxyCodeLine{00958\ \ \ Raises:}
\DoxyCodeLine{00959\ \ \ \ \ ValueError:\ If\ both\ scale\ \textcolor{keywordflow}{and}\ height\_scale\ \textcolor{keywordflow}{or}\ \textcolor{keywordflow}{if}\ both\ scale\ \textcolor{keywordflow}{and}\ width\_scale}
\DoxyCodeLine{00960\ \ \ \ \ \ \ are\ \textcolor{keywordtype}{None}.}
\DoxyCodeLine{00961\ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{00962\ \textcolor{stringliteral}{\ \ }\textcolor{keywordflow}{if}\ \textcolor{keywordflow}{not}\ scale\ \textcolor{keywordflow}{and}\ (height\_scale\ \textcolor{keywordflow}{is}\ \textcolor{keywordtype}{None}\ \textcolor{keywordflow}{or}\ width\_scale\ \textcolor{keywordflow}{is}\ \textcolor{keywordtype}{None}):}
\DoxyCodeLine{00963\ \ \ \ \ \textcolor{keywordflow}{raise}\ ValueError(\textcolor{stringliteral}{'Provide\ either\ \`{}scale`\ or\ \`{}height\_scale`\ and'}}
\DoxyCodeLine{00964\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'\ \`{}width\_scale`.'})}
\DoxyCodeLine{00965\ \ \ \textcolor{keyword}{with}\ tf.name\_scope(\textcolor{stringliteral}{'nearest\_neighbor\_upsampling'}):}
\DoxyCodeLine{00966\ \ \ \ \ h\_scale\ =\ scale\ \textcolor{keywordflow}{if}\ height\_scale\ \textcolor{keywordflow}{is}\ \textcolor{keywordtype}{None}\ \textcolor{keywordflow}{else}\ height\_scale}
\DoxyCodeLine{00967\ \ \ \ \ w\_scale\ =\ scale\ \textcolor{keywordflow}{if}\ width\_scale\ \textcolor{keywordflow}{is}\ \textcolor{keywordtype}{None}\ \textcolor{keywordflow}{else}\ width\_scale}
\DoxyCodeLine{00968\ \ \ \ \ (batch\_size,\ height,\ width,}
\DoxyCodeLine{00969\ \ \ \ \ \ channels)\ =\ shape\_utils.combined\_static\_and\_dynamic\_shape(input\_tensor)}
\DoxyCodeLine{00970\ \ \ \ \ output\_tensor\ =\ tf.reshape(}
\DoxyCodeLine{00971\ \ \ \ \ \ \ \ \ input\_tensor,\ [batch\_size,\ height,\ 1,\ width,\ 1,\ channels])\ *\ tf.ones(}
\DoxyCodeLine{00972\ \ \ \ \ \ \ \ \ \ \ \ \ [1,\ 1,\ h\_scale,\ 1,\ w\_scale,\ 1],\ dtype=input\_tensor.dtype)}
\DoxyCodeLine{00973\ \ \ \ \ \textcolor{keywordflow}{return}\ tf.reshape(output\_tensor,}
\DoxyCodeLine{00974\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ [batch\_size,\ height\ *\ h\_scale,\ width\ *\ w\_scale,\ channels])}
\DoxyCodeLine{00975\ }
\DoxyCodeLine{00976\ }

\end{DoxyCode}
\Hypertarget{namespacedetection__utils_1_1utils_1_1ops_a427d2293178f37f8f3030837d3813b65}\label{namespacedetection__utils_1_1utils_1_1ops_a427d2293178f37f8f3030837d3813b65} 
\index{detection\_utils.utils.ops@{detection\_utils.utils.ops}!normalize\_to\_target@{normalize\_to\_target}}
\index{normalize\_to\_target@{normalize\_to\_target}!detection\_utils.utils.ops@{detection\_utils.utils.ops}}
\doxysubsubsection{\texorpdfstring{normalize\_to\_target()}{normalize\_to\_target()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+utils.\+ops.\+normalize\+\_\+to\+\_\+target (\begin{DoxyParamCaption}\item[{}]{inputs,  }\item[{}]{target\+\_\+norm\+\_\+value,  }\item[{}]{dim,  }\item[{}]{epsilon = {\ttfamily 1e-\/7},  }\item[{}]{trainable = {\ttfamily True},  }\item[{}]{scope = {\ttfamily \textquotesingle{}NormalizeToTarget\textquotesingle{}},  }\item[{}]{summarize = {\ttfamily True} }\end{DoxyParamCaption})}

\begin{DoxyVerb}L2 normalizes the inputs across the specified dimension to a target norm.

This op implements the L2 Normalization layer introduced in
Liu, Wei, et al. "SSD: Single Shot MultiBox Detector."
and Liu, Wei, Andrew Rabinovich, and Alexander C. Berg.
"Parsenet: Looking wider to see better." and is useful for bringing
activations from multiple layers in a convnet to a standard scale.

Note that the rank of `inputs` must be known and the dimension to which
normalization is to be applied should be statically defined.

TODO(jonathanhuang): Add option to scale by L2 norm of the entire input.

Args:
  inputs: A `Tensor` of arbitrary size.
  target_norm_value: A float value that specifies an initial target norm or
    a list of floats (whose length must be equal to the depth along the
    dimension to be normalized) specifying a per-dimension multiplier
    after normalization.
  dim: The dimension along which the input is normalized.
  epsilon: A small value to add to the inputs to avoid dividing by zero.
  trainable: Whether the norm is trainable or not
  scope: Optional scope for variable_scope.
  summarize: Whether or not to add a tensorflow summary for the op.

Returns:
  The input tensor normalized to the specified target norm.

Raises:
  ValueError: If dim is smaller than the number of dimensions in 'inputs'.
  ValueError: If target_norm_value is not a float or a list of floats with
    length equal to the depth along the dimension to be normalized.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{ops_8py_source_l00528}{528}} of file \mbox{\hyperlink{ops_8py_source}{ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00534\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ summarize=\textcolor{keyword}{True}):}
\DoxyCodeLine{00535\ \ \ \textcolor{stringliteral}{"{}"{}"{}L2\ normalizes\ the\ inputs\ across\ the\ specified\ dimension\ to\ a\ target\ norm.}}
\DoxyCodeLine{00536\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00537\ \textcolor{stringliteral}{\ \ This\ op\ implements\ the\ L2\ Normalization\ layer\ introduced\ }\textcolor{keywordflow}{in}}
\DoxyCodeLine{00538\ \ \ Liu,\ Wei,\ et\ al.\ \textcolor{stringliteral}{"{}SSD:\ Single\ Shot\ MultiBox\ Detector."{}}}
\DoxyCodeLine{00539\ \ \ \textcolor{keywordflow}{and}\ Liu,\ Wei,\ Andrew\ Rabinovich,\ \textcolor{keywordflow}{and}\ Alexander\ C.\ Berg.}
\DoxyCodeLine{00540\ \ \ \textcolor{stringliteral}{"{}Parsenet:\ Looking\ wider\ to\ see\ better."{}}\ \textcolor{keywordflow}{and}\ \textcolor{keywordflow}{is}\ useful\ \textcolor{keywordflow}{for}\ bringing}
\DoxyCodeLine{00541\ \ \ activations\ \textcolor{keyword}{from}\ multiple\ layers\ \textcolor{keywordflow}{in}\ a\ convnet\ to\ a\ standard\ scale.}
\DoxyCodeLine{00542\ }
\DoxyCodeLine{00543\ \ \ Note\ that\ the\ rank\ of\ \`{}inputs\`{}\ must\ be\ known\ \textcolor{keywordflow}{and}\ the\ dimension\ to\ which}
\DoxyCodeLine{00544\ \ \ normalization\ \textcolor{keywordflow}{is}\ to\ be\ applied\ should\ be\ statically\ defined.}
\DoxyCodeLine{00545\ }
\DoxyCodeLine{00546\ \ \ TODO(jonathanhuang):\ Add\ option\ to\ scale\ by\ L2\ norm\ of\ the\ entire\ input.}
\DoxyCodeLine{00547\ }
\DoxyCodeLine{00548\ \ \ Args:}
\DoxyCodeLine{00549\ \ \ \ \ inputs:\ A\ \`{}Tensor\`{}\ of\ arbitrary\ size.}
\DoxyCodeLine{00550\ \ \ \ \ target\_norm\_value:\ A\ float\ value\ that\ specifies\ an\ initial\ target\ norm\ \textcolor{keywordflow}{or}}
\DoxyCodeLine{00551\ \ \ \ \ \ \ a\ list\ of\ floats\ (whose\ length\ must\ be\ equal\ to\ the\ depth\ along\ the}
\DoxyCodeLine{00552\ \ \ \ \ \ \ dimension\ to\ be\ normalized)\ specifying\ a\ per-\/dimension\ multiplier}
\DoxyCodeLine{00553\ \ \ \ \ \ \ after\ normalization.}
\DoxyCodeLine{00554\ \ \ \ \ dim:\ The\ dimension\ along\ which\ the\ input\ \textcolor{keywordflow}{is}\ normalized.}
\DoxyCodeLine{00555\ \ \ \ \ epsilon:\ A\ small\ value\ to\ add\ to\ the\ inputs\ to\ avoid\ dividing\ by\ zero.}
\DoxyCodeLine{00556\ \ \ \ \ trainable:\ Whether\ the\ norm\ \textcolor{keywordflow}{is}\ trainable\ \textcolor{keywordflow}{or}\ \textcolor{keywordflow}{not}}
\DoxyCodeLine{00557\ \ \ \ \ scope:\ Optional\ scope\ \textcolor{keywordflow}{for}\ variable\_scope.}
\DoxyCodeLine{00558\ \ \ \ \ summarize:\ Whether\ \textcolor{keywordflow}{or}\ \textcolor{keywordflow}{not}\ to\ add\ a\ tensorflow\ summary\ \textcolor{keywordflow}{for}\ the\ op.}
\DoxyCodeLine{00559\ }
\DoxyCodeLine{00560\ \ \ Returns:}
\DoxyCodeLine{00561\ \ \ \ \ The\ input\ tensor\ normalized\ to\ the\ specified\ target\ norm.}
\DoxyCodeLine{00562\ }
\DoxyCodeLine{00563\ \ \ Raises:}
\DoxyCodeLine{00564\ \ \ \ \ ValueError:\ If\ dim\ \textcolor{keywordflow}{is}\ smaller\ than\ the\ number\ of\ dimensions\ \textcolor{keywordflow}{in}\ \textcolor{stringliteral}{'inputs'}.}
\DoxyCodeLine{00565\ \ \ \ \ ValueError:\ If\ target\_norm\_value\ \textcolor{keywordflow}{is}\ \textcolor{keywordflow}{not}\ a\ float\ \textcolor{keywordflow}{or}\ a\ list\ of\ floats\ \textcolor{keyword}{with}}
\DoxyCodeLine{00566\ \ \ \ \ \ \ length\ equal\ to\ the\ depth\ along\ the\ dimension\ to\ be\ normalized.}
\DoxyCodeLine{00567\ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{00568\ \textcolor{stringliteral}{\ \ }\textcolor{keyword}{with}\ tf.variable\_scope(scope,\ \textcolor{stringliteral}{'NormalizeToTarget'},\ [inputs]):}
\DoxyCodeLine{00569\ \ \ \ \ \textcolor{keywordflow}{if}\ \textcolor{keywordflow}{not}\ inputs.get\_shape():}
\DoxyCodeLine{00570\ \ \ \ \ \ \ \textcolor{keywordflow}{raise}\ ValueError(\textcolor{stringliteral}{'The\ input\ rank\ must\ be\ known.'})}
\DoxyCodeLine{00571\ \ \ \ \ input\_shape\ =\ inputs.get\_shape().as\_list()}
\DoxyCodeLine{00572\ \ \ \ \ input\_rank\ =\ len(input\_shape)}
\DoxyCodeLine{00573\ \ \ \ \ \textcolor{keywordflow}{if}\ dim\ <\ 0\ \textcolor{keywordflow}{or}\ dim\ >=\ input\_rank:}
\DoxyCodeLine{00574\ \ \ \ \ \ \ \textcolor{keywordflow}{raise}\ ValueError(}
\DoxyCodeLine{00575\ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'dim\ must\ be\ non-\/negative\ but\ smaller\ than\ the\ input\ rank.'})}
\DoxyCodeLine{00576\ \ \ \ \ \textcolor{keywordflow}{if}\ \textcolor{keywordflow}{not}\ input\_shape[dim]:}
\DoxyCodeLine{00577\ \ \ \ \ \ \ \textcolor{keywordflow}{raise}\ ValueError(\textcolor{stringliteral}{'input\ shape\ should\ be\ statically\ defined\ along\ '}}
\DoxyCodeLine{00578\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'the\ specified\ dimension.'})}
\DoxyCodeLine{00579\ \ \ \ \ depth\ =\ input\_shape[dim]}
\DoxyCodeLine{00580\ \ \ \ \ \textcolor{keywordflow}{if}\ \textcolor{keywordflow}{not}\ (isinstance(target\_norm\_value,\ float)\ \textcolor{keywordflow}{or}}
\DoxyCodeLine{00581\ \ \ \ \ \ \ \ \ \ \ \ \ (isinstance(target\_norm\_value,\ list)\ \textcolor{keywordflow}{and}}
\DoxyCodeLine{00582\ \ \ \ \ \ \ \ \ \ \ \ \ \ len(target\_norm\_value)\ ==\ depth)\ \textcolor{keywordflow}{and}}
\DoxyCodeLine{00583\ \ \ \ \ \ \ \ \ \ \ \ \ all([isinstance(val,\ float)\ \textcolor{keywordflow}{for}\ val\ \textcolor{keywordflow}{in}\ target\_norm\_value])):}
\DoxyCodeLine{00584\ \ \ \ \ \ \ \textcolor{keywordflow}{raise}\ ValueError(\textcolor{stringliteral}{'target\_norm\_value\ must\ be\ a\ float\ or\ a\ list\ of\ floats\ '}}
\DoxyCodeLine{00585\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'with\ length\ equal\ to\ the\ depth\ along\ the\ dimension\ to\ '}}
\DoxyCodeLine{00586\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'be\ normalized.'})}
\DoxyCodeLine{00587\ \ \ \ \ \textcolor{keywordflow}{if}\ isinstance(target\_norm\_value,\ float):}
\DoxyCodeLine{00588\ \ \ \ \ \ \ initial\_norm\ =\ depth\ *\ [target\_norm\_value]}
\DoxyCodeLine{00589\ \ \ \ \ \textcolor{keywordflow}{else}:}
\DoxyCodeLine{00590\ \ \ \ \ \ \ initial\_norm\ =\ target\_norm\_value}
\DoxyCodeLine{00591\ \ \ \ \ target\_norm\ =\ tf.contrib.framework.model\_variable(}
\DoxyCodeLine{00592\ \ \ \ \ \ \ \ \ name=\textcolor{stringliteral}{'weights'},\ dtype=tf.float32,}
\DoxyCodeLine{00593\ \ \ \ \ \ \ \ \ initializer=tf.constant(initial\_norm,\ dtype=tf.float32),}
\DoxyCodeLine{00594\ \ \ \ \ \ \ \ \ trainable=trainable)}
\DoxyCodeLine{00595\ \ \ \ \ \textcolor{keywordflow}{if}\ summarize:}
\DoxyCodeLine{00596\ \ \ \ \ \ \ mean\ =\ tf.reduce\_mean(target\_norm)}
\DoxyCodeLine{00597\ \ \ \ \ \ \ tf.summary.scalar(tf.get\_variable\_scope().name,\ mean)}
\DoxyCodeLine{00598\ \ \ \ \ lengths\ =\ epsilon\ +\ tf.sqrt(tf.reduce\_sum(tf.square(inputs),\ dim,\ \textcolor{keyword}{True}))}
\DoxyCodeLine{00599\ \ \ \ \ mult\_shape\ =\ input\_rank*[1]}
\DoxyCodeLine{00600\ \ \ \ \ mult\_shape[dim]\ =\ depth}
\DoxyCodeLine{00601\ \ \ \ \ \textcolor{keywordflow}{return}\ tf.reshape(target\_norm,\ mult\_shape)\ *\ tf.truediv(inputs,\ lengths)}
\DoxyCodeLine{00602\ }
\DoxyCodeLine{00603\ }

\end{DoxyCode}
\Hypertarget{namespacedetection__utils_1_1utils_1_1ops_adc866ef74c28004b32df8315d34c8805}\label{namespacedetection__utils_1_1utils_1_1ops_adc866ef74c28004b32df8315d34c8805} 
\index{detection\_utils.utils.ops@{detection\_utils.utils.ops}!normalized\_to\_image\_coordinates@{normalized\_to\_image\_coordinates}}
\index{normalized\_to\_image\_coordinates@{normalized\_to\_image\_coordinates}!detection\_utils.utils.ops@{detection\_utils.utils.ops}}
\doxysubsubsection{\texorpdfstring{normalized\_to\_image\_coordinates()}{normalized\_to\_image\_coordinates()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+utils.\+ops.\+normalized\+\_\+to\+\_\+image\+\_\+coordinates (\begin{DoxyParamCaption}\item[{}]{normalized\+\_\+boxes,  }\item[{}]{image\+\_\+shape,  }\item[{}]{parallel\+\_\+iterations = {\ttfamily 32} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Converts a batch of boxes from normal to image coordinates.

Args:
  normalized_boxes: a tensor of shape [None, num_boxes, 4] in
    normalized coordinates. The dtype of this tensor must support tf.mul.
  image_shape: a tensor of shape [4] containing the image shape, with same
    dtype as `normalized_boxes`.
  parallel_iterations: parallelism for the map_fn op.

Returns:
  absolute_boxes: a tensor of shape [None, num_boxes, 4] containing
    the boxes in image coordinates, with same
    dtype as `normalized_boxes`.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{ops_8py_source_l00062}{62}} of file \mbox{\hyperlink{ops_8py_source}{ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00063\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ parallel\_iterations=32):}
\DoxyCodeLine{00064\ \ \ \textcolor{stringliteral}{"{}"{}"{}Converts\ a\ batch\ of\ boxes\ from\ normal\ to\ image\ coordinates.}}
\DoxyCodeLine{00065\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00066\ \textcolor{stringliteral}{\ \ Args:}}
\DoxyCodeLine{00067\ \textcolor{stringliteral}{\ \ \ \ normalized\_boxes:\ a\ tensor\ of\ shape\ [}\textcolor{keywordtype}{None},\ num\_boxes,\ 4]\ \textcolor{keywordflow}{in}}
\DoxyCodeLine{00068\ \ \ \ \ \ \ normalized\ coordinates.\ The\ dtype\ of\ this\ tensor\ must\ support\ tf.mul.}
\DoxyCodeLine{00069\ \ \ \ \ image\_shape:\ a\ tensor\ of\ shape\ [4]\ containing\ the\ image\ shape,\ \textcolor{keyword}{with}\ same}
\DoxyCodeLine{00070\ \ \ \ \ \ \ dtype\ \textcolor{keyword}{as}\ \`{}normalized\_boxes\`{}.}
\DoxyCodeLine{00071\ \ \ \ \ parallel\_iterations:\ parallelism\ \textcolor{keywordflow}{for}\ the\ map\_fn\ op.}
\DoxyCodeLine{00072\ }
\DoxyCodeLine{00073\ \ \ Returns:}
\DoxyCodeLine{00074\ \ \ \ \ absolute\_boxes:\ a\ tensor\ of\ shape\ [\textcolor{keywordtype}{None},\ num\_boxes,\ 4]\ containing}
\DoxyCodeLine{00075\ \ \ \ \ \ \ the\ boxes\ \textcolor{keywordflow}{in}\ image\ coordinates,\ \textcolor{keyword}{with}\ same}
\DoxyCodeLine{00076\ \ \ \ \ \ \ dtype\ \textcolor{keyword}{as}\ \`{}normalized\_boxes\`{}.}
\DoxyCodeLine{00077\ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{00078\ \textcolor{stringliteral}{\ \ x\_scale\ =\ tf.cast(image\_shape[2],\ normalized\_boxes.dtype)}}
\DoxyCodeLine{00079\ \textcolor{stringliteral}{\ \ y\_scale\ =\ tf.cast(image\_shape[1],\ normalized\_boxes.dtype)}}
\DoxyCodeLine{00080\ \textcolor{stringliteral}{\ \ }\textcolor{keyword}{def\ }\_to\_absolute\_coordinates(normalized\_boxes):}
\DoxyCodeLine{00081\ \ \ \ \ y\_min,\ x\_min,\ y\_max,\ x\_max\ =\ tf.split(}
\DoxyCodeLine{00082\ \ \ \ \ \ \ \ \ value=normalized\_boxes,\ num\_or\_size\_splits=4,\ axis=1)}
\DoxyCodeLine{00083\ \ \ \ \ y\_min\ =\ y\_scale\ *\ y\_min}
\DoxyCodeLine{00084\ \ \ \ \ y\_max\ =\ y\_scale\ *\ y\_max}
\DoxyCodeLine{00085\ \ \ \ \ x\_min\ =\ x\_scale\ *\ x\_min}
\DoxyCodeLine{00086\ \ \ \ \ x\_max\ =\ x\_scale\ *\ x\_max}
\DoxyCodeLine{00087\ \ \ \ \ scaled\_boxes\ =\ tf.concat([y\_min,\ x\_min,\ y\_max,\ x\_max],\ 1)}
\DoxyCodeLine{00088\ \ \ \ \ \textcolor{keywordflow}{return}\ scaled\_boxes}
\DoxyCodeLine{00089\ }
\DoxyCodeLine{00090\ \ \ absolute\_boxes\ =\ shape\_utils.static\_or\_dynamic\_map\_fn(}
\DoxyCodeLine{00091\ \ \ \ \ \ \ \_to\_absolute\_coordinates,}
\DoxyCodeLine{00092\ \ \ \ \ \ \ elems=(normalized\_boxes),}
\DoxyCodeLine{00093\ \ \ \ \ \ \ dtype=normalized\_boxes.dtype,}
\DoxyCodeLine{00094\ \ \ \ \ \ \ parallel\_iterations=parallel\_iterations,}
\DoxyCodeLine{00095\ \ \ \ \ \ \ back\_prop=\textcolor{keyword}{True})}
\DoxyCodeLine{00096\ \ \ \textcolor{keywordflow}{return}\ absolute\_boxes}
\DoxyCodeLine{00097\ }
\DoxyCodeLine{00098\ }

\end{DoxyCode}
\Hypertarget{namespacedetection__utils_1_1utils_1_1ops_afcdac23eebee9bb6a17790afbdf223d9}\label{namespacedetection__utils_1_1utils_1_1ops_afcdac23eebee9bb6a17790afbdf223d9} 
\index{detection\_utils.utils.ops@{detection\_utils.utils.ops}!pad\_to\_multiple@{pad\_to\_multiple}}
\index{pad\_to\_multiple@{pad\_to\_multiple}!detection\_utils.utils.ops@{detection\_utils.utils.ops}}
\doxysubsubsection{\texorpdfstring{pad\_to\_multiple()}{pad\_to\_multiple()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+utils.\+ops.\+pad\+\_\+to\+\_\+multiple (\begin{DoxyParamCaption}\item[{}]{tensor,  }\item[{}]{multiple }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns the tensor zero padded to the specified multiple.

Appends 0s to the end of the first and second dimension (height and width) of
the tensor until both dimensions are a multiple of the input argument
'multiple'. E.g. given an input tensor of shape [1, 3, 5, 1] and an input
multiple of 4, PadToMultiple will append 0s so that the resulting tensor will
be of shape [1, 4, 8, 1].

Args:
  tensor: rank 4 float32 tensor, where
          tensor -> [batch_size, height, width, channels].
  multiple: the multiple to pad to.

Returns:
  padded_tensor: the tensor zero padded to the specified multiple.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{ops_8py_source_l00160}{160}} of file \mbox{\hyperlink{ops_8py_source}{ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00160\ \textcolor{keyword}{def\ }pad\_to\_multiple(tensor,\ multiple):}
\DoxyCodeLine{00161\ \ \ \textcolor{stringliteral}{"{}"{}"{}Returns\ the\ tensor\ zero\ padded\ to\ the\ specified\ multiple.}}
\DoxyCodeLine{00162\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00163\ \textcolor{stringliteral}{\ \ Appends\ 0s\ to\ the\ end\ of\ the\ first\ }\textcolor{keywordflow}{and}\ second\ dimension\ (height\ \textcolor{keywordflow}{and}\ width)\ of}
\DoxyCodeLine{00164\ \ \ the\ tensor\ until\ both\ dimensions\ are\ a\ multiple\ of\ the\ input\ argument}
\DoxyCodeLine{00165\ \ \ \textcolor{stringliteral}{'multiple'}.\ E.g.\ given\ an\ input\ tensor\ of\ shape\ [1,\ 3,\ 5,\ 1]\ \textcolor{keywordflow}{and}\ an\ input}
\DoxyCodeLine{00166\ \ \ multiple\ of\ 4,\ PadToMultiple\ will\ append\ 0s\ so\ that\ the\ resulting\ tensor\ will}
\DoxyCodeLine{00167\ \ \ be\ of\ shape\ [1,\ 4,\ 8,\ 1].}
\DoxyCodeLine{00168\ }
\DoxyCodeLine{00169\ \ \ Args:}
\DoxyCodeLine{00170\ \ \ \ \ tensor:\ rank\ 4\ float32\ tensor,\ where}
\DoxyCodeLine{00171\ \ \ \ \ \ \ \ \ \ \ \ \ tensor\ -\/>\ [batch\_size,\ height,\ width,\ channels].}
\DoxyCodeLine{00172\ \ \ \ \ multiple:\ the\ multiple\ to\ pad\ to.}
\DoxyCodeLine{00173\ }
\DoxyCodeLine{00174\ \ \ Returns:}
\DoxyCodeLine{00175\ \ \ \ \ padded\_tensor:\ the\ tensor\ zero\ padded\ to\ the\ specified\ multiple.}
\DoxyCodeLine{00176\ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{00177\ \textcolor{stringliteral}{\ \ }\textcolor{keywordflow}{if}\ multiple\ ==\ 1:}
\DoxyCodeLine{00178\ \ \ \ \ \textcolor{keywordflow}{return}\ tensor}
\DoxyCodeLine{00179\ }
\DoxyCodeLine{00180\ \ \ tensor\_shape\ =\ tensor.get\_shape()}
\DoxyCodeLine{00181\ \ \ batch\_size\ =\ static\_shape.get\_batch\_size(tensor\_shape)}
\DoxyCodeLine{00182\ \ \ tensor\_height\ =\ static\_shape.get\_height(tensor\_shape)}
\DoxyCodeLine{00183\ \ \ tensor\_width\ =\ static\_shape.get\_width(tensor\_shape)}
\DoxyCodeLine{00184\ \ \ tensor\_depth\ =\ static\_shape.get\_depth(tensor\_shape)}
\DoxyCodeLine{00185\ }
\DoxyCodeLine{00186\ \ \ \textcolor{keywordflow}{if}\ batch\_size\ \textcolor{keywordflow}{is}\ \textcolor{keywordtype}{None}:}
\DoxyCodeLine{00187\ \ \ \ \ batch\_size\ =\ tf.shape(tensor)[0]}
\DoxyCodeLine{00188\ }
\DoxyCodeLine{00189\ \ \ \textcolor{keywordflow}{if}\ tensor\_height\ \textcolor{keywordflow}{is}\ \textcolor{keywordtype}{None}:}
\DoxyCodeLine{00190\ \ \ \ \ tensor\_height\ =\ tf.shape(tensor)[1]}
\DoxyCodeLine{00191\ \ \ \ \ padded\_tensor\_height\ =\ tf.cast(}
\DoxyCodeLine{00192\ \ \ \ \ \ \ \ \ tf.ceil(}
\DoxyCodeLine{00193\ \ \ \ \ \ \ \ \ \ \ \ \ tf.cast(tensor\_height,\ dtype=tf.float32)\ /}
\DoxyCodeLine{00194\ \ \ \ \ \ \ \ \ \ \ \ \ tf.cast(multiple,\ dtype=tf.float32)),}
\DoxyCodeLine{00195\ \ \ \ \ \ \ \ \ dtype=tf.int32)\ *\ multiple}
\DoxyCodeLine{00196\ \ \ \textcolor{keywordflow}{else}:}
\DoxyCodeLine{00197\ \ \ \ \ padded\_tensor\_height\ =\ int(}
\DoxyCodeLine{00198\ \ \ \ \ \ \ \ \ math.ceil(float(tensor\_height)\ /\ multiple)\ *\ multiple)}
\DoxyCodeLine{00199\ }
\DoxyCodeLine{00200\ \ \ \textcolor{keywordflow}{if}\ tensor\_width\ \textcolor{keywordflow}{is}\ \textcolor{keywordtype}{None}:}
\DoxyCodeLine{00201\ \ \ \ \ tensor\_width\ =\ tf.shape(tensor)[2]}
\DoxyCodeLine{00202\ \ \ \ \ padded\_tensor\_width\ =\ tf.cast(}
\DoxyCodeLine{00203\ \ \ \ \ \ \ \ \ tf.ceil(}
\DoxyCodeLine{00204\ \ \ \ \ \ \ \ \ \ \ \ \ tf.cast(tensor\_width,\ dtype=tf.float32)\ /}
\DoxyCodeLine{00205\ \ \ \ \ \ \ \ \ \ \ \ \ tf.cast(multiple,\ dtype=tf.float32)),}
\DoxyCodeLine{00206\ \ \ \ \ \ \ \ \ dtype=tf.int32)\ *\ multiple}
\DoxyCodeLine{00207\ \ \ \textcolor{keywordflow}{else}:}
\DoxyCodeLine{00208\ \ \ \ \ padded\_tensor\_width\ =\ int(}
\DoxyCodeLine{00209\ \ \ \ \ \ \ \ \ math.ceil(float(tensor\_width)\ /\ multiple)\ *\ multiple)}
\DoxyCodeLine{00210\ }
\DoxyCodeLine{00211\ \ \ \textcolor{keywordflow}{if}\ tensor\_depth\ \textcolor{keywordflow}{is}\ \textcolor{keywordtype}{None}:}
\DoxyCodeLine{00212\ \ \ \ \ tensor\_depth\ =\ tf.shape(tensor)[3]}
\DoxyCodeLine{00213\ }
\DoxyCodeLine{00214\ \ \ \textcolor{comment}{\#\ Use\ tf.concat\ instead\ of\ tf.pad\ to\ preserve\ static\ shape}}
\DoxyCodeLine{00215\ \ \ \textcolor{keywordflow}{if}\ padded\_tensor\_height\ !=\ tensor\_height:}
\DoxyCodeLine{00216\ \ \ \ \ height\_pad\ =\ tf.zeros([}
\DoxyCodeLine{00217\ \ \ \ \ \ \ \ \ batch\_size,\ padded\_tensor\_height\ -\/\ tensor\_height,\ tensor\_width,}
\DoxyCodeLine{00218\ \ \ \ \ \ \ \ \ tensor\_depth}
\DoxyCodeLine{00219\ \ \ \ \ ])}
\DoxyCodeLine{00220\ \ \ \ \ tensor\ =\ tf.concat([tensor,\ height\_pad],\ 1)}
\DoxyCodeLine{00221\ \ \ \textcolor{keywordflow}{if}\ padded\_tensor\_width\ !=\ tensor\_width:}
\DoxyCodeLine{00222\ \ \ \ \ width\_pad\ =\ tf.zeros([}
\DoxyCodeLine{00223\ \ \ \ \ \ \ \ \ batch\_size,\ padded\_tensor\_height,\ padded\_tensor\_width\ -\/\ tensor\_width,}
\DoxyCodeLine{00224\ \ \ \ \ \ \ \ \ tensor\_depth}
\DoxyCodeLine{00225\ \ \ \ \ ])}
\DoxyCodeLine{00226\ \ \ \ \ tensor\ =\ tf.concat([tensor,\ width\_pad],\ 2)}
\DoxyCodeLine{00227\ }
\DoxyCodeLine{00228\ \ \ \textcolor{keywordflow}{return}\ tensor}
\DoxyCodeLine{00229\ }
\DoxyCodeLine{00230\ }

\end{DoxyCode}
\Hypertarget{namespacedetection__utils_1_1utils_1_1ops_afe923c1879971de61ca2630119d56287}\label{namespacedetection__utils_1_1utils_1_1ops_afe923c1879971de61ca2630119d56287} 
\index{detection\_utils.utils.ops@{detection\_utils.utils.ops}!padded\_one\_hot\_encoding@{padded\_one\_hot\_encoding}}
\index{padded\_one\_hot\_encoding@{padded\_one\_hot\_encoding}!detection\_utils.utils.ops@{detection\_utils.utils.ops}}
\doxysubsubsection{\texorpdfstring{padded\_one\_hot\_encoding()}{padded\_one\_hot\_encoding()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+utils.\+ops.\+padded\+\_\+one\+\_\+hot\+\_\+encoding (\begin{DoxyParamCaption}\item[{}]{indices,  }\item[{}]{depth,  }\item[{}]{left\+\_\+pad }\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns a zero padded one-hot tensor.

This function converts a sparse representation of indices (e.g., [4]) to a
zero padded one-hot representation (e.g., [0, 0, 0, 0, 1] with depth = 4 and
left_pad = 1). If `indices` is empty, the result will simply be a tensor of
shape (0, depth + left_pad). If depth = 0, then this function just returns
`None`.

Args:
  indices: an integer tensor of shape [num_indices].
  depth: depth for the one-hot tensor (integer).
  left_pad: number of zeros to left pad the one-hot tensor with (integer).

Returns:
  padded_onehot: a tensor with shape (num_indices, depth + left_pad). Returns
    `None` if the depth is zero.

Raises:
  ValueError: if `indices` does not have rank 1 or if `left_pad` or `depth are
    either negative or non-integers.

TODO(rathodv): add runtime checks for depth and indices.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{ops_8py_source_l00231}{231}} of file \mbox{\hyperlink{ops_8py_source}{ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00231\ \textcolor{keyword}{def\ }padded\_one\_hot\_encoding(indices,\ depth,\ left\_pad):}
\DoxyCodeLine{00232\ \ \ \textcolor{stringliteral}{"{}"{}"{}Returns\ a\ zero\ padded\ one-\/hot\ tensor.}}
\DoxyCodeLine{00233\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00234\ \textcolor{stringliteral}{\ \ This\ function\ converts\ a\ sparse\ representation\ of\ indices\ (e.g.,\ [4])\ to\ a}}
\DoxyCodeLine{00235\ \textcolor{stringliteral}{\ \ zero\ padded\ one-\/hot\ representation\ (e.g.,\ [0,\ 0,\ 0,\ 0,\ 1]\ }\textcolor{keyword}{with}\ depth\ =\ 4\ \textcolor{keywordflow}{and}}
\DoxyCodeLine{00236\ \ \ left\_pad\ =\ 1).\ If\ \`{}indices\`{}\ \textcolor{keywordflow}{is}\ empty,\ the\ result\ will\ simply\ be\ a\ tensor\ of}
\DoxyCodeLine{00237\ \ \ shape\ (0,\ depth\ +\ left\_pad).\ If\ depth\ =\ 0,\ then\ this\ function\ just\ returns}
\DoxyCodeLine{00238\ \ \ \`{}\textcolor{keywordtype}{None}\`{}.}
\DoxyCodeLine{00239\ }
\DoxyCodeLine{00240\ \ \ Args:}
\DoxyCodeLine{00241\ \ \ \ \ indices:\ an\ integer\ tensor\ of\ shape\ [num\_indices].}
\DoxyCodeLine{00242\ \ \ \ \ depth:\ depth\ \textcolor{keywordflow}{for}\ the\ one-\/hot\ tensor\ (integer).}
\DoxyCodeLine{00243\ \ \ \ \ left\_pad:\ number\ of\ zeros\ to\ left\ pad\ the\ one-\/hot\ tensor\ \textcolor{keyword}{with}\ (integer).}
\DoxyCodeLine{00244\ }
\DoxyCodeLine{00245\ \ \ Returns:}
\DoxyCodeLine{00246\ \ \ \ \ padded\_onehot:\ a\ tensor\ \textcolor{keyword}{with}\ shape\ (num\_indices,\ depth\ +\ left\_pad).\ Returns}
\DoxyCodeLine{00247\ \ \ \ \ \ \ \`{}\textcolor{keywordtype}{None}\`{}\ \textcolor{keywordflow}{if}\ the\ depth\ \textcolor{keywordflow}{is}\ zero.}
\DoxyCodeLine{00248\ }
\DoxyCodeLine{00249\ \ \ Raises:}
\DoxyCodeLine{00250\ \ \ \ \ ValueError:\ \textcolor{keywordflow}{if}\ \`{}indices\`{}\ does\ \textcolor{keywordflow}{not}\ have\ rank\ 1\ \textcolor{keywordflow}{or}\ \textcolor{keywordflow}{if}\ \`{}left\_pad\`{}\ \textcolor{keywordflow}{or}\ \`{}depth\ are}
\DoxyCodeLine{00251\ \ \ \ \ \ \ either\ negative\ \textcolor{keywordflow}{or}\ non-\/integers.}
\DoxyCodeLine{00252\ }
\DoxyCodeLine{00253\ \ \ TODO(rathodv):\ add\ runtime\ checks\ \textcolor{keywordflow}{for}\ depth\ \textcolor{keywordflow}{and}\ indices.}
\DoxyCodeLine{00254\ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{00255\ \textcolor{stringliteral}{\ \ }\textcolor{keywordflow}{if}\ depth\ <\ 0\ \textcolor{keywordflow}{or}\ \textcolor{keywordflow}{not}\ isinstance(depth,\ six.integer\_types):}
\DoxyCodeLine{00256\ \ \ \ \ \textcolor{keywordflow}{raise}\ ValueError(\textcolor{stringliteral}{'\`{}depth`\ must\ be\ a\ non-\/negative\ integer.'})}
\DoxyCodeLine{00257\ \ \ \textcolor{keywordflow}{if}\ left\_pad\ <\ 0\ \textcolor{keywordflow}{or}\ \textcolor{keywordflow}{not}\ isinstance(left\_pad,\ six.integer\_types):}
\DoxyCodeLine{00258\ \ \ \ \ \textcolor{keywordflow}{raise}\ ValueError(\textcolor{stringliteral}{'\`{}left\_pad`\ must\ be\ a\ non-\/negative\ integer.'})}
\DoxyCodeLine{00259\ \ \ \textcolor{keywordflow}{if}\ depth\ ==\ 0:}
\DoxyCodeLine{00260\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keywordtype}{None}}
\DoxyCodeLine{00261\ }
\DoxyCodeLine{00262\ \ \ rank\ =\ len(indices.get\_shape().as\_list())}
\DoxyCodeLine{00263\ \ \ \textcolor{keywordflow}{if}\ rank\ !=\ 1:}
\DoxyCodeLine{00264\ \ \ \ \ \textcolor{keywordflow}{raise}\ ValueError(\textcolor{stringliteral}{'\`{}indices`\ must\ have\ rank\ 1,\ but\ has\ rank=\%s'}\ \%\ rank)}
\DoxyCodeLine{00265\ }
\DoxyCodeLine{00266\ \ \ \textcolor{keyword}{def\ }one\_hot\_and\_pad():}
\DoxyCodeLine{00267\ \ \ \ \ one\_hot\ =\ tf.cast(tf.one\_hot(tf.cast(indices,\ tf.int64),\ depth,}
\DoxyCodeLine{00268\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ on\_value=1,\ off\_value=0),\ tf.float32)}
\DoxyCodeLine{00269\ \ \ \ \ \textcolor{keywordflow}{return}\ tf.pad(one\_hot,\ [[0,\ 0],\ [left\_pad,\ 0]],\ mode=\textcolor{stringliteral}{'CONSTANT'})}
\DoxyCodeLine{00270\ \ \ result\ =\ tf.cond(tf.greater(tf.size(indices),\ 0),\ one\_hot\_and\_pad,}
\DoxyCodeLine{00271\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{lambda}:\ tf.zeros((depth\ +\ left\_pad,\ 0)))}
\DoxyCodeLine{00272\ \ \ \textcolor{keywordflow}{return}\ tf.reshape(result,\ [-\/1,\ depth\ +\ left\_pad])}
\DoxyCodeLine{00273\ }
\DoxyCodeLine{00274\ }

\end{DoxyCode}
\Hypertarget{namespacedetection__utils_1_1utils_1_1ops_a674b91c79c0575b09d5b79114912a8fa}\label{namespacedetection__utils_1_1utils_1_1ops_a674b91c79c0575b09d5b79114912a8fa} 
\index{detection\_utils.utils.ops@{detection\_utils.utils.ops}!position\_sensitive\_crop\_regions@{position\_sensitive\_crop\_regions}}
\index{position\_sensitive\_crop\_regions@{position\_sensitive\_crop\_regions}!detection\_utils.utils.ops@{detection\_utils.utils.ops}}
\doxysubsubsection{\texorpdfstring{position\_sensitive\_crop\_regions()}{position\_sensitive\_crop\_regions()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+utils.\+ops.\+position\+\_\+sensitive\+\_\+crop\+\_\+regions (\begin{DoxyParamCaption}\item[{}]{image,  }\item[{}]{boxes,  }\item[{}]{crop\+\_\+size,  }\item[{}]{num\+\_\+spatial\+\_\+bins,  }\item[{}]{global\+\_\+pool }\end{DoxyParamCaption})}

\begin{DoxyVerb}Position-sensitive crop and pool rectangular regions from a feature grid.

The output crops are split into `spatial_bins_y` vertical bins
and `spatial_bins_x` horizontal bins. For each intersection of a vertical
and a horizontal bin the output values are gathered by performing
`tf.image.crop_and_resize` (bilinear resampling) on a a separate subset of
channels of the image. This reduces `depth` by a factor of
`(spatial_bins_y * spatial_bins_x)`.

When global_pool is True, this function implements a differentiable version
of position-sensitive RoI pooling used in
[R-FCN detection system](https://arxiv.org/abs/1605.06409).

When global_pool is False, this function implements a differentiable version
of position-sensitive assembling operation used in
[instance FCN](https://arxiv.org/abs/1603.08678).

Args:
  image: A `Tensor`. Must be one of the following types: `uint8`, `int8`,
    `int16`, `int32`, `int64`, `half`, `float32`, `float64`.
    A 3-D tensor of shape `[image_height, image_width, depth]`.
    Both `image_height` and `image_width` need to be positive.
  boxes: A `Tensor` of type `float32`.
    A 2-D tensor of shape `[num_boxes, 4]`. Each box is specified in
    normalized coordinates `[y1, x1, y2, x2]`. A normalized coordinate value
    of `y` is mapped to the image coordinate at `y * (image_height - 1)`, so
    as the `[0, 1]` interval of normalized image height is mapped to
    `[0, image_height - 1] in image height coordinates. We do allow y1 > y2,
    in which case the sampled crop is an up-down flipped version of the
    original image. The width dimension is treated similarly.
  crop_size: A list of two integers `[crop_height, crop_width]`. All
    cropped image patches are resized to this size. The aspect ratio of the
    image content is not preserved. Both `crop_height` and `crop_width` need
    to be positive.
  num_spatial_bins: A list of two integers `[spatial_bins_y, spatial_bins_x]`.
    Represents the number of position-sensitive bins in y and x directions.
    Both values should be >= 1. `crop_height` should be divisible by
    `spatial_bins_y`, and similarly for width.
    The number of image channels should be divisible by
    (spatial_bins_y * spatial_bins_x).
    Suggested value from R-FCN paper: [3, 3].
  global_pool: A boolean variable.
    If True, we perform average global pooling on the features assembled from
      the position-sensitive score maps.
    If False, we keep the position-pooled features without global pooling
      over the spatial coordinates.
    Note that using global_pool=True is equivalent to but more efficient than
      running the function with global_pool=False and then performing global
      average pooling.

Returns:
  position_sensitive_features: A 4-D tensor of shape
    `[num_boxes, K, K, crop_channels]`,
    where `crop_channels = depth / (spatial_bins_y * spatial_bins_x)`,
    where K = 1 when global_pool is True (Average-pooled cropped regions),
    and K = crop_size when global_pool is False.
Raises:
  ValueError: Raised in four situations:
    `num_spatial_bins` is not >= 1;
    `num_spatial_bins` does not divide `crop_size`;
    `(spatial_bins_y*spatial_bins_x)` does not divide `depth`;
    `bin_crop_size` is not square when global_pool=False due to the
      constraint in function space_to_depth.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{ops_8py_source_l00652}{652}} of file \mbox{\hyperlink{ops_8py_source}{ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00656\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ global\_pool):}
\DoxyCodeLine{00657\ \ \ \textcolor{stringliteral}{"{}"{}"{}Position-\/sensitive\ crop\ and\ pool\ rectangular\ regions\ from\ a\ feature\ grid.}}
\DoxyCodeLine{00658\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00659\ \textcolor{stringliteral}{\ \ The\ output\ crops\ are\ split\ into\ \`{}spatial\_bins\_y\`{}\ vertical\ bins}}
\DoxyCodeLine{00660\ \textcolor{stringliteral}{\ \ }\textcolor{keywordflow}{and}\ \`{}spatial\_bins\_x\`{}\ horizontal\ bins.\ For\ each\ intersection\ of\ a\ vertical}
\DoxyCodeLine{00661\ \ \ \textcolor{keywordflow}{and}\ a\ horizontal\ bin\ the\ output\ values\ are\ gathered\ by\ performing}
\DoxyCodeLine{00662\ \ \ \`{}tf.image.crop\_and\_resize\`{}\ (bilinear\ resampling)\ on\ a\ a\ separate\ subset\ of}
\DoxyCodeLine{00663\ \ \ channels\ of\ the\ image.\ This\ reduces\ \`{}depth\`{}\ by\ a\ factor\ of}
\DoxyCodeLine{00664\ \ \ \`{}(spatial\_bins\_y\ *\ spatial\_bins\_x)\`{}.}
\DoxyCodeLine{00665\ }
\DoxyCodeLine{00666\ \ \ When\ global\_pool\ \textcolor{keywordflow}{is}\ \textcolor{keyword}{True},\ this\ function\ implements\ a\ differentiable\ version}
\DoxyCodeLine{00667\ \ \ of\ position-\/sensitive\ RoI\ pooling\ used\ \textcolor{keywordflow}{in}}
\DoxyCodeLine{00668\ \ \ [R-\/FCN\ detection\ system](https://arxiv.org/abs/1605.06409).}
\DoxyCodeLine{00669\ }
\DoxyCodeLine{00670\ \ \ When\ global\_pool\ \textcolor{keywordflow}{is}\ \textcolor{keyword}{False},\ this\ function\ implements\ a\ differentiable\ version}
\DoxyCodeLine{00671\ \ \ of\ position-\/sensitive\ assembling\ operation\ used\ \textcolor{keywordflow}{in}}
\DoxyCodeLine{00672\ \ \ [instance\ FCN](https://arxiv.org/abs/1603.08678).}
\DoxyCodeLine{00673\ }
\DoxyCodeLine{00674\ \ \ Args:}
\DoxyCodeLine{00675\ \ \ \ \ image:\ A\ \`{}Tensor\`{}.\ Must\ be\ one\ of\ the\ following\ types:\ \`{}uint8\`{},\ \`{}int8\`{},}
\DoxyCodeLine{00676\ \ \ \ \ \ \ \`{}int16\`{},\ \`{}int32\`{},\ \`{}int64\`{},\ \`{}half\`{},\ \`{}float32\`{},\ \`{}float64\`{}.}
\DoxyCodeLine{00677\ \ \ \ \ \ \ A\ 3-\/D\ tensor\ of\ shape\ \`{}[image\_height,\ image\_width,\ depth]\`{}.}
\DoxyCodeLine{00678\ \ \ \ \ \ \ Both\ \`{}image\_height\`{}\ \textcolor{keywordflow}{and}\ \`{}image\_width\`{}\ need\ to\ be\ positive.}
\DoxyCodeLine{00679\ \ \ \ \ boxes:\ A\ \`{}Tensor\`{}\ of\ type\ \`{}float32\`{}.}
\DoxyCodeLine{00680\ \ \ \ \ \ \ A\ 2-\/D\ tensor\ of\ shape\ \`{}[num\_boxes,\ 4]\`{}.\ Each\ box\ \textcolor{keywordflow}{is}\ specified\ \textcolor{keywordflow}{in}}
\DoxyCodeLine{00681\ \ \ \ \ \ \ normalized\ coordinates\ \`{}[y1,\ x1,\ y2,\ x2]\`{}.\ A\ normalized\ coordinate\ value}
\DoxyCodeLine{00682\ \ \ \ \ \ \ of\ \`{}y\`{}\ \textcolor{keywordflow}{is}\ mapped\ to\ the\ image\ coordinate\ at\ \`{}y\ *\ (image\_height\ -\/\ 1)\`{},\ so}
\DoxyCodeLine{00683\ \ \ \ \ \ \ \textcolor{keyword}{as}\ the\ \`{}[0,\ 1]\`{}\ interval\ of\ normalized\ image\ height\ \textcolor{keywordflow}{is}\ mapped\ to}
\DoxyCodeLine{00684\ \ \ \ \ \ \ \`{}[0,\ image\_height\ -\/\ 1]\ \textcolor{keywordflow}{in}\ image\ height\ coordinates.\ We\ do\ allow\ y1\ >\ y2,}
\DoxyCodeLine{00685\ \ \ \ \ \ \ \textcolor{keywordflow}{in}\ which\ case\ the\ sampled\ crop\ \textcolor{keywordflow}{is}\ an\ up-\/down\ flipped\ version\ of\ the}
\DoxyCodeLine{00686\ \ \ \ \ \ \ original\ image.\ The\ width\ dimension\ \textcolor{keywordflow}{is}\ treated\ similarly.}
\DoxyCodeLine{00687\ \ \ \ \ crop\_size:\ A\ list\ of\ two\ integers\ \`{}[crop\_height,\ crop\_width]\`{}.\ All}
\DoxyCodeLine{00688\ \ \ \ \ \ \ cropped\ image\ patches\ are\ resized\ to\ this\ size.\ The\ aspect\ ratio\ of\ the}
\DoxyCodeLine{00689\ \ \ \ \ \ \ image\ content\ \textcolor{keywordflow}{is}\ \textcolor{keywordflow}{not}\ preserved.\ Both\ \`{}crop\_height\`{}\ \textcolor{keywordflow}{and}\ \`{}crop\_width\`{}\ need}
\DoxyCodeLine{00690\ \ \ \ \ \ \ to\ be\ positive.}
\DoxyCodeLine{00691\ \ \ \ \ num\_spatial\_bins:\ A\ list\ of\ two\ integers\ \`{}[spatial\_bins\_y,\ spatial\_bins\_x]\`{}.}
\DoxyCodeLine{00692\ \ \ \ \ \ \ Represents\ the\ number\ of\ position-\/sensitive\ bins\ \textcolor{keywordflow}{in}\ y\ \textcolor{keywordflow}{and}\ x\ directions.}
\DoxyCodeLine{00693\ \ \ \ \ \ \ Both\ values\ should\ be\ >=\ 1.\ \`{}crop\_height\`{}\ should\ be\ divisible\ by}
\DoxyCodeLine{00694\ \ \ \ \ \ \ \`{}spatial\_bins\_y\`{},\ \textcolor{keywordflow}{and}\ similarly\ \textcolor{keywordflow}{for}\ width.}
\DoxyCodeLine{00695\ \ \ \ \ \ \ The\ number\ of\ image\ channels\ should\ be\ divisible\ by}
\DoxyCodeLine{00696\ \ \ \ \ \ \ (spatial\_bins\_y\ *\ spatial\_bins\_x).}
\DoxyCodeLine{00697\ \ \ \ \ \ \ Suggested\ value\ \textcolor{keyword}{from}\ R-\/FCN\ paper:\ [3,\ 3].}
\DoxyCodeLine{00698\ \ \ \ \ global\_pool:\ A\ boolean\ variable.}
\DoxyCodeLine{00699\ \ \ \ \ \ \ If\ \textcolor{keyword}{True},\ we\ perform\ average\ \textcolor{keyword}{global}\ pooling\ on\ the\ features\ assembled\ \textcolor{keyword}{from}}
\DoxyCodeLine{00700\ \ \ \ \ \ \ \ \ the\ position-\/sensitive\ score\ maps.}
\DoxyCodeLine{00701\ \ \ \ \ \ \ If\ \textcolor{keyword}{False},\ we\ keep\ the\ position-\/pooled\ features\ without\ \textcolor{keyword}{global}\ pooling}
\DoxyCodeLine{00702\ \ \ \ \ \ \ \ \ over\ the\ spatial\ coordinates.}
\DoxyCodeLine{00703\ \ \ \ \ \ \ Note\ that\ using\ global\_pool=\textcolor{keyword}{True}\ \textcolor{keywordflow}{is}\ equivalent\ to\ but\ more\ efficient\ than}
\DoxyCodeLine{00704\ \ \ \ \ \ \ \ \ running\ the\ function\ \textcolor{keyword}{with}\ global\_pool=\textcolor{keyword}{False}\ \textcolor{keywordflow}{and}\ then\ performing\ \textcolor{keyword}{global}}
\DoxyCodeLine{00705\ \ \ \ \ \ \ \ \ average\ pooling.}
\DoxyCodeLine{00706\ }
\DoxyCodeLine{00707\ \ \ Returns:}
\DoxyCodeLine{00708\ \ \ \ \ position\_sensitive\_features:\ A\ 4-\/D\ tensor\ of\ shape}
\DoxyCodeLine{00709\ \ \ \ \ \ \ \`{}[num\_boxes,\ K,\ K,\ crop\_channels]\`{},}
\DoxyCodeLine{00710\ \ \ \ \ \ \ where\ \`{}crop\_channels\ =\ depth\ /\ (spatial\_bins\_y\ *\ spatial\_bins\_x)\`{},}
\DoxyCodeLine{00711\ \ \ \ \ \ \ where\ K\ =\ 1\ when\ global\_pool\ \textcolor{keywordflow}{is}\ \textcolor{keyword}{True}\ (Average-\/pooled\ cropped\ regions),}
\DoxyCodeLine{00712\ \ \ \ \ \ \ \textcolor{keywordflow}{and}\ K\ =\ crop\_size\ when\ global\_pool\ \textcolor{keywordflow}{is}\ \textcolor{keyword}{False}.}
\DoxyCodeLine{00713\ \ \ Raises:}
\DoxyCodeLine{00714\ \ \ \ \ ValueError:\ Raised\ \textcolor{keywordflow}{in}\ four\ situations:}
\DoxyCodeLine{00715\ \ \ \ \ \ \ \`{}num\_spatial\_bins\`{}\ \textcolor{keywordflow}{is}\ \textcolor{keywordflow}{not}\ >=\ 1;}
\DoxyCodeLine{00716\ \ \ \ \ \ \ \`{}num\_spatial\_bins\`{}\ does\ \textcolor{keywordflow}{not}\ divide\ \`{}crop\_size\`{};}
\DoxyCodeLine{00717\ \ \ \ \ \ \ \`{}(spatial\_bins\_y*spatial\_bins\_x)\`{}\ does\ \textcolor{keywordflow}{not}\ divide\ \`{}depth\`{};}
\DoxyCodeLine{00718\ \ \ \ \ \ \ \`{}bin\_crop\_size\`{}\ \textcolor{keywordflow}{is}\ \textcolor{keywordflow}{not}\ square\ when\ global\_pool=\textcolor{keyword}{False}\ due\ to\ the}
\DoxyCodeLine{00719\ \ \ \ \ \ \ \ \ constraint\ \textcolor{keywordflow}{in}\ function\ space\_to\_depth.}
\DoxyCodeLine{00720\ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{00721\ \textcolor{stringliteral}{\ \ total\_bins\ =\ 1}}
\DoxyCodeLine{00722\ \textcolor{stringliteral}{\ \ bin\_crop\_size\ =\ []}}
\DoxyCodeLine{00723\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00724\ \textcolor{stringliteral}{\ \ }\textcolor{keywordflow}{for}\ (num\_bins,\ crop\_dim)\ \textcolor{keywordflow}{in}\ zip(num\_spatial\_bins,\ crop\_size):}
\DoxyCodeLine{00725\ \ \ \ \ \textcolor{keywordflow}{if}\ num\_bins\ <\ 1:}
\DoxyCodeLine{00726\ \ \ \ \ \ \ \textcolor{keywordflow}{raise}\ ValueError(\textcolor{stringliteral}{'num\_spatial\_bins\ should\ be\ >=\ 1'})}
\DoxyCodeLine{00727\ }
\DoxyCodeLine{00728\ \ \ \ \ \textcolor{keywordflow}{if}\ crop\_dim\ \%\ num\_bins\ !=\ 0:}
\DoxyCodeLine{00729\ \ \ \ \ \ \ \textcolor{keywordflow}{raise}\ ValueError(\textcolor{stringliteral}{'crop\_size\ should\ be\ divisible\ by\ num\_spatial\_bins'})}
\DoxyCodeLine{00730\ }
\DoxyCodeLine{00731\ \ \ \ \ total\_bins\ *=\ num\_bins}
\DoxyCodeLine{00732\ \ \ \ \ bin\_crop\_size.append(crop\_dim\ //\ num\_bins)}
\DoxyCodeLine{00733\ }
\DoxyCodeLine{00734\ \ \ \textcolor{keywordflow}{if}\ \textcolor{keywordflow}{not}\ global\_pool\ \textcolor{keywordflow}{and}\ bin\_crop\_size[0]\ !=\ bin\_crop\_size[1]:}
\DoxyCodeLine{00735\ \ \ \ \ \textcolor{keywordflow}{raise}\ ValueError(\textcolor{stringliteral}{'Only\ support\ square\ bin\ crop\ size\ for\ now.'})}
\DoxyCodeLine{00736\ }
\DoxyCodeLine{00737\ \ \ ymin,\ xmin,\ ymax,\ xmax\ =\ tf.unstack(boxes,\ axis=1)}
\DoxyCodeLine{00738\ \ \ spatial\_bins\_y,\ spatial\_bins\_x\ =\ num\_spatial\_bins}
\DoxyCodeLine{00739\ }
\DoxyCodeLine{00740\ \ \ \textcolor{comment}{\#\ Split\ each\ box\ into\ spatial\_bins\_y\ *\ spatial\_bins\_x\ bins.}}
\DoxyCodeLine{00741\ \ \ position\_sensitive\_boxes\ =\ []}
\DoxyCodeLine{00742\ \ \ \textcolor{keywordflow}{for}\ bin\_y\ \textcolor{keywordflow}{in}\ range(spatial\_bins\_y):}
\DoxyCodeLine{00743\ \ \ \ \ step\_y\ =\ (ymax\ -\/\ ymin)\ /\ spatial\_bins\_y}
\DoxyCodeLine{00744\ \ \ \ \ \textcolor{keywordflow}{for}\ bin\_x\ \textcolor{keywordflow}{in}\ range(spatial\_bins\_x):}
\DoxyCodeLine{00745\ \ \ \ \ \ \ step\_x\ =\ (xmax\ -\/\ xmin)\ /\ spatial\_bins\_x}
\DoxyCodeLine{00746\ \ \ \ \ \ \ box\_coordinates\ =\ [ymin\ +\ bin\_y\ *\ step\_y,}
\DoxyCodeLine{00747\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ xmin\ +\ bin\_x\ *\ step\_x,}
\DoxyCodeLine{00748\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ymin\ +\ (bin\_y\ +\ 1)\ *\ step\_y,}
\DoxyCodeLine{00749\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ xmin\ +\ (bin\_x\ +\ 1)\ *\ step\_x,}
\DoxyCodeLine{00750\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ]}
\DoxyCodeLine{00751\ \ \ \ \ \ \ position\_sensitive\_boxes.append(tf.stack(box\_coordinates,\ axis=1))}
\DoxyCodeLine{00752\ }
\DoxyCodeLine{00753\ \ \ image\_splits\ =\ tf.split(value=image,\ num\_or\_size\_splits=total\_bins,\ axis=2)}
\DoxyCodeLine{00754\ }
\DoxyCodeLine{00755\ \ \ image\_crops\ =\ []}
\DoxyCodeLine{00756\ \ \ \textcolor{keywordflow}{for}\ (split,\ box)\ \textcolor{keywordflow}{in}\ zip(image\_splits,\ position\_sensitive\_boxes):}
\DoxyCodeLine{00757\ \ \ \ \ \textcolor{keywordflow}{if}\ split.shape.is\_fully\_defined()\ \textcolor{keywordflow}{and}\ box.shape.is\_fully\_defined():}
\DoxyCodeLine{00758\ \ \ \ \ \ \ crop\ =\ tf.squeeze(}
\DoxyCodeLine{00759\ \ \ \ \ \ \ \ \ \ \ matmul\_crop\_and\_resize(}
\DoxyCodeLine{00760\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ tf.expand\_dims(split,\ axis=0),\ tf.expand\_dims(box,\ axis=0),}
\DoxyCodeLine{00761\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ bin\_crop\_size),}
\DoxyCodeLine{00762\ \ \ \ \ \ \ \ \ \ \ axis=0)}
\DoxyCodeLine{00763\ \ \ \ \ \textcolor{keywordflow}{else}:}
\DoxyCodeLine{00764\ \ \ \ \ \ \ crop\ =\ tf.image.crop\_and\_resize(}
\DoxyCodeLine{00765\ \ \ \ \ \ \ \ \ \ \ tf.expand\_dims(split,\ 0),\ box,}
\DoxyCodeLine{00766\ \ \ \ \ \ \ \ \ \ \ tf.zeros(tf.shape(boxes)[0],\ dtype=tf.int32),\ bin\_crop\_size)}
\DoxyCodeLine{00767\ \ \ \ \ image\_crops.append(crop)}
\DoxyCodeLine{00768\ }
\DoxyCodeLine{00769\ \ \ \textcolor{keywordflow}{if}\ global\_pool:}
\DoxyCodeLine{00770\ \ \ \ \ \textcolor{comment}{\#\ Average\ over\ all\ bins.}}
\DoxyCodeLine{00771\ \ \ \ \ position\_sensitive\_features\ =\ tf.add\_n(image\_crops)\ /\ len(image\_crops)}
\DoxyCodeLine{00772\ \ \ \ \ \textcolor{comment}{\#\ Then\ average\ over\ spatial\ positions\ within\ the\ bins.}}
\DoxyCodeLine{00773\ \ \ \ \ position\_sensitive\_features\ =\ tf.reduce\_mean(}
\DoxyCodeLine{00774\ \ \ \ \ \ \ \ \ position\_sensitive\_features,\ [1,\ 2],\ keepdims=\textcolor{keyword}{True})}
\DoxyCodeLine{00775\ \ \ \textcolor{keywordflow}{else}:}
\DoxyCodeLine{00776\ \ \ \ \ \textcolor{comment}{\#\ Reorder\ height/width\ to\ depth\ channel.}}
\DoxyCodeLine{00777\ \ \ \ \ block\_size\ =\ bin\_crop\_size[0]}
\DoxyCodeLine{00778\ \ \ \ \ \textcolor{keywordflow}{if}\ block\_size\ >=\ 2:}
\DoxyCodeLine{00779\ \ \ \ \ \ \ image\_crops\ =\ [tf.space\_to\_depth(}
\DoxyCodeLine{00780\ \ \ \ \ \ \ \ \ \ \ crop,\ block\_size=block\_size)\ \textcolor{keywordflow}{for}\ crop\ \textcolor{keywordflow}{in}\ image\_crops]}
\DoxyCodeLine{00781\ }
\DoxyCodeLine{00782\ \ \ \ \ \textcolor{comment}{\#\ Pack\ image\_crops\ so\ that\ first\ dimension\ is\ for\ position-\/senstive\ boxes.}}
\DoxyCodeLine{00783\ \ \ \ \ position\_sensitive\_features\ =\ tf.stack(image\_crops,\ axis=0)}
\DoxyCodeLine{00784\ }
\DoxyCodeLine{00785\ \ \ \ \ \textcolor{comment}{\#\ Unroll\ the\ position-\/sensitive\ boxes\ to\ spatial\ positions.}}
\DoxyCodeLine{00786\ \ \ \ \ position\_sensitive\_features\ =\ tf.squeeze(}
\DoxyCodeLine{00787\ \ \ \ \ \ \ \ \ tf.batch\_to\_space\_nd(position\_sensitive\_features,}
\DoxyCodeLine{00788\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ block\_shape=[1]\ +\ num\_spatial\_bins,}
\DoxyCodeLine{00789\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ crops=tf.zeros((3,\ 2),\ dtype=tf.int32)),}
\DoxyCodeLine{00790\ \ \ \ \ \ \ \ \ axis=[0])}
\DoxyCodeLine{00791\ }
\DoxyCodeLine{00792\ \ \ \ \ \textcolor{comment}{\#\ Reorder\ back\ the\ depth\ channel.}}
\DoxyCodeLine{00793\ \ \ \ \ \textcolor{keywordflow}{if}\ block\_size\ >=\ 2:}
\DoxyCodeLine{00794\ \ \ \ \ \ \ position\_sensitive\_features\ =\ tf.depth\_to\_space(}
\DoxyCodeLine{00795\ \ \ \ \ \ \ \ \ \ \ position\_sensitive\_features,\ block\_size=block\_size)}
\DoxyCodeLine{00796\ }
\DoxyCodeLine{00797\ \ \ \textcolor{keywordflow}{return}\ position\_sensitive\_features}
\DoxyCodeLine{00798\ }
\DoxyCodeLine{00799\ }

\end{DoxyCode}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{db/d47/namespacedetection__utils_1_1utils_1_1ops_a674b91c79c0575b09d5b79114912a8fa_icgraph}
\end{center}
\end{figure}
\Hypertarget{namespacedetection__utils_1_1utils_1_1ops_a8c5e626e71f1d4e2bf1a4693b1035984}\label{namespacedetection__utils_1_1utils_1_1ops_a8c5e626e71f1d4e2bf1a4693b1035984} 
\index{detection\_utils.utils.ops@{detection\_utils.utils.ops}!reduce\_sum\_trailing\_dimensions@{reduce\_sum\_trailing\_dimensions}}
\index{reduce\_sum\_trailing\_dimensions@{reduce\_sum\_trailing\_dimensions}!detection\_utils.utils.ops@{detection\_utils.utils.ops}}
\doxysubsubsection{\texorpdfstring{reduce\_sum\_trailing\_dimensions()}{reduce\_sum\_trailing\_dimensions()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+utils.\+ops.\+reduce\+\_\+sum\+\_\+trailing\+\_\+dimensions (\begin{DoxyParamCaption}\item[{}]{tensor,  }\item[{}]{ndims }\end{DoxyParamCaption})}

\begin{DoxyVerb}Computes sum across all dimensions following first `ndims` dimensions.\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{ops_8py_source_l00338}{338}} of file \mbox{\hyperlink{ops_8py_source}{ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00338\ \textcolor{keyword}{def\ }reduce\_sum\_trailing\_dimensions(tensor,\ ndims):}
\DoxyCodeLine{00339\ \ \ \textcolor{stringliteral}{"{}"{}"{}Computes\ sum\ across\ all\ dimensions\ following\ first\ \`{}ndims\`{}\ dimensions."{}"{}"{}}}
\DoxyCodeLine{00340\ \ \ \textcolor{keywordflow}{return}\ tf.reduce\_sum(tensor,\ axis=tuple(range(ndims,\ tensor.shape.ndims)))}
\DoxyCodeLine{00341\ }
\DoxyCodeLine{00342\ }

\end{DoxyCode}
\Hypertarget{namespacedetection__utils_1_1utils_1_1ops_ae862e7f24dbb83f231c678895bfdf766}\label{namespacedetection__utils_1_1utils_1_1ops_ae862e7f24dbb83f231c678895bfdf766} 
\index{detection\_utils.utils.ops@{detection\_utils.utils.ops}!reframe\_box\_masks\_to\_image\_masks@{reframe\_box\_masks\_to\_image\_masks}}
\index{reframe\_box\_masks\_to\_image\_masks@{reframe\_box\_masks\_to\_image\_masks}!detection\_utils.utils.ops@{detection\_utils.utils.ops}}
\doxysubsubsection{\texorpdfstring{reframe\_box\_masks\_to\_image\_masks()}{reframe\_box\_masks\_to\_image\_masks()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+utils.\+ops.\+reframe\+\_\+box\+\_\+masks\+\_\+to\+\_\+image\+\_\+masks (\begin{DoxyParamCaption}\item[{}]{box\+\_\+masks,  }\item[{}]{boxes,  }\item[{}]{image\+\_\+height,  }\item[{}]{image\+\_\+width }\end{DoxyParamCaption})}

\begin{DoxyVerb}Transforms the box masks back to full image masks.

Embeds masks in bounding boxes of larger masks whose shapes correspond to
image shape.

Args:
  box_masks: A tf.float32 tensor of size [num_masks, mask_height, mask_width].
  boxes: A tf.float32 tensor of size [num_masks, 4] containing the box
         corners. Row i contains [ymin, xmin, ymax, xmax] of the box
         corresponding to mask i. Note that the box corners are in
         normalized coordinates.
  image_height: Image height. The output mask will have the same height as
                the image height.
  image_width: Image width. The output mask will have the same width as the
               image width.

Returns:
  A tf.float32 tensor of size [num_masks, image_height, image_width].
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{ops_8py_source_l00800}{800}} of file \mbox{\hyperlink{ops_8py_source}{ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00801\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ image\_width):}
\DoxyCodeLine{00802\ \ \ \textcolor{stringliteral}{"{}"{}"{}Transforms\ the\ box\ masks\ back\ to\ full\ image\ masks.}}
\DoxyCodeLine{00803\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00804\ \textcolor{stringliteral}{\ \ Embeds\ masks\ }\textcolor{keywordflow}{in}\ bounding\ boxes\ of\ larger\ masks\ whose\ shapes\ correspond\ to}
\DoxyCodeLine{00805\ \ \ image\ shape.}
\DoxyCodeLine{00806\ }
\DoxyCodeLine{00807\ \ \ Args:}
\DoxyCodeLine{00808\ \ \ \ \ box\_masks:\ A\ tf.float32\ tensor\ of\ size\ [num\_masks,\ mask\_height,\ mask\_width].}
\DoxyCodeLine{00809\ \ \ \ \ boxes:\ A\ tf.float32\ tensor\ of\ size\ [num\_masks,\ 4]\ containing\ the\ box}
\DoxyCodeLine{00810\ \ \ \ \ \ \ \ \ \ \ \ corners.\ Row\ i\ contains\ [ymin,\ xmin,\ ymax,\ xmax]\ of\ the\ box}
\DoxyCodeLine{00811\ \ \ \ \ \ \ \ \ \ \ \ corresponding\ to\ mask\ i.\ Note\ that\ the\ box\ corners\ are\ \textcolor{keywordflow}{in}}
\DoxyCodeLine{00812\ \ \ \ \ \ \ \ \ \ \ \ normalized\ coordinates.}
\DoxyCodeLine{00813\ \ \ \ \ image\_height:\ Image\ height.\ The\ output\ mask\ will\ have\ the\ same\ height\ \textcolor{keyword}{as}}
\DoxyCodeLine{00814\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ the\ image\ height.}
\DoxyCodeLine{00815\ \ \ \ \ image\_width:\ Image\ width.\ The\ output\ mask\ will\ have\ the\ same\ width\ \textcolor{keyword}{as}\ the}
\DoxyCodeLine{00816\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ image\ width.}
\DoxyCodeLine{00817\ }
\DoxyCodeLine{00818\ \ \ Returns:}
\DoxyCodeLine{00819\ \ \ \ \ A\ tf.float32\ tensor\ of\ size\ [num\_masks,\ image\_height,\ image\_width].}
\DoxyCodeLine{00820\ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{00821\ \textcolor{stringliteral}{\ \ }\textcolor{comment}{\#\ TODO(rathodv):\ Make\ this\ a\ public\ function.}}
\DoxyCodeLine{00822\ \ \ \textcolor{keyword}{def\ }reframe\_box\_masks\_to\_image\_masks\_default():}
\DoxyCodeLine{00823\ \ \ \ \ \textcolor{stringliteral}{"{}"{}"{}The\ default\ function\ when\ there\ are\ more\ than\ 0\ box\ masks."{}"{}"{}}}
\DoxyCodeLine{00824\ \ \ \ \ \textcolor{keyword}{def\ }transform\_boxes\_relative\_to\_boxes(boxes,\ reference\_boxes):}
\DoxyCodeLine{00825\ \ \ \ \ \ \ boxes\ =\ tf.reshape(boxes,\ [-\/1,\ 2,\ 2])}
\DoxyCodeLine{00826\ \ \ \ \ \ \ min\_corner\ =\ tf.expand\_dims(reference\_boxes[:,\ 0:2],\ 1)}
\DoxyCodeLine{00827\ \ \ \ \ \ \ max\_corner\ =\ tf.expand\_dims(reference\_boxes[:,\ 2:4],\ 1)}
\DoxyCodeLine{00828\ \ \ \ \ \ \ transformed\_boxes\ =\ (boxes\ -\/\ min\_corner)\ /\ (max\_corner\ -\/\ min\_corner)}
\DoxyCodeLine{00829\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ tf.reshape(transformed\_boxes,\ [-\/1,\ 4])}
\DoxyCodeLine{00830\ }
\DoxyCodeLine{00831\ \ \ \ \ box\_masks\_expanded\ =\ tf.expand\_dims(box\_masks,\ axis=3)}
\DoxyCodeLine{00832\ \ \ \ \ num\_boxes\ =\ tf.shape(box\_masks\_expanded)[0]}
\DoxyCodeLine{00833\ \ \ \ \ unit\_boxes\ =\ tf.concat(}
\DoxyCodeLine{00834\ \ \ \ \ \ \ \ \ [tf.zeros([num\_boxes,\ 2]),\ tf.ones([num\_boxes,\ 2])],\ axis=1)}
\DoxyCodeLine{00835\ \ \ \ \ reverse\_boxes\ =\ transform\_boxes\_relative\_to\_boxes(unit\_boxes,\ boxes)}
\DoxyCodeLine{00836\ \ \ \ \ \textcolor{keywordflow}{return}\ tf.image.crop\_and\_resize(}
\DoxyCodeLine{00837\ \ \ \ \ \ \ \ \ image=box\_masks\_expanded,}
\DoxyCodeLine{00838\ \ \ \ \ \ \ \ \ boxes=reverse\_boxes,}
\DoxyCodeLine{00839\ \ \ \ \ \ \ \ \ box\_ind=tf.range(num\_boxes),}
\DoxyCodeLine{00840\ \ \ \ \ \ \ \ \ crop\_size=[image\_height,\ image\_width],}
\DoxyCodeLine{00841\ \ \ \ \ \ \ \ \ extrapolation\_value=0.0)}
\DoxyCodeLine{00842\ \ \ image\_masks\ =\ tf.cond(}
\DoxyCodeLine{00843\ \ \ \ \ \ \ tf.shape(box\_masks)[0]\ >\ 0,}
\DoxyCodeLine{00844\ \ \ \ \ \ \ reframe\_box\_masks\_to\_image\_masks\_default,}
\DoxyCodeLine{00845\ \ \ \ \ \ \ \textcolor{keyword}{lambda}:\ tf.zeros([0,\ image\_height,\ image\_width,\ 1],\ dtype=tf.float32))}
\DoxyCodeLine{00846\ \ \ \textcolor{keywordflow}{return}\ tf.squeeze(image\_masks,\ axis=3)}
\DoxyCodeLine{00847\ }
\DoxyCodeLine{00848\ }

\end{DoxyCode}
\Hypertarget{namespacedetection__utils_1_1utils_1_1ops_ae9ea79fd4a604caa7430abce7d10bcef}\label{namespacedetection__utils_1_1utils_1_1ops_ae9ea79fd4a604caa7430abce7d10bcef} 
\index{detection\_utils.utils.ops@{detection\_utils.utils.ops}!replace\_nan\_groundtruth\_label\_scores\_with\_ones@{replace\_nan\_groundtruth\_label\_scores\_with\_ones}}
\index{replace\_nan\_groundtruth\_label\_scores\_with\_ones@{replace\_nan\_groundtruth\_label\_scores\_with\_ones}!detection\_utils.utils.ops@{detection\_utils.utils.ops}}
\doxysubsubsection{\texorpdfstring{replace\_nan\_groundtruth\_label\_scores\_with\_ones()}{replace\_nan\_groundtruth\_label\_scores\_with\_ones()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+utils.\+ops.\+replace\+\_\+nan\+\_\+groundtruth\+\_\+label\+\_\+scores\+\_\+with\+\_\+ones (\begin{DoxyParamCaption}\item[{}]{label\+\_\+scores }\end{DoxyParamCaption})}

\begin{DoxyVerb}Replaces nan label scores with 1.0.

Args:
  label_scores: a tensor containing object annoation label scores.

Returns:
  a tensor where NaN label scores have been replaced by ones.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{ops_8py_source_l00432}{432}} of file \mbox{\hyperlink{ops_8py_source}{ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00432\ \textcolor{keyword}{def\ }replace\_nan\_groundtruth\_label\_scores\_with\_ones(label\_scores):}
\DoxyCodeLine{00433\ \ \ \textcolor{stringliteral}{"{}"{}"{}Replaces\ nan\ label\ scores\ with\ 1.0.}}
\DoxyCodeLine{00434\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00435\ \textcolor{stringliteral}{\ \ Args:}}
\DoxyCodeLine{00436\ \textcolor{stringliteral}{\ \ \ \ label\_scores:\ a\ tensor\ containing\ object\ annoation\ label\ scores.}}
\DoxyCodeLine{00437\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00438\ \textcolor{stringliteral}{\ \ Returns:}}
\DoxyCodeLine{00439\ \textcolor{stringliteral}{\ \ \ \ a\ tensor\ where\ NaN\ label\ scores\ have\ been\ replaced\ by\ ones.}}
\DoxyCodeLine{00440\ \textcolor{stringliteral}{\ \ "{}"{}"{}}}
\DoxyCodeLine{00441\ \textcolor{stringliteral}{\ \ }\textcolor{keywordflow}{return}\ tf.where(}
\DoxyCodeLine{00442\ \ \ \ \ \ \ tf.is\_nan(label\_scores),\ tf.ones(tf.shape(label\_scores)),\ label\_scores)}
\DoxyCodeLine{00443\ }
\DoxyCodeLine{00444\ }

\end{DoxyCode}
\Hypertarget{namespacedetection__utils_1_1utils_1_1ops_af4c44e343c3cb222937eb3e496ce68e6}\label{namespacedetection__utils_1_1utils_1_1ops_af4c44e343c3cb222937eb3e496ce68e6} 
\index{detection\_utils.utils.ops@{detection\_utils.utils.ops}!retain\_groundtruth@{retain\_groundtruth}}
\index{retain\_groundtruth@{retain\_groundtruth}!detection\_utils.utils.ops@{detection\_utils.utils.ops}}
\doxysubsubsection{\texorpdfstring{retain\_groundtruth()}{retain\_groundtruth()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+utils.\+ops.\+retain\+\_\+groundtruth (\begin{DoxyParamCaption}\item[{}]{tensor\+\_\+dict,  }\item[{}]{valid\+\_\+indices }\end{DoxyParamCaption})}

\begin{DoxyVerb}Retains groundtruth by valid indices.

Args:
  tensor_dict: a dictionary of following groundtruth tensors -
    fields.InputDataFields.groundtruth_boxes
    fields.InputDataFields.groundtruth_classes
    fields.InputDataFields.groundtruth_confidences
    fields.InputDataFields.groundtruth_keypoints
    fields.InputDataFields.groundtruth_instance_masks
    fields.InputDataFields.groundtruth_is_crowd
    fields.InputDataFields.groundtruth_area
    fields.InputDataFields.groundtruth_label_types
    fields.InputDataFields.groundtruth_difficult
  valid_indices: a tensor with valid indices for the box-level groundtruth.

Returns:
  a dictionary of tensors containing only the groundtruth for valid_indices.

Raises:
  ValueError: If the shape of valid_indices is invalid.
  ValueError: field fields.InputDataFields.groundtruth_boxes is
    not present in tensor_dict.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{ops_8py_source_l00343}{343}} of file \mbox{\hyperlink{ops_8py_source}{ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00343\ \textcolor{keyword}{def\ }retain\_groundtruth(tensor\_dict,\ valid\_indices):}
\DoxyCodeLine{00344\ \ \ \textcolor{stringliteral}{"{}"{}"{}Retains\ groundtruth\ by\ valid\ indices.}}
\DoxyCodeLine{00345\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00346\ \textcolor{stringliteral}{\ \ Args:}}
\DoxyCodeLine{00347\ \textcolor{stringliteral}{\ \ \ \ tensor\_dict:\ a\ dictionary\ of\ following\ groundtruth\ tensors\ -\/}}
\DoxyCodeLine{00348\ \textcolor{stringliteral}{\ \ \ \ \ \ fields.InputDataFields.groundtruth\_boxes}}
\DoxyCodeLine{00349\ \textcolor{stringliteral}{\ \ \ \ \ \ fields.InputDataFields.groundtruth\_classes}}
\DoxyCodeLine{00350\ \textcolor{stringliteral}{\ \ \ \ \ \ fields.InputDataFields.groundtruth\_confidences}}
\DoxyCodeLine{00351\ \textcolor{stringliteral}{\ \ \ \ \ \ fields.InputDataFields.groundtruth\_keypoints}}
\DoxyCodeLine{00352\ \textcolor{stringliteral}{\ \ \ \ \ \ fields.InputDataFields.groundtruth\_instance\_masks}}
\DoxyCodeLine{00353\ \textcolor{stringliteral}{\ \ \ \ \ \ fields.InputDataFields.groundtruth\_is\_crowd}}
\DoxyCodeLine{00354\ \textcolor{stringliteral}{\ \ \ \ \ \ fields.InputDataFields.groundtruth\_area}}
\DoxyCodeLine{00355\ \textcolor{stringliteral}{\ \ \ \ \ \ fields.InputDataFields.groundtruth\_label\_types}}
\DoxyCodeLine{00356\ \textcolor{stringliteral}{\ \ \ \ \ \ fields.InputDataFields.groundtruth\_difficult}}
\DoxyCodeLine{00357\ \textcolor{stringliteral}{\ \ \ \ valid\_indices:\ a\ tensor\ }\textcolor{keyword}{with}\ valid\ indices\ \textcolor{keywordflow}{for}\ the\ box-\/level\ groundtruth.}
\DoxyCodeLine{00358\ }
\DoxyCodeLine{00359\ \ \ Returns:}
\DoxyCodeLine{00360\ \ \ \ \ a\ dictionary\ of\ tensors\ containing\ only\ the\ groundtruth\ \textcolor{keywordflow}{for}\ valid\_indices.}
\DoxyCodeLine{00361\ }
\DoxyCodeLine{00362\ \ \ Raises:}
\DoxyCodeLine{00363\ \ \ \ \ ValueError:\ If\ the\ shape\ of\ valid\_indices\ \textcolor{keywordflow}{is}\ invalid.}
\DoxyCodeLine{00364\ \ \ \ \ ValueError:\ field\ fields.InputDataFields.groundtruth\_boxes\ \textcolor{keywordflow}{is}}
\DoxyCodeLine{00365\ \ \ \ \ \ \ \textcolor{keywordflow}{not}\ present\ \textcolor{keywordflow}{in}\ tensor\_dict.}
\DoxyCodeLine{00366\ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{00367\ \textcolor{stringliteral}{\ \ input\_shape\ =\ valid\_indices.get\_shape().as\_list()}}
\DoxyCodeLine{00368\ \textcolor{stringliteral}{\ \ }\textcolor{keywordflow}{if}\ \textcolor{keywordflow}{not}\ (len(input\_shape)\ ==\ 1\ \textcolor{keywordflow}{or}}
\DoxyCodeLine{00369\ \ \ \ \ \ \ \ \ \ \ (len(input\_shape)\ ==\ 2\ \textcolor{keywordflow}{and}\ input\_shape[1]\ ==\ 1)):}
\DoxyCodeLine{00370\ \ \ \ \ \textcolor{keywordflow}{raise}\ ValueError(\textcolor{stringliteral}{'The\ shape\ of\ valid\_indices\ is\ invalid.'})}
\DoxyCodeLine{00371\ \ \ valid\_indices\ =\ tf.reshape(valid\_indices,\ [-\/1])}
\DoxyCodeLine{00372\ \ \ valid\_dict\ =\ \{\}}
\DoxyCodeLine{00373\ \ \ \textcolor{keywordflow}{if}\ fields.InputDataFields.groundtruth\_boxes\ \textcolor{keywordflow}{in}\ tensor\_dict:}
\DoxyCodeLine{00374\ \ \ \ \ \textcolor{comment}{\#\ Prevents\ reshape\ failure\ when\ num\_boxes\ is\ 0.}}
\DoxyCodeLine{00375\ \ \ \ \ num\_boxes\ =\ tf.maximum(tf.shape(}
\DoxyCodeLine{00376\ \ \ \ \ \ \ \ \ tensor\_dict[fields.InputDataFields.groundtruth\_boxes])[0],\ 1)}
\DoxyCodeLine{00377\ \ \ \ \ \textcolor{keywordflow}{for}\ key\ \textcolor{keywordflow}{in}\ tensor\_dict:}
\DoxyCodeLine{00378\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ key\ \textcolor{keywordflow}{in}\ [fields.InputDataFields.groundtruth\_boxes,}
\DoxyCodeLine{00379\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ fields.InputDataFields.groundtruth\_classes,}
\DoxyCodeLine{00380\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ fields.InputDataFields.groundtruth\_confidences,}
\DoxyCodeLine{00381\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ fields.InputDataFields.groundtruth\_keypoints,}
\DoxyCodeLine{00382\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ fields.InputDataFields.groundtruth\_keypoint\_visibilities,}
\DoxyCodeLine{00383\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ fields.InputDataFields.groundtruth\_instance\_masks]:}
\DoxyCodeLine{00384\ \ \ \ \ \ \ \ \ valid\_dict[key]\ =\ tf.gather(tensor\_dict[key],\ valid\_indices)}
\DoxyCodeLine{00385\ \ \ \ \ \ \ \textcolor{comment}{\#\ Input\ decoder\ returns\ empty\ tensor\ when\ these\ fields\ are\ not\ provided.}}
\DoxyCodeLine{00386\ \ \ \ \ \ \ \textcolor{comment}{\#\ Needs\ to\ reshape\ into\ [num\_boxes,\ -\/1]\ for\ tf.gather()\ to\ work.}}
\DoxyCodeLine{00387\ \ \ \ \ \ \ \textcolor{keywordflow}{elif}\ key\ \textcolor{keywordflow}{in}\ [fields.InputDataFields.groundtruth\_is\_crowd,}
\DoxyCodeLine{00388\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ fields.InputDataFields.groundtruth\_area,}
\DoxyCodeLine{00389\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ fields.InputDataFields.groundtruth\_difficult,}
\DoxyCodeLine{00390\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ fields.InputDataFields.groundtruth\_label\_types]:}
\DoxyCodeLine{00391\ \ \ \ \ \ \ \ \ valid\_dict[key]\ =\ tf.reshape(}
\DoxyCodeLine{00392\ \ \ \ \ \ \ \ \ \ \ \ \ tf.gather(tf.reshape(tensor\_dict[key],\ [num\_boxes,\ -\/1]),}
\DoxyCodeLine{00393\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ valid\_indices),\ [-\/1])}
\DoxyCodeLine{00394\ \ \ \ \ \ \ \textcolor{comment}{\#\ Fields\ that\ are\ not\ associated\ with\ boxes.}}
\DoxyCodeLine{00395\ \ \ \ \ \ \ \textcolor{keywordflow}{else}:}
\DoxyCodeLine{00396\ \ \ \ \ \ \ \ \ valid\_dict[key]\ =\ tensor\_dict[key]}
\DoxyCodeLine{00397\ \ \ \textcolor{keywordflow}{else}:}
\DoxyCodeLine{00398\ \ \ \ \ \textcolor{keywordflow}{raise}\ ValueError(\textcolor{stringliteral}{'\%s\ not\ present\ in\ input\ tensor\ dict.'}\ \%\ (}
\DoxyCodeLine{00399\ \ \ \ \ \ \ \ \ fields.InputDataFields.groundtruth\_boxes))}
\DoxyCodeLine{00400\ \ \ \textcolor{keywordflow}{return}\ valid\_dict}
\DoxyCodeLine{00401\ }
\DoxyCodeLine{00402\ }

\end{DoxyCode}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{db/d47/namespacedetection__utils_1_1utils_1_1ops_af4c44e343c3cb222937eb3e496ce68e6_icgraph}
\end{center}
\end{figure}
\Hypertarget{namespacedetection__utils_1_1utils_1_1ops_ae6ecd4d38671df8c284d9a856f1d603f}\label{namespacedetection__utils_1_1utils_1_1ops_ae6ecd4d38671df8c284d9a856f1d603f} 
\index{detection\_utils.utils.ops@{detection\_utils.utils.ops}!retain\_groundtruth\_with\_positive\_classes@{retain\_groundtruth\_with\_positive\_classes}}
\index{retain\_groundtruth\_with\_positive\_classes@{retain\_groundtruth\_with\_positive\_classes}!detection\_utils.utils.ops@{detection\_utils.utils.ops}}
\doxysubsubsection{\texorpdfstring{retain\_groundtruth\_with\_positive\_classes()}{retain\_groundtruth\_with\_positive\_classes()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+utils.\+ops.\+retain\+\_\+groundtruth\+\_\+with\+\_\+positive\+\_\+classes (\begin{DoxyParamCaption}\item[{}]{tensor\+\_\+dict }\end{DoxyParamCaption})}

\begin{DoxyVerb}Retains only groundtruth with positive class ids.

Args:
  tensor_dict: a dictionary of following groundtruth tensors -
    fields.InputDataFields.groundtruth_boxes
    fields.InputDataFields.groundtruth_classes
    fields.InputDataFields.groundtruth_confidences
    fields.InputDataFields.groundtruth_keypoints
    fields.InputDataFields.groundtruth_instance_masks
    fields.InputDataFields.groundtruth_is_crowd
    fields.InputDataFields.groundtruth_area
    fields.InputDataFields.groundtruth_label_types
    fields.InputDataFields.groundtruth_difficult

Returns:
  a dictionary of tensors containing only the groundtruth with positive
  classes.

Raises:
  ValueError: If groundtruth_classes tensor is not in tensor_dict.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{ops_8py_source_l00403}{403}} of file \mbox{\hyperlink{ops_8py_source}{ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00403\ \textcolor{keyword}{def\ }retain\_groundtruth\_with\_positive\_classes(tensor\_dict):}
\DoxyCodeLine{00404\ \ \ \textcolor{stringliteral}{"{}"{}"{}Retains\ only\ groundtruth\ with\ positive\ class\ ids.}}
\DoxyCodeLine{00405\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00406\ \textcolor{stringliteral}{\ \ Args:}}
\DoxyCodeLine{00407\ \textcolor{stringliteral}{\ \ \ \ tensor\_dict:\ a\ dictionary\ of\ following\ groundtruth\ tensors\ -\/}}
\DoxyCodeLine{00408\ \textcolor{stringliteral}{\ \ \ \ \ \ fields.InputDataFields.groundtruth\_boxes}}
\DoxyCodeLine{00409\ \textcolor{stringliteral}{\ \ \ \ \ \ fields.InputDataFields.groundtruth\_classes}}
\DoxyCodeLine{00410\ \textcolor{stringliteral}{\ \ \ \ \ \ fields.InputDataFields.groundtruth\_confidences}}
\DoxyCodeLine{00411\ \textcolor{stringliteral}{\ \ \ \ \ \ fields.InputDataFields.groundtruth\_keypoints}}
\DoxyCodeLine{00412\ \textcolor{stringliteral}{\ \ \ \ \ \ fields.InputDataFields.groundtruth\_instance\_masks}}
\DoxyCodeLine{00413\ \textcolor{stringliteral}{\ \ \ \ \ \ fields.InputDataFields.groundtruth\_is\_crowd}}
\DoxyCodeLine{00414\ \textcolor{stringliteral}{\ \ \ \ \ \ fields.InputDataFields.groundtruth\_area}}
\DoxyCodeLine{00415\ \textcolor{stringliteral}{\ \ \ \ \ \ fields.InputDataFields.groundtruth\_label\_types}}
\DoxyCodeLine{00416\ \textcolor{stringliteral}{\ \ \ \ \ \ fields.InputDataFields.groundtruth\_difficult}}
\DoxyCodeLine{00417\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00418\ \textcolor{stringliteral}{\ \ Returns:}}
\DoxyCodeLine{00419\ \textcolor{stringliteral}{\ \ \ \ a\ dictionary\ of\ tensors\ containing\ only\ the\ groundtruth\ }\textcolor{keyword}{with}\ positive}
\DoxyCodeLine{00420\ \ \ \ \ classes.}
\DoxyCodeLine{00421\ }
\DoxyCodeLine{00422\ \ \ Raises:}
\DoxyCodeLine{00423\ \ \ \ \ ValueError:\ If\ groundtruth\_classes\ tensor\ \textcolor{keywordflow}{is}\ \textcolor{keywordflow}{not}\ \textcolor{keywordflow}{in}\ tensor\_dict.}
\DoxyCodeLine{00424\ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{00425\ \textcolor{stringliteral}{\ \ }\textcolor{keywordflow}{if}\ fields.InputDataFields.groundtruth\_classes\ \textcolor{keywordflow}{not}\ \textcolor{keywordflow}{in}\ tensor\_dict:}
\DoxyCodeLine{00426\ \ \ \ \ \textcolor{keywordflow}{raise}\ ValueError(\textcolor{stringliteral}{'\`{}groundtruth\ classes`\ not\ in\ tensor\_dict.'})}
\DoxyCodeLine{00427\ \ \ keep\_indices\ =\ tf.where(tf.greater(}
\DoxyCodeLine{00428\ \ \ \ \ \ \ tensor\_dict[fields.InputDataFields.groundtruth\_classes],\ 0))}
\DoxyCodeLine{00429\ \ \ \textcolor{keywordflow}{return}\ retain\_groundtruth(tensor\_dict,\ keep\_indices)}
\DoxyCodeLine{00430\ }
\DoxyCodeLine{00431\ }

\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{db/d47/namespacedetection__utils_1_1utils_1_1ops_ae6ecd4d38671df8c284d9a856f1d603f_cgraph}
\end{center}
\end{figure}


\doxysubsection{Variable Documentation}
\Hypertarget{namespacedetection__utils_1_1utils_1_1ops_a82ed092503588fcc71b43646a1100dac}\label{namespacedetection__utils_1_1utils_1_1ops_a82ed092503588fcc71b43646a1100dac} 
\index{detection\_utils.utils.ops@{detection\_utils.utils.ops}!EqualizationLossConfig@{EqualizationLossConfig}}
\index{EqualizationLossConfig@{EqualizationLossConfig}!detection\_utils.utils.ops@{detection\_utils.utils.ops}}
\doxysubsubsection{\texorpdfstring{EqualizationLossConfig}{EqualizationLossConfig}}
{\footnotesize\ttfamily detection\+\_\+utils.\+utils.\+ops.\+Equalization\+Loss\+Config}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ collections.namedtuple(\textcolor{stringliteral}{'EqualizationLossConfig'},}
\DoxyCodeLine{00002\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ [\textcolor{stringliteral}{'weight'},\ \textcolor{stringliteral}{'exclude\_prefixes'}])}

\end{DoxyCode}


Definition at line \mbox{\hyperlink{ops_8py_source_l01093}{1093}} of file \mbox{\hyperlink{ops_8py_source}{ops.\+py}}.

\Hypertarget{namespacedetection__utils_1_1utils_1_1ops_a33f64e9ecb63a23af0c998ebb402c533}\label{namespacedetection__utils_1_1utils_1_1ops_a33f64e9ecb63a23af0c998ebb402c533} 
\index{detection\_utils.utils.ops@{detection\_utils.utils.ops}!matmul\_crop\_and\_resize@{matmul\_crop\_and\_resize}}
\index{matmul\_crop\_and\_resize@{matmul\_crop\_and\_resize}!detection\_utils.utils.ops@{detection\_utils.utils.ops}}
\doxysubsubsection{\texorpdfstring{matmul\_crop\_and\_resize}{matmul\_crop\_and\_resize}}
{\footnotesize\ttfamily detection\+\_\+utils.\+utils.\+ops.\+matmul\+\_\+crop\+\_\+and\+\_\+resize = spatial\+\_\+ops.\+matmul\+\_\+crop\+\_\+and\+\_\+resize}



Definition at line \mbox{\hyperlink{ops_8py_source_l00035}{35}} of file \mbox{\hyperlink{ops_8py_source}{ops.\+py}}.

\Hypertarget{namespacedetection__utils_1_1utils_1_1ops_af020a014cef7a2230e195b6b6a02e88f}\label{namespacedetection__utils_1_1utils_1_1ops_af020a014cef7a2230e195b6b6a02e88f} 
\index{detection\_utils.utils.ops@{detection\_utils.utils.ops}!multilevel\_roi\_align@{multilevel\_roi\_align}}
\index{multilevel\_roi\_align@{multilevel\_roi\_align}!detection\_utils.utils.ops@{detection\_utils.utils.ops}}
\doxysubsubsection{\texorpdfstring{multilevel\_roi\_align}{multilevel\_roi\_align}}
{\footnotesize\ttfamily detection\+\_\+utils.\+utils.\+ops.\+multilevel\+\_\+roi\+\_\+align = spatial\+\_\+ops.\+multilevel\+\_\+roi\+\_\+align}



Definition at line \mbox{\hyperlink{ops_8py_source_l00036}{36}} of file \mbox{\hyperlink{ops_8py_source}{ops.\+py}}.

\Hypertarget{namespacedetection__utils_1_1utils_1_1ops_a3c7872f0750bfae89334d4e6073caabf}\label{namespacedetection__utils_1_1utils_1_1ops_a3c7872f0750bfae89334d4e6073caabf} 
\index{detection\_utils.utils.ops@{detection\_utils.utils.ops}!native\_crop\_and\_resize@{native\_crop\_and\_resize}}
\index{native\_crop\_and\_resize@{native\_crop\_and\_resize}!detection\_utils.utils.ops@{detection\_utils.utils.ops}}
\doxysubsubsection{\texorpdfstring{native\_crop\_and\_resize}{native\_crop\_and\_resize}}
{\footnotesize\ttfamily detection\+\_\+utils.\+utils.\+ops.\+native\+\_\+crop\+\_\+and\+\_\+resize = spatial\+\_\+ops.\+native\+\_\+crop\+\_\+and\+\_\+resize}



Definition at line \mbox{\hyperlink{ops_8py_source_l00037}{37}} of file \mbox{\hyperlink{ops_8py_source}{ops.\+py}}.

