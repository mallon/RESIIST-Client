\doxysection{detection\+\_\+utils.\+core.\+box\+\_\+list\+\_\+ops Namespace Reference}
\hypertarget{namespacedetection__utils_1_1core_1_1box__list__ops}{}\label{namespacedetection__utils_1_1core_1_1box__list__ops}\index{detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}}
\doxysubsubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classdetection__utils_1_1core_1_1box__list__ops_1_1_sort_order}{Sort\+Order}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1core_1_1box__list__ops_a92898db065feb66a9559123f5dc1190e}{area}} (boxlist, scope=None)
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1core_1_1box__list__ops_a30d8f8a23a3ee1a92ed2aded0b20b761}{height\+\_\+width}} (boxlist, scope=None)
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1core_1_1box__list__ops_a890e93aacb6d9ba7532251c3047d53fd}{scale}} (boxlist, y\+\_\+scale, x\+\_\+scale, scope=None)
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1core_1_1box__list__ops_a0c75cbd62f25f099ee47c6f50a22c12d}{clip\+\_\+to\+\_\+window}} (boxlist, window, filter\+\_\+nonoverlapping=True, scope=None)
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1core_1_1box__list__ops_a8cce2ae473046db81897506796042133}{prune\+\_\+outside\+\_\+window}} (boxlist, window, scope=None)
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1core_1_1box__list__ops_ac97746ffdde0c48bd2bad8c439c6bd3c}{prune\+\_\+completely\+\_\+outside\+\_\+window}} (boxlist, window, scope=None)
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1core_1_1box__list__ops_afd15da7dda22daae6756580f198e34da}{intersection}} (boxlist1, boxlist2, scope=None)
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1core_1_1box__list__ops_afdde2971529ea91174efe09af9202c05}{matched\+\_\+intersection}} (boxlist1, boxlist2, scope=None)
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1core_1_1box__list__ops_a0c3ceb43da9213d701fe159dd5ab3b16}{iou}} (boxlist1, boxlist2, scope=None)
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1core_1_1box__list__ops_a9fad601f99641baf7fda27235c4723a0}{matched\+\_\+iou}} (boxlist1, boxlist2, scope=None)
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1core_1_1box__list__ops_a9e0ac719b5e09ec7392954a9c9fe4174}{ioa}} (boxlist1, boxlist2, scope=None)
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1core_1_1box__list__ops_a71b57b4bfadf9a8c24875f06c894ec79}{prune\+\_\+non\+\_\+overlapping\+\_\+boxes}} (boxlist1, boxlist2, min\+\_\+overlap=0.\+0, scope=None)
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1core_1_1box__list__ops_a121943718c068c50e17a0dbbde02b17e}{prune\+\_\+small\+\_\+boxes}} (boxlist, min\+\_\+side, scope=None)
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1core_1_1box__list__ops_a725390a73d7d904bf824344014ed055c}{change\+\_\+coordinate\+\_\+frame}} (boxlist, window, scope=None)
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1core_1_1box__list__ops_a2e9b6ea6358fa09ac69ff5f20e6696ee}{sq\+\_\+dist}} (boxlist1, boxlist2, scope=None)
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1core_1_1box__list__ops_ad52cd56fc9dc0a632dd326e489bd1399}{boolean\+\_\+mask}} (boxlist, indicator, fields=None, scope=None, use\+\_\+static\+\_\+shapes=False, indicator\+\_\+sum=None)
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1core_1_1box__list__ops_ab935f3907c57be324fe3e04a553aad0b}{gather}} (boxlist, indices, fields=None, scope=None, use\+\_\+static\+\_\+shapes=False)
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1core_1_1box__list__ops_a7bdc06a00ef29d99daeab567329d7421}{concatenate}} (boxlists, fields=None, scope=None)
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1core_1_1box__list__ops_a103f0e0e0eeb3193514895e6b2c9ba94}{sort\+\_\+by\+\_\+field}} (boxlist, field, order=\mbox{\hyperlink{classdetection__utils_1_1core_1_1box__list__ops_1_1_sort_order_a50eb8b077a78822f0085d91664f9226d}{Sort\+Order.\+descend}}, scope=None)
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1core_1_1box__list__ops_ab18840a73551ff7a36605bc8e53552e4}{visualize\+\_\+boxes\+\_\+in\+\_\+image}} (image, boxlist, normalized=False, scope=None)
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1core_1_1box__list__ops_a704393f594559cb69a017b29adfb0eab}{filter\+\_\+field\+\_\+value\+\_\+equals}} (boxlist, field, value, scope=None)
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1core_1_1box__list__ops_af19b9892d46f5558103b58fb131dc5c5}{filter\+\_\+greater\+\_\+than}} (boxlist, thresh, scope=None)
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1core_1_1box__list__ops_a4f53127d0876cf0b4ab378bf7d2e2ef1}{non\+\_\+max\+\_\+suppression}} (boxlist, thresh, max\+\_\+output\+\_\+size, scope=None)
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1core_1_1box__list__ops_a3627514ae9ddcaf45f6039284657db24}{\+\_\+copy\+\_\+extra\+\_\+fields}} (boxlist\+\_\+to\+\_\+copy\+\_\+to, boxlist\+\_\+to\+\_\+copy\+\_\+from)
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1core_1_1box__list__ops_a8a6b7f0a6aa75c518f14f90c8480c146}{to\+\_\+normalized\+\_\+coordinates}} (boxlist, height, width, check\+\_\+range=True, scope=None)
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1core_1_1box__list__ops_ada89676fbe54301964c23a14e0260a8c}{to\+\_\+absolute\+\_\+coordinates}} (boxlist, height, width, check\+\_\+range=True, maximum\+\_\+normalized\+\_\+coordinate=1.\+1, scope=None)
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1core_1_1box__list__ops_a94cd2ba48717a3b24c2889ac73e749f9}{refine\+\_\+boxes\+\_\+multi\+\_\+class}} (pool\+\_\+boxes, num\+\_\+classes, nms\+\_\+iou\+\_\+thresh, nms\+\_\+max\+\_\+detections, voting\+\_\+iou\+\_\+thresh=0.\+5)
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1core_1_1box__list__ops_a7763ebbaf43a4450d6ae5d0fe88398a7}{refine\+\_\+boxes}} (pool\+\_\+boxes, nms\+\_\+iou\+\_\+thresh, nms\+\_\+max\+\_\+detections, voting\+\_\+iou\+\_\+thresh=0.\+5)
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1core_1_1box__list__ops_a6d89634b5541a267c532cd81b4abaf64}{box\+\_\+voting}} (selected\+\_\+boxes, pool\+\_\+boxes, iou\+\_\+thresh=0.\+5)
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1core_1_1box__list__ops_ad7ee814b54c928c4600ce5f111e6b51b}{pad\+\_\+or\+\_\+clip\+\_\+box\+\_\+list}} (boxlist, num\+\_\+boxes, scope=None)
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1core_1_1box__list__ops_a4bce696e11d0578132e9c0e56ab93167}{select\+\_\+random\+\_\+box}} (boxlist, default\+\_\+box=None, seed=None, scope=None)
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1core_1_1box__list__ops_ab20486b60634ec258c5e24dbc5f64e52}{get\+\_\+minimal\+\_\+coverage\+\_\+box}} (boxlist, default\+\_\+box=None, scope=None)
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1core_1_1box__list__ops_a15808676e298dede166cab386896e46c}{sample\+\_\+boxes\+\_\+by\+\_\+jittering}} (boxlist, num\+\_\+boxes\+\_\+to\+\_\+sample, stddev=0.\+1, scope=None)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\begin{DoxyVerb}Bounding Box List operations.

Example box operations that are supported:
  * areas: compute bounding box areas
  * iou: pairwise intersection-over-union scores
  * sq_dist: pairwise distances between bounding boxes

Whenever box_list_ops functions output a BoxList, the fields of the incoming
BoxList are retained unless documented otherwise.
\end{DoxyVerb}
 

\doxysubsection{Function Documentation}
\Hypertarget{namespacedetection__utils_1_1core_1_1box__list__ops_a3627514ae9ddcaf45f6039284657db24}\label{namespacedetection__utils_1_1core_1_1box__list__ops_a3627514ae9ddcaf45f6039284657db24} 
\index{detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}!\_copy\_extra\_fields@{\_copy\_extra\_fields}}
\index{\_copy\_extra\_fields@{\_copy\_extra\_fields}!detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}}
\doxysubsubsection{\texorpdfstring{\_copy\_extra\_fields()}{\_copy\_extra\_fields()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+core.\+box\+\_\+list\+\_\+ops.\+\_\+copy\+\_\+extra\+\_\+fields (\begin{DoxyParamCaption}\item[{}]{boxlist\+\_\+to\+\_\+copy\+\_\+to,  }\item[{}]{boxlist\+\_\+to\+\_\+copy\+\_\+from }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Copies the extra fields of boxlist_to_copy_from to boxlist_to_copy_to.

Args:
  boxlist_to_copy_to: BoxList to which extra fields are copied.
  boxlist_to_copy_from: BoxList from which fields are copied.

Returns:
  boxlist_to_copy_to with extra fields.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{box__list__ops_8py_source_l00757}{757}} of file \mbox{\hyperlink{box__list__ops_8py_source}{box\+\_\+list\+\_\+ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00757\ \textcolor{keyword}{def\ }\_copy\_extra\_fields(boxlist\_to\_copy\_to,\ boxlist\_to\_copy\_from):}
\DoxyCodeLine{00758\ \ \ \textcolor{stringliteral}{"{}"{}"{}Copies\ the\ extra\ fields\ of\ boxlist\_to\_copy\_from\ to\ boxlist\_to\_copy\_to.}}
\DoxyCodeLine{00759\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00760\ \textcolor{stringliteral}{\ \ Args:}}
\DoxyCodeLine{00761\ \textcolor{stringliteral}{\ \ \ \ boxlist\_to\_copy\_to:\ BoxList\ to\ which\ extra\ fields\ are\ copied.}}
\DoxyCodeLine{00762\ \textcolor{stringliteral}{\ \ \ \ boxlist\_to\_copy\_from:\ BoxList\ }\textcolor{keyword}{from}\ which\ fields\ are\ copied.}
\DoxyCodeLine{00763\ }
\DoxyCodeLine{00764\ \ \ Returns:}
\DoxyCodeLine{00765\ \ \ \ \ boxlist\_to\_copy\_to\ \textcolor{keyword}{with}\ extra\ fields.}
\DoxyCodeLine{00766\ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{00767\ \textcolor{stringliteral}{\ \ }\textcolor{keywordflow}{for}\ field\ \textcolor{keywordflow}{in}\ boxlist\_to\_copy\_from.get\_extra\_fields():}
\DoxyCodeLine{00768\ \ \ \ \ boxlist\_to\_copy\_to.add\_field(field,\ boxlist\_to\_copy\_from.get\_field(field))}
\DoxyCodeLine{00769\ \ \ \textcolor{keywordflow}{return}\ boxlist\_to\_copy\_to}
\DoxyCodeLine{00770\ }
\DoxyCodeLine{00771\ }

\end{DoxyCode}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d9/da1/namespacedetection__utils_1_1core_1_1box__list__ops_a3627514ae9ddcaf45f6039284657db24_icgraph}
\end{center}
\end{figure}
\Hypertarget{namespacedetection__utils_1_1core_1_1box__list__ops_a92898db065feb66a9559123f5dc1190e}\label{namespacedetection__utils_1_1core_1_1box__list__ops_a92898db065feb66a9559123f5dc1190e} 
\index{detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}!area@{area}}
\index{area@{area}!detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}}
\doxysubsubsection{\texorpdfstring{area()}{area()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+core.\+box\+\_\+list\+\_\+ops.\+area (\begin{DoxyParamCaption}\item[{}]{boxlist,  }\item[{}]{scope = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Computes area of boxes.

Args:
  boxlist: BoxList holding N boxes
  scope: name scope.

Returns:
  a tensor with shape [N] representing box areas.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{box__list__ops_8py_source_l00049}{49}} of file \mbox{\hyperlink{box__list__ops_8py_source}{box\+\_\+list\+\_\+ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00049\ \textcolor{keyword}{def\ }area(boxlist,\ scope=None):}
\DoxyCodeLine{00050\ \ \ \textcolor{stringliteral}{"{}"{}"{}Computes\ area\ of\ boxes.}}
\DoxyCodeLine{00051\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00052\ \textcolor{stringliteral}{\ \ Args:}}
\DoxyCodeLine{00053\ \textcolor{stringliteral}{\ \ \ \ boxlist:\ BoxList\ holding\ N\ boxes}}
\DoxyCodeLine{00054\ \textcolor{stringliteral}{\ \ \ \ scope:\ name\ scope.}}
\DoxyCodeLine{00055\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00056\ \textcolor{stringliteral}{\ \ Returns:}}
\DoxyCodeLine{00057\ \textcolor{stringliteral}{\ \ \ \ a\ tensor\ }\textcolor{keyword}{with}\ shape\ [N]\ representing\ box\ areas.}
\DoxyCodeLine{00058\ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{00059\ \textcolor{stringliteral}{\ \ }\textcolor{keyword}{with}\ tf.name\_scope(scope,\ \textcolor{stringliteral}{'Area'}):}
\DoxyCodeLine{00060\ \ \ \ \ y\_min,\ x\_min,\ y\_max,\ x\_max\ =\ tf.split(}
\DoxyCodeLine{00061\ \ \ \ \ \ \ \ \ value=boxlist.get(),\ num\_or\_size\_splits=4,\ axis=1)}
\DoxyCodeLine{00062\ \ \ \ \ \textcolor{keywordflow}{return}\ tf.squeeze((y\_max\ -\/\ y\_min)\ *\ (x\_max\ -\/\ x\_min),\ [1])}
\DoxyCodeLine{00063\ }
\DoxyCodeLine{00064\ }

\end{DoxyCode}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d9/da1/namespacedetection__utils_1_1core_1_1box__list__ops_a92898db065feb66a9559123f5dc1190e_icgraph}
\end{center}
\end{figure}
\Hypertarget{namespacedetection__utils_1_1core_1_1box__list__ops_ad52cd56fc9dc0a632dd326e489bd1399}\label{namespacedetection__utils_1_1core_1_1box__list__ops_ad52cd56fc9dc0a632dd326e489bd1399} 
\index{detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}!boolean\_mask@{boolean\_mask}}
\index{boolean\_mask@{boolean\_mask}!detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}}
\doxysubsubsection{\texorpdfstring{boolean\_mask()}{boolean\_mask()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+core.\+box\+\_\+list\+\_\+ops.\+boolean\+\_\+mask (\begin{DoxyParamCaption}\item[{}]{boxlist,  }\item[{}]{indicator,  }\item[{}]{fields = {\ttfamily None},  }\item[{}]{scope = {\ttfamily None},  }\item[{}]{use\+\_\+static\+\_\+shapes = {\ttfamily False},  }\item[{}]{indicator\+\_\+sum = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Select boxes from BoxList according to indicator and return new BoxList.

`boolean_mask` returns the subset of boxes that are marked as "True" by the
indicator tensor. By default, `boolean_mask` returns boxes corresponding to
the input index list, as well as all additional fields stored in the boxlist
(indexing into the first dimension).  However one can optionally only draw
from a subset of fields.

Args:
  boxlist: BoxList holding N boxes
  indicator: a rank-1 boolean tensor
  fields: (optional) list of fields to also gather from.  If None (default),
    all fields are gathered from.  Pass an empty fields list to only gather
    the box coordinates.
  scope: name scope.
  use_static_shapes: Whether to use an implementation with static shape
    gurantees.
  indicator_sum: An integer containing the sum of `indicator` vector. Only
    required if `use_static_shape` is True.

Returns:
  subboxlist: a BoxList corresponding to the subset of the input BoxList
    specified by indicator
Raises:
  ValueError: if `indicator` is not a rank-1 boolean tensor.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{box__list__ops_8py_source_l00429}{429}} of file \mbox{\hyperlink{box__list__ops_8py_source}{box\+\_\+list\+\_\+ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00430\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ use\_static\_shapes=\textcolor{keyword}{False},\ indicator\_sum=\textcolor{keywordtype}{None}):}
\DoxyCodeLine{00431\ \ \ \textcolor{stringliteral}{"{}"{}"{}Select\ boxes\ from\ BoxList\ according\ to\ indicator\ and\ return\ new\ BoxList.}}
\DoxyCodeLine{00432\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00433\ \textcolor{stringliteral}{\ \ \`{}boolean\_mask\`{}\ returns\ the\ subset\ of\ boxes\ that\ are\ marked\ }\textcolor{keyword}{as}\ \textcolor{stringliteral}{"{}True"{}}\ by\ the}
\DoxyCodeLine{00434\ \ \ indicator\ tensor.\ By\ default,\ \`{}boolean\_mask\`{}\ returns\ boxes\ corresponding\ to}
\DoxyCodeLine{00435\ \ \ the\ input\ index\ list,\ \textcolor{keyword}{as}\ well\ \textcolor{keyword}{as}\ all\ additional\ fields\ stored\ \textcolor{keywordflow}{in}\ the\ boxlist}
\DoxyCodeLine{00436\ \ \ (indexing\ into\ the\ first\ dimension).\ \ However\ one\ can\ optionally\ only\ draw}
\DoxyCodeLine{00437\ \ \ \textcolor{keyword}{from}\ a\ subset\ of\ fields.}
\DoxyCodeLine{00438\ }
\DoxyCodeLine{00439\ \ \ Args:}
\DoxyCodeLine{00440\ \ \ \ \ boxlist:\ BoxList\ holding\ N\ boxes}
\DoxyCodeLine{00441\ \ \ \ \ indicator:\ a\ rank-\/1\ boolean\ tensor}
\DoxyCodeLine{00442\ \ \ \ \ fields:\ (optional)\ list\ of\ fields\ to\ also\ gather\ \textcolor{keyword}{from}.\ \ If\ \textcolor{keywordtype}{None}\ (default),}
\DoxyCodeLine{00443\ \ \ \ \ \ \ all\ fields\ are\ gathered\ \textcolor{keyword}{from}.\ \ Pass\ an\ empty\ fields\ list\ to\ only\ gather}
\DoxyCodeLine{00444\ \ \ \ \ \ \ the\ box\ coordinates.}
\DoxyCodeLine{00445\ \ \ \ \ scope:\ name\ scope.}
\DoxyCodeLine{00446\ \ \ \ \ use\_static\_shapes:\ Whether\ to\ use\ an\ implementation\ \textcolor{keyword}{with}\ static\ shape}
\DoxyCodeLine{00447\ \ \ \ \ \ \ gurantees.}
\DoxyCodeLine{00448\ \ \ \ \ indicator\_sum:\ An\ integer\ containing\ the\ sum\ of\ \`{}indicator\`{}\ vector.\ Only}
\DoxyCodeLine{00449\ \ \ \ \ \ \ required\ \textcolor{keywordflow}{if}\ \`{}use\_static\_shape\`{}\ \textcolor{keywordflow}{is}\ \textcolor{keyword}{True}.}
\DoxyCodeLine{00450\ }
\DoxyCodeLine{00451\ \ \ Returns:}
\DoxyCodeLine{00452\ \ \ \ \ subboxlist:\ a\ BoxList\ corresponding\ to\ the\ subset\ of\ the\ input\ BoxList}
\DoxyCodeLine{00453\ \ \ \ \ \ \ specified\ by\ indicator}
\DoxyCodeLine{00454\ \ \ Raises:}
\DoxyCodeLine{00455\ \ \ \ \ ValueError:\ \textcolor{keywordflow}{if}\ \`{}indicator\`{}\ \textcolor{keywordflow}{is}\ \textcolor{keywordflow}{not}\ a\ rank-\/1\ boolean\ tensor.}
\DoxyCodeLine{00456\ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{00457\ \textcolor{stringliteral}{\ \ }\textcolor{keyword}{with}\ tf.name\_scope(scope,\ \textcolor{stringliteral}{'BooleanMask'}):}
\DoxyCodeLine{00458\ \ \ \ \ \textcolor{keywordflow}{if}\ indicator.shape.ndims\ !=\ 1:}
\DoxyCodeLine{00459\ \ \ \ \ \ \ \textcolor{keywordflow}{raise}\ ValueError(\textcolor{stringliteral}{'indicator\ should\ have\ rank\ 1'})}
\DoxyCodeLine{00460\ \ \ \ \ \textcolor{keywordflow}{if}\ indicator.dtype\ !=\ tf.bool:}
\DoxyCodeLine{00461\ \ \ \ \ \ \ \textcolor{keywordflow}{raise}\ ValueError(\textcolor{stringliteral}{'indicator\ should\ be\ a\ boolean\ tensor'})}
\DoxyCodeLine{00462\ \ \ \ \ \textcolor{keywordflow}{if}\ use\_static\_shapes:}
\DoxyCodeLine{00463\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ \textcolor{keywordflow}{not}\ (indicator\_sum\ \textcolor{keywordflow}{and}\ isinstance(indicator\_sum,\ int)):}
\DoxyCodeLine{00464\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{raise}\ ValueError(\textcolor{stringliteral}{'\`{}indicator\_sum`\ must\ be\ a\ of\ type\ int'})}
\DoxyCodeLine{00465\ \ \ \ \ \ \ selected\_positions\ =\ tf.cast(indicator,\ dtype=tf.float32)}
\DoxyCodeLine{00466\ \ \ \ \ \ \ indexed\_positions\ =\ tf.cast(}
\DoxyCodeLine{00467\ \ \ \ \ \ \ \ \ \ \ tf.multiply(}
\DoxyCodeLine{00468\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ tf.cumsum(selected\_positions),\ selected\_positions),}
\DoxyCodeLine{00469\ \ \ \ \ \ \ \ \ \ \ dtype=tf.int32)}
\DoxyCodeLine{00470\ \ \ \ \ \ \ one\_hot\_selector\ =\ tf.one\_hot(}
\DoxyCodeLine{00471\ \ \ \ \ \ \ \ \ \ \ indexed\_positions\ -\/\ 1,\ indicator\_sum,\ dtype=tf.float32)}
\DoxyCodeLine{00472\ \ \ \ \ \ \ sampled\_indices\ =\ tf.cast(}
\DoxyCodeLine{00473\ \ \ \ \ \ \ \ \ \ \ tf.tensordot(}
\DoxyCodeLine{00474\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ tf.cast(tf.range(tf.shape(indicator)[0]),\ dtype=tf.float32),}
\DoxyCodeLine{00475\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ one\_hot\_selector,}
\DoxyCodeLine{00476\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ axes=[0,\ 0]),}
\DoxyCodeLine{00477\ \ \ \ \ \ \ \ \ \ \ dtype=tf.int32)}
\DoxyCodeLine{00478\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ gather(boxlist,\ sampled\_indices,\ use\_static\_shapes=\textcolor{keyword}{True})}
\DoxyCodeLine{00479\ \ \ \ \ \textcolor{keywordflow}{else}:}
\DoxyCodeLine{00480\ \ \ \ \ \ \ subboxlist\ =\ box\_list.BoxList(tf.boolean\_mask(boxlist.get(),\ indicator))}
\DoxyCodeLine{00481\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ fields\ \textcolor{keywordflow}{is}\ \textcolor{keywordtype}{None}:}
\DoxyCodeLine{00482\ \ \ \ \ \ \ \ \ fields\ =\ boxlist.get\_extra\_fields()}
\DoxyCodeLine{00483\ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ field\ \textcolor{keywordflow}{in}\ fields:}
\DoxyCodeLine{00484\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ \textcolor{keywordflow}{not}\ boxlist.has\_field(field):}
\DoxyCodeLine{00485\ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{raise}\ ValueError(\textcolor{stringliteral}{'boxlist\ must\ contain\ all\ specified\ fields'})}
\DoxyCodeLine{00486\ \ \ \ \ \ \ \ \ subfieldlist\ =\ tf.boolean\_mask(boxlist.get\_field(field),\ indicator)}
\DoxyCodeLine{00487\ \ \ \ \ \ \ \ \ subboxlist.add\_field(field,\ subfieldlist)}
\DoxyCodeLine{00488\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ subboxlist}
\DoxyCodeLine{00489\ }
\DoxyCodeLine{00490\ }

\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d9/da1/namespacedetection__utils_1_1core_1_1box__list__ops_ad52cd56fc9dc0a632dd326e489bd1399_cgraph}
\end{center}
\end{figure}
\Hypertarget{namespacedetection__utils_1_1core_1_1box__list__ops_a6d89634b5541a267c532cd81b4abaf64}\label{namespacedetection__utils_1_1core_1_1box__list__ops_a6d89634b5541a267c532cd81b4abaf64} 
\index{detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}!box\_voting@{box\_voting}}
\index{box\_voting@{box\_voting}!detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}}
\doxysubsubsection{\texorpdfstring{box\_voting()}{box\_voting()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+core.\+box\+\_\+list\+\_\+ops.\+box\+\_\+voting (\begin{DoxyParamCaption}\item[{}]{selected\+\_\+boxes,  }\item[{}]{pool\+\_\+boxes,  }\item[{}]{iou\+\_\+thresh = {\ttfamily 0.5} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Performs box voting as described in S. Gidaris and N. Komodakis, ICCV 2015.

Performs box voting as described in 'Object detection via a multi-region &
semantic segmentation-aware CNN model', Gidaris and Komodakis, ICCV 2015. For
each box 'B' in selected_boxes, we find the set 'S' of boxes in pool_boxes
with iou overlap >= iou_thresh. The location of B is set to the weighted
average location of boxes in S (scores are used for weighting). And the score
of B is set to the average score of boxes in S.

Args:
  selected_boxes: BoxList containing a subset of boxes in pool_boxes. These
    boxes are usually selected from pool_boxes using non max suppression.
  pool_boxes: BoxList containing a set of (possibly redundant) boxes.
  iou_thresh: (float scalar) iou threshold for matching boxes in
    selected_boxes and pool_boxes.

Returns:
  BoxList containing averaged locations and scores for each box in
  selected_boxes.

Raises:
  ValueError: if
    a) selected_boxes or pool_boxes is not a BoxList.
    b) if iou_thresh is not in [0, 1].
    c) pool_boxes does not have a scores field.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{box__list__ops_8py_source_l00933}{933}} of file \mbox{\hyperlink{box__list__ops_8py_source}{box\+\_\+list\+\_\+ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00933\ \textcolor{keyword}{def\ }box\_voting(selected\_boxes,\ pool\_boxes,\ iou\_thresh=0.5):}
\DoxyCodeLine{00934\ \ \ \textcolor{stringliteral}{"{}"{}"{}Performs\ box\ voting\ as\ described\ in\ S.\ Gidaris\ and\ N.\ Komodakis,\ ICCV\ 2015.}}
\DoxyCodeLine{00935\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00936\ \textcolor{stringliteral}{\ \ Performs\ box\ voting\ }\textcolor{keyword}{as}\ described\ \textcolor{keywordflow}{in}\ \textcolor{stringliteral}{'Object\ detection\ via\ a\ multi-\/region\ \&}}
\DoxyCodeLine{00937\ \textcolor{stringliteral}{\ \ semantic\ segmentation-\/aware\ CNN\ model',\ Gidaris\ and\ Komodakis,\ ICCV\ 2015.\ For}}
\DoxyCodeLine{00938\ \textcolor{stringliteral}{\ \ each\ box\ 'B'}\ \textcolor{keywordflow}{in}\ selected\_boxes,\ we\ find\ the\ set\ \textcolor{stringliteral}{'S'}\ of\ boxes\ \textcolor{keywordflow}{in}\ pool\_boxes}
\DoxyCodeLine{00939\ \ \ \textcolor{keyword}{with}\ iou\ overlap\ >=\ iou\_thresh.\ The\ location\ of\ B\ \textcolor{keywordflow}{is}\ set\ to\ the\ weighted}
\DoxyCodeLine{00940\ \ \ average\ location\ of\ boxes\ \textcolor{keywordflow}{in}\ S\ (scores\ are\ used\ \textcolor{keywordflow}{for}\ weighting).\ And\ the\ score}
\DoxyCodeLine{00941\ \ \ of\ B\ \textcolor{keywordflow}{is}\ set\ to\ the\ average\ score\ of\ boxes\ \textcolor{keywordflow}{in}\ S.}
\DoxyCodeLine{00942\ }
\DoxyCodeLine{00943\ \ \ Args:}
\DoxyCodeLine{00944\ \ \ \ \ selected\_boxes:\ BoxList\ containing\ a\ subset\ of\ boxes\ \textcolor{keywordflow}{in}\ pool\_boxes.\ These}
\DoxyCodeLine{00945\ \ \ \ \ \ \ boxes\ are\ usually\ selected\ \textcolor{keyword}{from}\ pool\_boxes\ using\ non\ max\ suppression.}
\DoxyCodeLine{00946\ \ \ \ \ pool\_boxes:\ BoxList\ containing\ a\ set\ of\ (possibly\ redundant)\ boxes.}
\DoxyCodeLine{00947\ \ \ \ \ iou\_thresh:\ (float\ scalar)\ iou\ threshold\ \textcolor{keywordflow}{for}\ matching\ boxes\ \textcolor{keywordflow}{in}}
\DoxyCodeLine{00948\ \ \ \ \ \ \ selected\_boxes\ \textcolor{keywordflow}{and}\ pool\_boxes.}
\DoxyCodeLine{00949\ }
\DoxyCodeLine{00950\ \ \ Returns:}
\DoxyCodeLine{00951\ \ \ \ \ BoxList\ containing\ averaged\ locations\ \textcolor{keywordflow}{and}\ scores\ \textcolor{keywordflow}{for}\ each\ box\ \textcolor{keywordflow}{in}}
\DoxyCodeLine{00952\ \ \ \ \ selected\_boxes.}
\DoxyCodeLine{00953\ }
\DoxyCodeLine{00954\ \ \ Raises:}
\DoxyCodeLine{00955\ \ \ \ \ ValueError:\ \textcolor{keywordflow}{if}}
\DoxyCodeLine{00956\ \ \ \ \ \ \ a)\ selected\_boxes\ \textcolor{keywordflow}{or}\ pool\_boxes\ \textcolor{keywordflow}{is}\ \textcolor{keywordflow}{not}\ a\ BoxList.}
\DoxyCodeLine{00957\ \ \ \ \ \ \ b)\ \textcolor{keywordflow}{if}\ iou\_thresh\ \textcolor{keywordflow}{is}\ \textcolor{keywordflow}{not}\ \textcolor{keywordflow}{in}\ [0,\ 1].}
\DoxyCodeLine{00958\ \ \ \ \ \ \ c)\ pool\_boxes\ does\ \textcolor{keywordflow}{not}\ have\ a\ scores\ field.}
\DoxyCodeLine{00959\ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{00960\ \textcolor{stringliteral}{\ \ }\textcolor{keywordflow}{if}\ \textcolor{keywordflow}{not}\ 0.0\ <=\ iou\_thresh\ <=\ 1.0:}
\DoxyCodeLine{00961\ \ \ \ \ \textcolor{keywordflow}{raise}\ ValueError(\textcolor{stringliteral}{'iou\_thresh\ must\ be\ between\ 0\ and\ 1'})}
\DoxyCodeLine{00962\ \ \ \textcolor{keywordflow}{if}\ \textcolor{keywordflow}{not}\ isinstance(selected\_boxes,\ box\_list.BoxList):}
\DoxyCodeLine{00963\ \ \ \ \ \textcolor{keywordflow}{raise}\ ValueError(\textcolor{stringliteral}{'selected\_boxes\ must\ be\ a\ BoxList'})}
\DoxyCodeLine{00964\ \ \ \textcolor{keywordflow}{if}\ \textcolor{keywordflow}{not}\ isinstance(pool\_boxes,\ box\_list.BoxList):}
\DoxyCodeLine{00965\ \ \ \ \ \textcolor{keywordflow}{raise}\ ValueError(\textcolor{stringliteral}{'pool\_boxes\ must\ be\ a\ BoxList'})}
\DoxyCodeLine{00966\ \ \ \textcolor{keywordflow}{if}\ \textcolor{keywordflow}{not}\ pool\_boxes.has\_field(\textcolor{stringliteral}{'scores'}):}
\DoxyCodeLine{00967\ \ \ \ \ \textcolor{keywordflow}{raise}\ ValueError(\textcolor{stringliteral}{'pool\_boxes\ must\ have\ a\ \(\backslash\)'scores\(\backslash\)'\ field'})}
\DoxyCodeLine{00968\ }
\DoxyCodeLine{00969\ \ \ iou\_\ =\ iou(selected\_boxes,\ pool\_boxes)}
\DoxyCodeLine{00970\ \ \ match\_indicator\ =\ tf.cast(tf.greater(iou\_,\ iou\_thresh),\ dtype=tf.float32)}
\DoxyCodeLine{00971\ \ \ num\_matches\ =\ tf.reduce\_sum(match\_indicator,\ 1)}
\DoxyCodeLine{00972\ \ \ \textcolor{comment}{\#\ TODO(kbanoop):\ Handle\ the\ case\ where\ some\ boxes\ in\ selected\_boxes\ do\ not}}
\DoxyCodeLine{00973\ \ \ \textcolor{comment}{\#\ match\ to\ any\ boxes\ in\ pool\_boxes.\ For\ such\ boxes\ without\ any\ matches,\ we}}
\DoxyCodeLine{00974\ \ \ \textcolor{comment}{\#\ should\ return\ the\ original\ boxes\ without\ voting.}}
\DoxyCodeLine{00975\ \ \ match\_assert\ =\ tf.Assert(}
\DoxyCodeLine{00976\ \ \ \ \ \ \ tf.reduce\_all(tf.greater(num\_matches,\ 0)),}
\DoxyCodeLine{00977\ \ \ \ \ \ \ [\textcolor{stringliteral}{'Each\ box\ in\ selected\_boxes\ must\ match\ with\ at\ least\ one\ box\ '}}
\DoxyCodeLine{00978\ \ \ \ \ \ \ \ \textcolor{stringliteral}{'in\ pool\_boxes.'}])}
\DoxyCodeLine{00979\ }
\DoxyCodeLine{00980\ \ \ scores\ =\ tf.expand\_dims(pool\_boxes.get\_field(\textcolor{stringliteral}{'scores'}),\ 1)}
\DoxyCodeLine{00981\ \ \ scores\_assert\ =\ tf.Assert(}
\DoxyCodeLine{00982\ \ \ \ \ \ \ tf.reduce\_all(tf.greater\_equal(scores,\ 0)),}
\DoxyCodeLine{00983\ \ \ \ \ \ \ [\textcolor{stringliteral}{'Scores\ must\ be\ non\ negative.'}])}
\DoxyCodeLine{00984\ }
\DoxyCodeLine{00985\ \ \ \textcolor{keyword}{with}\ tf.control\_dependencies([scores\_assert,\ match\_assert]):}
\DoxyCodeLine{00986\ \ \ \ \ sum\_scores\ =\ tf.matmul(match\_indicator,\ scores)}
\DoxyCodeLine{00987\ \ \ averaged\_scores\ =\ tf.reshape(sum\_scores,\ [-\/1])\ /\ num\_matches}
\DoxyCodeLine{00988\ }
\DoxyCodeLine{00989\ \ \ box\_locations\ =\ tf.matmul(match\_indicator,}
\DoxyCodeLine{00990\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ pool\_boxes.get()\ *\ scores)\ /\ sum\_scores}
\DoxyCodeLine{00991\ \ \ averaged\_boxes\ =\ box\_list.BoxList(box\_locations)}
\DoxyCodeLine{00992\ \ \ \_copy\_extra\_fields(averaged\_boxes,\ selected\_boxes)}
\DoxyCodeLine{00993\ \ \ averaged\_boxes.add\_field(\textcolor{stringliteral}{'scores'},\ averaged\_scores)}
\DoxyCodeLine{00994\ \ \ \textcolor{keywordflow}{return}\ averaged\_boxes}
\DoxyCodeLine{00995\ }
\DoxyCodeLine{00996\ }

\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d9/da1/namespacedetection__utils_1_1core_1_1box__list__ops_a6d89634b5541a267c532cd81b4abaf64_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d9/da1/namespacedetection__utils_1_1core_1_1box__list__ops_a6d89634b5541a267c532cd81b4abaf64_icgraph}
\end{center}
\end{figure}
\Hypertarget{namespacedetection__utils_1_1core_1_1box__list__ops_a725390a73d7d904bf824344014ed055c}\label{namespacedetection__utils_1_1core_1_1box__list__ops_a725390a73d7d904bf824344014ed055c} 
\index{detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}!change\_coordinate\_frame@{change\_coordinate\_frame}}
\index{change\_coordinate\_frame@{change\_coordinate\_frame}!detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}}
\doxysubsubsection{\texorpdfstring{change\_coordinate\_frame()}{change\_coordinate\_frame()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+core.\+box\+\_\+list\+\_\+ops.\+change\+\_\+coordinate\+\_\+frame (\begin{DoxyParamCaption}\item[{}]{boxlist,  }\item[{}]{window,  }\item[{}]{scope = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Change coordinate frame of the boxlist to be relative to window's frame.

Given a window of the form [ymin, xmin, ymax, xmax],
changes bounding box coordinates from boxlist to be relative to this window
(e.g., the min corner maps to (0,0) and the max corner maps to (1,1)).

An example use case is data augmentation: where we are given groundtruth
boxes (boxlist) and would like to randomly crop the image to some
window (window). In this case we need to change the coordinate frame of
each groundtruth box to be relative to this new window.

Args:
  boxlist: A BoxList object holding N boxes.
  window: A rank 1 tensor [4].
  scope: name scope.

Returns:
  Returns a BoxList object with N boxes.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{box__list__ops_8py_source_l00370}{370}} of file \mbox{\hyperlink{box__list__ops_8py_source}{box\+\_\+list\+\_\+ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00370\ \textcolor{keyword}{def\ }change\_coordinate\_frame(boxlist,\ window,\ scope=None):}
\DoxyCodeLine{00371\ \ \ \textcolor{stringliteral}{"{}"{}"{}Change\ coordinate\ frame\ of\ the\ boxlist\ to\ be\ relative\ to\ window's\ frame.}}
\DoxyCodeLine{00372\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00373\ \textcolor{stringliteral}{\ \ Given\ a\ window\ of\ the\ form\ [ymin,\ xmin,\ ymax,\ xmax],}}
\DoxyCodeLine{00374\ \textcolor{stringliteral}{\ \ changes\ bounding\ box\ coordinates\ }\textcolor{keyword}{from}\ boxlist\ to\ be\ relative\ to\ this\ window}
\DoxyCodeLine{00375\ \ \ (e.g.,\ the\ min\ corner\ maps\ to\ (0,0)\ \textcolor{keywordflow}{and}\ the\ max\ corner\ maps\ to\ (1,1)).}
\DoxyCodeLine{00376\ }
\DoxyCodeLine{00377\ \ \ An\ example\ use\ case\ \textcolor{keywordflow}{is}\ data\ augmentation:\ where\ we\ are\ given\ groundtruth}
\DoxyCodeLine{00378\ \ \ boxes\ (boxlist)\ \textcolor{keywordflow}{and}\ would\ like\ to\ randomly\ crop\ the\ image\ to\ some}
\DoxyCodeLine{00379\ \ \ window\ (window).\ In\ this\ case\ we\ need\ to\ change\ the\ coordinate\ frame\ of}
\DoxyCodeLine{00380\ \ \ each\ groundtruth\ box\ to\ be\ relative\ to\ this\ new\ window.}
\DoxyCodeLine{00381\ }
\DoxyCodeLine{00382\ \ \ Args:}
\DoxyCodeLine{00383\ \ \ \ \ boxlist:\ A\ BoxList\ object\ holding\ N\ boxes.}
\DoxyCodeLine{00384\ \ \ \ \ window:\ A\ rank\ 1\ tensor\ [4].}
\DoxyCodeLine{00385\ \ \ \ \ scope:\ name\ scope.}
\DoxyCodeLine{00386\ }
\DoxyCodeLine{00387\ \ \ Returns:}
\DoxyCodeLine{00388\ \ \ \ \ Returns\ a\ BoxList\ object\ \textcolor{keyword}{with}\ N\ boxes.}
\DoxyCodeLine{00389\ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{00390\ \textcolor{stringliteral}{\ \ }\textcolor{keyword}{with}\ tf.name\_scope(scope,\ \textcolor{stringliteral}{'ChangeCoordinateFrame'}):}
\DoxyCodeLine{00391\ \ \ \ \ win\_height\ =\ window[2]\ -\/\ window[0]}
\DoxyCodeLine{00392\ \ \ \ \ win\_width\ =\ window[3]\ -\/\ window[1]}
\DoxyCodeLine{00393\ \ \ \ \ boxlist\_new\ =\ scale(box\_list.BoxList(}
\DoxyCodeLine{00394\ \ \ \ \ \ \ \ \ boxlist.get()\ -\/\ [window[0],\ window[1],\ window[0],\ window[1]]),}
\DoxyCodeLine{00395\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 1.0\ /\ win\_height,\ 1.0\ /\ win\_width)}
\DoxyCodeLine{00396\ \ \ \ \ boxlist\_new\ =\ \_copy\_extra\_fields(boxlist\_new,\ boxlist)}
\DoxyCodeLine{00397\ \ \ \ \ \textcolor{keywordflow}{return}\ boxlist\_new}
\DoxyCodeLine{00398\ }
\DoxyCodeLine{00399\ }

\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d9/da1/namespacedetection__utils_1_1core_1_1box__list__ops_a725390a73d7d904bf824344014ed055c_cgraph}
\end{center}
\end{figure}
\Hypertarget{namespacedetection__utils_1_1core_1_1box__list__ops_a0c75cbd62f25f099ee47c6f50a22c12d}\label{namespacedetection__utils_1_1core_1_1box__list__ops_a0c75cbd62f25f099ee47c6f50a22c12d} 
\index{detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}!clip\_to\_window@{clip\_to\_window}}
\index{clip\_to\_window@{clip\_to\_window}!detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}}
\doxysubsubsection{\texorpdfstring{clip\_to\_window()}{clip\_to\_window()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+core.\+box\+\_\+list\+\_\+ops.\+clip\+\_\+to\+\_\+window (\begin{DoxyParamCaption}\item[{}]{boxlist,  }\item[{}]{window,  }\item[{}]{filter\+\_\+nonoverlapping = {\ttfamily True},  }\item[{}]{scope = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Clip bounding boxes to a window.

This op clips any input bounding boxes (represented by bounding box
corners) to a window, optionally filtering out boxes that do not
overlap at all with the window.

Args:
  boxlist: BoxList holding M_in boxes
  window: a tensor of shape [4] representing the [y_min, x_min, y_max, x_max]
    window to which the op should clip boxes.
  filter_nonoverlapping: whether to filter out boxes that do not overlap at
    all with the window.
  scope: name scope.

Returns:
  a BoxList holding M_out boxes where M_out <= M_in
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{box__list__ops_8py_source_l00108}{108}} of file \mbox{\hyperlink{box__list__ops_8py_source}{box\+\_\+list\+\_\+ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00108\ \textcolor{keyword}{def\ }clip\_to\_window(boxlist,\ window,\ filter\_nonoverlapping=True,\ scope=None):}
\DoxyCodeLine{00109\ \ \ \textcolor{stringliteral}{"{}"{}"{}Clip\ bounding\ boxes\ to\ a\ window.}}
\DoxyCodeLine{00110\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00111\ \textcolor{stringliteral}{\ \ This\ op\ clips\ any\ input\ bounding\ boxes\ (represented\ by\ bounding\ box}}
\DoxyCodeLine{00112\ \textcolor{stringliteral}{\ \ corners)\ to\ a\ window,\ optionally\ filtering\ out\ boxes\ that\ do\ }\textcolor{keywordflow}{not}}
\DoxyCodeLine{00113\ \ \ overlap\ at\ all\ \textcolor{keyword}{with}\ the\ window.}
\DoxyCodeLine{00114\ }
\DoxyCodeLine{00115\ \ \ Args:}
\DoxyCodeLine{00116\ \ \ \ \ boxlist:\ BoxList\ holding\ M\_in\ boxes}
\DoxyCodeLine{00117\ \ \ \ \ window:\ a\ tensor\ of\ shape\ [4]\ representing\ the\ [y\_min,\ x\_min,\ y\_max,\ x\_max]}
\DoxyCodeLine{00118\ \ \ \ \ \ \ window\ to\ which\ the\ op\ should\ clip\ boxes.}
\DoxyCodeLine{00119\ \ \ \ \ filter\_nonoverlapping:\ whether\ to\ filter\ out\ boxes\ that\ do\ \textcolor{keywordflow}{not}\ overlap\ at}
\DoxyCodeLine{00120\ \ \ \ \ \ \ all\ \textcolor{keyword}{with}\ the\ window.}
\DoxyCodeLine{00121\ \ \ \ \ scope:\ name\ scope.}
\DoxyCodeLine{00122\ }
\DoxyCodeLine{00123\ \ \ Returns:}
\DoxyCodeLine{00124\ \ \ \ \ a\ BoxList\ holding\ M\_out\ boxes\ where\ M\_out\ <=\ M\_in}
\DoxyCodeLine{00125\ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{00126\ \textcolor{stringliteral}{\ \ }\textcolor{keyword}{with}\ tf.name\_scope(scope,\ \textcolor{stringliteral}{'ClipToWindow'}):}
\DoxyCodeLine{00127\ \ \ \ \ y\_min,\ x\_min,\ y\_max,\ x\_max\ =\ tf.split(}
\DoxyCodeLine{00128\ \ \ \ \ \ \ \ \ value=boxlist.get(),\ num\_or\_size\_splits=4,\ axis=1)}
\DoxyCodeLine{00129\ \ \ \ \ win\_y\_min,\ win\_x\_min,\ win\_y\_max,\ win\_x\_max\ =\ tf.unstack(window)}
\DoxyCodeLine{00130\ \ \ \ \ y\_min\_clipped\ =\ tf.maximum(tf.minimum(y\_min,\ win\_y\_max),\ win\_y\_min)}
\DoxyCodeLine{00131\ \ \ \ \ y\_max\_clipped\ =\ tf.maximum(tf.minimum(y\_max,\ win\_y\_max),\ win\_y\_min)}
\DoxyCodeLine{00132\ \ \ \ \ x\_min\_clipped\ =\ tf.maximum(tf.minimum(x\_min,\ win\_x\_max),\ win\_x\_min)}
\DoxyCodeLine{00133\ \ \ \ \ x\_max\_clipped\ =\ tf.maximum(tf.minimum(x\_max,\ win\_x\_max),\ win\_x\_min)}
\DoxyCodeLine{00134\ \ \ \ \ clipped\ =\ box\_list.BoxList(}
\DoxyCodeLine{00135\ \ \ \ \ \ \ \ \ tf.concat([y\_min\_clipped,\ x\_min\_clipped,\ y\_max\_clipped,\ x\_max\_clipped],}
\DoxyCodeLine{00136\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 1))}
\DoxyCodeLine{00137\ \ \ \ \ clipped\ =\ \_copy\_extra\_fields(clipped,\ boxlist)}
\DoxyCodeLine{00138\ \ \ \ \ \textcolor{keywordflow}{if}\ filter\_nonoverlapping:}
\DoxyCodeLine{00139\ \ \ \ \ \ \ areas\ =\ area(clipped)}
\DoxyCodeLine{00140\ \ \ \ \ \ \ nonzero\_area\_indices\ =\ tf.cast(}
\DoxyCodeLine{00141\ \ \ \ \ \ \ \ \ \ \ tf.reshape(tf.where(tf.greater(areas,\ 0.0)),\ [-\/1]),\ tf.int32)}
\DoxyCodeLine{00142\ \ \ \ \ \ \ clipped\ =\ gather(clipped,\ nonzero\_area\_indices)}
\DoxyCodeLine{00143\ \ \ \ \ \textcolor{keywordflow}{return}\ clipped}
\DoxyCodeLine{00144\ }
\DoxyCodeLine{00145\ }

\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d9/da1/namespacedetection__utils_1_1core_1_1box__list__ops_a0c75cbd62f25f099ee47c6f50a22c12d_cgraph}
\end{center}
\end{figure}
\Hypertarget{namespacedetection__utils_1_1core_1_1box__list__ops_a7bdc06a00ef29d99daeab567329d7421}\label{namespacedetection__utils_1_1core_1_1box__list__ops_a7bdc06a00ef29d99daeab567329d7421} 
\index{detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}!concatenate@{concatenate}}
\index{concatenate@{concatenate}!detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}}
\doxysubsubsection{\texorpdfstring{concatenate()}{concatenate()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+core.\+box\+\_\+list\+\_\+ops.\+concatenate (\begin{DoxyParamCaption}\item[{}]{boxlists,  }\item[{}]{fields = {\ttfamily None},  }\item[{}]{scope = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Concatenate list of BoxLists.

This op concatenates a list of input BoxLists into a larger BoxList.  It also
handles concatenation of BoxList fields as long as the field tensor shapes
are equal except for the first dimension.

Args:
  boxlists: list of BoxList objects
  fields: optional list of fields to also concatenate.  By default, all
    fields from the first BoxList in the list are included in the
    concatenation.
  scope: name scope.

Returns:
  a BoxList with number of boxes equal to
    sum([boxlist.num_boxes() for boxlist in BoxList])
Raises:
  ValueError: if boxlists is invalid (i.e., is not a list, is empty, or
    contains non BoxList objects), or if requested fields are not contained in
    all boxlists
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{box__list__ops_8py_source_l00536}{536}} of file \mbox{\hyperlink{box__list__ops_8py_source}{box\+\_\+list\+\_\+ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00536\ \textcolor{keyword}{def\ }concatenate(boxlists,\ fields=None,\ scope=None):}
\DoxyCodeLine{00537\ \ \ \textcolor{stringliteral}{"{}"{}"{}Concatenate\ list\ of\ BoxLists.}}
\DoxyCodeLine{00538\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00539\ \textcolor{stringliteral}{\ \ This\ op\ concatenates\ a\ list\ of\ input\ BoxLists\ into\ a\ larger\ BoxList.\ \ It\ also}}
\DoxyCodeLine{00540\ \textcolor{stringliteral}{\ \ handles\ concatenation\ of\ BoxList\ fields\ }\textcolor{keyword}{as}\ long\ \textcolor{keyword}{as}\ the\ field\ tensor\ shapes}
\DoxyCodeLine{00541\ \ \ are\ equal\ \textcolor{keywordflow}{except}\ \textcolor{keywordflow}{for}\ the\ first\ dimension.}
\DoxyCodeLine{00542\ }
\DoxyCodeLine{00543\ \ \ Args:}
\DoxyCodeLine{00544\ \ \ \ \ boxlists:\ list\ of\ BoxList\ objects}
\DoxyCodeLine{00545\ \ \ \ \ fields:\ optional\ list\ of\ fields\ to\ also\ concatenate.\ \ By\ default,\ all}
\DoxyCodeLine{00546\ \ \ \ \ \ \ fields\ \textcolor{keyword}{from}\ the\ first\ BoxList\ \textcolor{keywordflow}{in}\ the\ list\ are\ included\ \textcolor{keywordflow}{in}\ the}
\DoxyCodeLine{00547\ \ \ \ \ \ \ concatenation.}
\DoxyCodeLine{00548\ \ \ \ \ scope:\ name\ scope.}
\DoxyCodeLine{00549\ }
\DoxyCodeLine{00550\ \ \ Returns:}
\DoxyCodeLine{00551\ \ \ \ \ a\ BoxList\ \textcolor{keyword}{with}\ number\ of\ boxes\ equal\ to}
\DoxyCodeLine{00552\ \ \ \ \ \ \ sum([boxlist.num\_boxes()\ \textcolor{keywordflow}{for}\ boxlist\ \textcolor{keywordflow}{in}\ BoxList])}
\DoxyCodeLine{00553\ \ \ Raises:}
\DoxyCodeLine{00554\ \ \ \ \ ValueError:\ \textcolor{keywordflow}{if}\ boxlists\ \textcolor{keywordflow}{is}\ invalid\ (i.e.,\ \textcolor{keywordflow}{is}\ \textcolor{keywordflow}{not}\ a\ list,\ \textcolor{keywordflow}{is}\ empty,\ \textcolor{keywordflow}{or}}
\DoxyCodeLine{00555\ \ \ \ \ \ \ contains\ non\ BoxList\ objects),\ \textcolor{keywordflow}{or}\ \textcolor{keywordflow}{if}\ requested\ fields\ are\ \textcolor{keywordflow}{not}\ contained\ \textcolor{keywordflow}{in}}
\DoxyCodeLine{00556\ \ \ \ \ \ \ all\ boxlists}
\DoxyCodeLine{00557\ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{00558\ \textcolor{stringliteral}{\ \ }\textcolor{keyword}{with}\ tf.name\_scope(scope,\ \textcolor{stringliteral}{'Concatenate'}):}
\DoxyCodeLine{00559\ \ \ \ \ \textcolor{keywordflow}{if}\ \textcolor{keywordflow}{not}\ isinstance(boxlists,\ list):}
\DoxyCodeLine{00560\ \ \ \ \ \ \ \textcolor{keywordflow}{raise}\ ValueError(\textcolor{stringliteral}{'boxlists\ should\ be\ a\ list'})}
\DoxyCodeLine{00561\ \ \ \ \ \textcolor{keywordflow}{if}\ \textcolor{keywordflow}{not}\ boxlists:}
\DoxyCodeLine{00562\ \ \ \ \ \ \ \textcolor{keywordflow}{raise}\ ValueError(\textcolor{stringliteral}{'boxlists\ should\ have\ nonzero\ length'})}
\DoxyCodeLine{00563\ \ \ \ \ \textcolor{keywordflow}{for}\ boxlist\ \textcolor{keywordflow}{in}\ boxlists:}
\DoxyCodeLine{00564\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ \textcolor{keywordflow}{not}\ isinstance(boxlist,\ box\_list.BoxList):}
\DoxyCodeLine{00565\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{raise}\ ValueError(\textcolor{stringliteral}{'all\ elements\ of\ boxlists\ should\ be\ BoxList\ objects'})}
\DoxyCodeLine{00566\ \ \ \ \ concatenated\ =\ box\_list.BoxList(}
\DoxyCodeLine{00567\ \ \ \ \ \ \ \ \ tf.concat([boxlist.get()\ \textcolor{keywordflow}{for}\ boxlist\ \textcolor{keywordflow}{in}\ boxlists],\ 0))}
\DoxyCodeLine{00568\ \ \ \ \ \textcolor{keywordflow}{if}\ fields\ \textcolor{keywordflow}{is}\ \textcolor{keywordtype}{None}:}
\DoxyCodeLine{00569\ \ \ \ \ \ \ fields\ =\ boxlists[0].get\_extra\_fields()}
\DoxyCodeLine{00570\ \ \ \ \ \textcolor{keywordflow}{for}\ field\ \textcolor{keywordflow}{in}\ fields:}
\DoxyCodeLine{00571\ \ \ \ \ \ \ first\_field\_shape\ =\ boxlists[0].get\_field(field).get\_shape().as\_list()}
\DoxyCodeLine{00572\ \ \ \ \ \ \ first\_field\_shape[0]\ =\ -\/1}
\DoxyCodeLine{00573\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ \textcolor{keywordtype}{None}\ \textcolor{keywordflow}{in}\ first\_field\_shape:}
\DoxyCodeLine{00574\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{raise}\ ValueError(\textcolor{stringliteral}{'field\ \%s\ must\ have\ fully\ defined\ shape\ except\ for\ the'}}
\DoxyCodeLine{00575\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'\ 0th\ dimension.'}\ \%\ field)}
\DoxyCodeLine{00576\ \ \ \ \ \ \ \textcolor{keywordflow}{for}\ boxlist\ \textcolor{keywordflow}{in}\ boxlists:}
\DoxyCodeLine{00577\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ \textcolor{keywordflow}{not}\ boxlist.has\_field(field):}
\DoxyCodeLine{00578\ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{raise}\ ValueError(\textcolor{stringliteral}{'boxlist\ must\ contain\ all\ requested\ fields'})}
\DoxyCodeLine{00579\ \ \ \ \ \ \ \ \ field\_shape\ =\ boxlist.get\_field(field).get\_shape().as\_list()}
\DoxyCodeLine{00580\ \ \ \ \ \ \ \ \ field\_shape[0]\ =\ -\/1}
\DoxyCodeLine{00581\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ field\_shape\ !=\ first\_field\_shape:}
\DoxyCodeLine{00582\ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{raise}\ ValueError(\textcolor{stringliteral}{'field\ \%s\ must\ have\ same\ shape\ for\ all\ boxlists\ '}}
\DoxyCodeLine{00583\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'except\ for\ the\ 0th\ dimension.'}\ \%\ field)}
\DoxyCodeLine{00584\ \ \ \ \ \ \ concatenated\_field\ =\ tf.concat(}
\DoxyCodeLine{00585\ \ \ \ \ \ \ \ \ \ \ [boxlist.get\_field(field)\ \textcolor{keywordflow}{for}\ boxlist\ \textcolor{keywordflow}{in}\ boxlists],\ 0)}
\DoxyCodeLine{00586\ \ \ \ \ \ \ concatenated.add\_field(field,\ concatenated\_field)}
\DoxyCodeLine{00587\ \ \ \ \ \textcolor{keywordflow}{return}\ concatenated}
\DoxyCodeLine{00588\ }
\DoxyCodeLine{00589\ }

\end{DoxyCode}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d9/da1/namespacedetection__utils_1_1core_1_1box__list__ops_a7bdc06a00ef29d99daeab567329d7421_icgraph}
\end{center}
\end{figure}
\Hypertarget{namespacedetection__utils_1_1core_1_1box__list__ops_a704393f594559cb69a017b29adfb0eab}\label{namespacedetection__utils_1_1core_1_1box__list__ops_a704393f594559cb69a017b29adfb0eab} 
\index{detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}!filter\_field\_value\_equals@{filter\_field\_value\_equals}}
\index{filter\_field\_value\_equals@{filter\_field\_value\_equals}!detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}}
\doxysubsubsection{\texorpdfstring{filter\_field\_value\_equals()}{filter\_field\_value\_equals()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+core.\+box\+\_\+list\+\_\+ops.\+filter\+\_\+field\+\_\+value\+\_\+equals (\begin{DoxyParamCaption}\item[{}]{boxlist,  }\item[{}]{field,  }\item[{}]{value,  }\item[{}]{scope = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Filter to keep only boxes with field entries equal to the given value.

Args:
  boxlist: BoxList holding N boxes.
  field: field name for filtering.
  value: scalar value.
  scope: name scope.

Returns:
  a BoxList holding M boxes where M <= N

Raises:
  ValueError: if boxlist not a BoxList object or if it does not have
    the specified field.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{box__list__ops_8py_source_l00660}{660}} of file \mbox{\hyperlink{box__list__ops_8py_source}{box\+\_\+list\+\_\+ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00660\ \textcolor{keyword}{def\ }filter\_field\_value\_equals(boxlist,\ field,\ value,\ scope=None):}
\DoxyCodeLine{00661\ \ \ \textcolor{stringliteral}{"{}"{}"{}Filter\ to\ keep\ only\ boxes\ with\ field\ entries\ equal\ to\ the\ given\ value.}}
\DoxyCodeLine{00662\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00663\ \textcolor{stringliteral}{\ \ Args:}}
\DoxyCodeLine{00664\ \textcolor{stringliteral}{\ \ \ \ boxlist:\ BoxList\ holding\ N\ boxes.}}
\DoxyCodeLine{00665\ \textcolor{stringliteral}{\ \ \ \ field:\ field\ name\ }\textcolor{keywordflow}{for}\ filtering.}
\DoxyCodeLine{00666\ \ \ \ \ value:\ scalar\ value.}
\DoxyCodeLine{00667\ \ \ \ \ scope:\ name\ scope.}
\DoxyCodeLine{00668\ }
\DoxyCodeLine{00669\ \ \ Returns:}
\DoxyCodeLine{00670\ \ \ \ \ a\ BoxList\ holding\ M\ boxes\ where\ M\ <=\ N}
\DoxyCodeLine{00671\ }
\DoxyCodeLine{00672\ \ \ Raises:}
\DoxyCodeLine{00673\ \ \ \ \ ValueError:\ \textcolor{keywordflow}{if}\ boxlist\ \textcolor{keywordflow}{not}\ a\ BoxList\ object\ \textcolor{keywordflow}{or}\ \textcolor{keywordflow}{if}\ it\ does\ \textcolor{keywordflow}{not}\ have}
\DoxyCodeLine{00674\ \ \ \ \ \ \ the\ specified\ field.}
\DoxyCodeLine{00675\ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{00676\ \textcolor{stringliteral}{\ \ }\textcolor{keyword}{with}\ tf.name\_scope(scope,\ \textcolor{stringliteral}{'FilterFieldValueEquals'}):}
\DoxyCodeLine{00677\ \ \ \ \ \textcolor{keywordflow}{if}\ \textcolor{keywordflow}{not}\ isinstance(boxlist,\ box\_list.BoxList):}
\DoxyCodeLine{00678\ \ \ \ \ \ \ \textcolor{keywordflow}{raise}\ ValueError(\textcolor{stringliteral}{'boxlist\ must\ be\ a\ BoxList'})}
\DoxyCodeLine{00679\ \ \ \ \ \textcolor{keywordflow}{if}\ \textcolor{keywordflow}{not}\ boxlist.has\_field(field):}
\DoxyCodeLine{00680\ \ \ \ \ \ \ \textcolor{keywordflow}{raise}\ ValueError(\textcolor{stringliteral}{'boxlist\ must\ contain\ the\ specified\ field'})}
\DoxyCodeLine{00681\ \ \ \ \ filter\_field\ =\ boxlist.get\_field(field)}
\DoxyCodeLine{00682\ \ \ \ \ gather\_index\ =\ tf.reshape(tf.where(tf.equal(filter\_field,\ value)),\ [-\/1])}
\DoxyCodeLine{00683\ \ \ \ \ \textcolor{keywordflow}{return}\ gather(boxlist,\ gather\_index)}
\DoxyCodeLine{00684\ }
\DoxyCodeLine{00685\ }

\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d9/da1/namespacedetection__utils_1_1core_1_1box__list__ops_a704393f594559cb69a017b29adfb0eab_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d9/da1/namespacedetection__utils_1_1core_1_1box__list__ops_a704393f594559cb69a017b29adfb0eab_icgraph}
\end{center}
\end{figure}
\Hypertarget{namespacedetection__utils_1_1core_1_1box__list__ops_af19b9892d46f5558103b58fb131dc5c5}\label{namespacedetection__utils_1_1core_1_1box__list__ops_af19b9892d46f5558103b58fb131dc5c5} 
\index{detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}!filter\_greater\_than@{filter\_greater\_than}}
\index{filter\_greater\_than@{filter\_greater\_than}!detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}}
\doxysubsubsection{\texorpdfstring{filter\_greater\_than()}{filter\_greater\_than()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+core.\+box\+\_\+list\+\_\+ops.\+filter\+\_\+greater\+\_\+than (\begin{DoxyParamCaption}\item[{}]{boxlist,  }\item[{}]{thresh,  }\item[{}]{scope = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Filter to keep only boxes with score exceeding a given threshold.

This op keeps the collection of boxes whose corresponding scores are
greater than the input threshold.

TODO(jonathanhuang): Change function name to filter_scores_greater_than

Args:
  boxlist: BoxList holding N boxes.  Must contain a 'scores' field
    representing detection scores.
  thresh: scalar threshold
  scope: name scope.

Returns:
  a BoxList holding M boxes where M <= N

Raises:
  ValueError: if boxlist not a BoxList object or if it does not
    have a scores field
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{box__list__ops_8py_source_l00686}{686}} of file \mbox{\hyperlink{box__list__ops_8py_source}{box\+\_\+list\+\_\+ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00686\ \textcolor{keyword}{def\ }filter\_greater\_than(boxlist,\ thresh,\ scope=None):}
\DoxyCodeLine{00687\ \ \ \textcolor{stringliteral}{"{}"{}"{}Filter\ to\ keep\ only\ boxes\ with\ score\ exceeding\ a\ given\ threshold.}}
\DoxyCodeLine{00688\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00689\ \textcolor{stringliteral}{\ \ This\ op\ keeps\ the\ collection\ of\ boxes\ whose\ corresponding\ scores\ are}}
\DoxyCodeLine{00690\ \textcolor{stringliteral}{\ \ greater\ than\ the\ input\ threshold.}}
\DoxyCodeLine{00691\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00692\ \textcolor{stringliteral}{\ \ TODO(jonathanhuang):\ Change\ function\ name\ to\ filter\_scores\_greater\_than}}
\DoxyCodeLine{00693\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00694\ \textcolor{stringliteral}{\ \ Args:}}
\DoxyCodeLine{00695\ \textcolor{stringliteral}{\ \ \ \ boxlist:\ BoxList\ holding\ N\ boxes.\ \ Must\ contain\ a\ 'scores'}\ field}
\DoxyCodeLine{00696\ \ \ \ \ \ \ representing\ detection\ scores.}
\DoxyCodeLine{00697\ \ \ \ \ thresh:\ scalar\ threshold}
\DoxyCodeLine{00698\ \ \ \ \ scope:\ name\ scope.}
\DoxyCodeLine{00699\ }
\DoxyCodeLine{00700\ \ \ Returns:}
\DoxyCodeLine{00701\ \ \ \ \ a\ BoxList\ holding\ M\ boxes\ where\ M\ <=\ N}
\DoxyCodeLine{00702\ }
\DoxyCodeLine{00703\ \ \ Raises:}
\DoxyCodeLine{00704\ \ \ \ \ ValueError:\ \textcolor{keywordflow}{if}\ boxlist\ \textcolor{keywordflow}{not}\ a\ BoxList\ object\ \textcolor{keywordflow}{or}\ \textcolor{keywordflow}{if}\ it\ does\ \textcolor{keywordflow}{not}}
\DoxyCodeLine{00705\ \ \ \ \ \ \ have\ a\ scores\ field}
\DoxyCodeLine{00706\ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{00707\ \textcolor{stringliteral}{\ \ }\textcolor{keyword}{with}\ tf.name\_scope(scope,\ \textcolor{stringliteral}{'FilterGreaterThan'}):}
\DoxyCodeLine{00708\ \ \ \ \ \textcolor{keywordflow}{if}\ \textcolor{keywordflow}{not}\ isinstance(boxlist,\ box\_list.BoxList):}
\DoxyCodeLine{00709\ \ \ \ \ \ \ \textcolor{keywordflow}{raise}\ ValueError(\textcolor{stringliteral}{'boxlist\ must\ be\ a\ BoxList'})}
\DoxyCodeLine{00710\ \ \ \ \ \textcolor{keywordflow}{if}\ \textcolor{keywordflow}{not}\ boxlist.has\_field(\textcolor{stringliteral}{'scores'}):}
\DoxyCodeLine{00711\ \ \ \ \ \ \ \textcolor{keywordflow}{raise}\ ValueError(\textcolor{stringliteral}{'input\ boxlist\ must\ have\ \(\backslash\)'scores\(\backslash\)'\ field'})}
\DoxyCodeLine{00712\ \ \ \ \ scores\ =\ boxlist.get\_field(\textcolor{stringliteral}{'scores'})}
\DoxyCodeLine{00713\ \ \ \ \ \textcolor{keywordflow}{if}\ len(scores.shape.as\_list())\ >\ 2:}
\DoxyCodeLine{00714\ \ \ \ \ \ \ \textcolor{keywordflow}{raise}\ ValueError(\textcolor{stringliteral}{'Scores\ should\ have\ rank\ 1\ or\ 2'})}
\DoxyCodeLine{00715\ \ \ \ \ \textcolor{keywordflow}{if}\ len(scores.shape.as\_list())\ ==\ 2\ \textcolor{keywordflow}{and}\ scores.shape.as\_list()[1]\ !=\ 1:}
\DoxyCodeLine{00716\ \ \ \ \ \ \ \textcolor{keywordflow}{raise}\ ValueError(\textcolor{stringliteral}{'Scores\ should\ have\ rank\ 1\ or\ have\ shape\ '}}
\DoxyCodeLine{00717\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'consistent\ with\ [None,\ 1]'})}
\DoxyCodeLine{00718\ \ \ \ \ high\_score\_indices\ =\ tf.cast(tf.reshape(}
\DoxyCodeLine{00719\ \ \ \ \ \ \ \ \ tf.where(tf.greater(scores,\ thresh)),}
\DoxyCodeLine{00720\ \ \ \ \ \ \ \ \ [-\/1]),\ tf.int32)}
\DoxyCodeLine{00721\ \ \ \ \ \textcolor{keywordflow}{return}\ gather(boxlist,\ high\_score\_indices)}
\DoxyCodeLine{00722\ }
\DoxyCodeLine{00723\ }

\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d9/da1/namespacedetection__utils_1_1core_1_1box__list__ops_af19b9892d46f5558103b58fb131dc5c5_cgraph}
\end{center}
\end{figure}
\Hypertarget{namespacedetection__utils_1_1core_1_1box__list__ops_ab935f3907c57be324fe3e04a553aad0b}\label{namespacedetection__utils_1_1core_1_1box__list__ops_ab935f3907c57be324fe3e04a553aad0b} 
\index{detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}!gather@{gather}}
\index{gather@{gather}!detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}}
\doxysubsubsection{\texorpdfstring{gather()}{gather()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+core.\+box\+\_\+list\+\_\+ops.\+gather (\begin{DoxyParamCaption}\item[{}]{boxlist,  }\item[{}]{indices,  }\item[{}]{fields = {\ttfamily None},  }\item[{}]{scope = {\ttfamily None},  }\item[{}]{use\+\_\+static\+\_\+shapes = {\ttfamily False} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Gather boxes from BoxList according to indices and return new BoxList.

By default, `gather` returns boxes corresponding to the input index list, as
well as all additional fields stored in the boxlist (indexing into the
first dimension).  However one can optionally only gather from a
subset of fields.

Args:
  boxlist: BoxList holding N boxes
  indices: a rank-1 tensor of type int32 / int64
  fields: (optional) list of fields to also gather from.  If None (default),
    all fields are gathered from.  Pass an empty fields list to only gather
    the box coordinates.
  scope: name scope.
  use_static_shapes: Whether to use an implementation with static shape
    gurantees.

Returns:
  subboxlist: a BoxList corresponding to the subset of the input BoxList
  specified by indices
Raises:
  ValueError: if specified field is not contained in boxlist or if the
    indices are not of type int32
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{box__list__ops_8py_source_l00491}{491}} of file \mbox{\hyperlink{box__list__ops_8py_source}{box\+\_\+list\+\_\+ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00491\ \textcolor{keyword}{def\ }gather(boxlist,\ indices,\ fields=None,\ scope=None,\ use\_static\_shapes=False):}
\DoxyCodeLine{00492\ \ \ \textcolor{stringliteral}{"{}"{}"{}Gather\ boxes\ from\ BoxList\ according\ to\ indices\ and\ return\ new\ BoxList.}}
\DoxyCodeLine{00493\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00494\ \textcolor{stringliteral}{\ \ By\ default,\ \`{}gather\`{}\ returns\ boxes\ corresponding\ to\ the\ input\ index\ list,\ }\textcolor{keyword}{as}}
\DoxyCodeLine{00495\ \ \ well\ \textcolor{keyword}{as}\ all\ additional\ fields\ stored\ \textcolor{keywordflow}{in}\ the\ boxlist\ (indexing\ into\ the}
\DoxyCodeLine{00496\ \ \ first\ dimension).\ \ However\ one\ can\ optionally\ only\ gather\ \textcolor{keyword}{from}\ a}
\DoxyCodeLine{00497\ \ \ subset\ of\ fields.}
\DoxyCodeLine{00498\ }
\DoxyCodeLine{00499\ \ \ Args:}
\DoxyCodeLine{00500\ \ \ \ \ boxlist:\ BoxList\ holding\ N\ boxes}
\DoxyCodeLine{00501\ \ \ \ \ indices:\ a\ rank-\/1\ tensor\ of\ type\ int32\ /\ int64}
\DoxyCodeLine{00502\ \ \ \ \ fields:\ (optional)\ list\ of\ fields\ to\ also\ gather\ \textcolor{keyword}{from}.\ \ If\ \textcolor{keywordtype}{None}\ (default),}
\DoxyCodeLine{00503\ \ \ \ \ \ \ all\ fields\ are\ gathered\ \textcolor{keyword}{from}.\ \ Pass\ an\ empty\ fields\ list\ to\ only\ gather}
\DoxyCodeLine{00504\ \ \ \ \ \ \ the\ box\ coordinates.}
\DoxyCodeLine{00505\ \ \ \ \ scope:\ name\ scope.}
\DoxyCodeLine{00506\ \ \ \ \ use\_static\_shapes:\ Whether\ to\ use\ an\ implementation\ \textcolor{keyword}{with}\ static\ shape}
\DoxyCodeLine{00507\ \ \ \ \ \ \ gurantees.}
\DoxyCodeLine{00508\ }
\DoxyCodeLine{00509\ \ \ Returns:}
\DoxyCodeLine{00510\ \ \ \ \ subboxlist:\ a\ BoxList\ corresponding\ to\ the\ subset\ of\ the\ input\ BoxList}
\DoxyCodeLine{00511\ \ \ \ \ specified\ by\ indices}
\DoxyCodeLine{00512\ \ \ Raises:}
\DoxyCodeLine{00513\ \ \ \ \ ValueError:\ \textcolor{keywordflow}{if}\ specified\ field\ \textcolor{keywordflow}{is}\ \textcolor{keywordflow}{not}\ contained\ \textcolor{keywordflow}{in}\ boxlist\ \textcolor{keywordflow}{or}\ \textcolor{keywordflow}{if}\ the}
\DoxyCodeLine{00514\ \ \ \ \ \ \ indices\ are\ \textcolor{keywordflow}{not}\ of\ type\ int32}
\DoxyCodeLine{00515\ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{00516\ \textcolor{stringliteral}{\ \ }\textcolor{keyword}{with}\ tf.name\_scope(scope,\ \textcolor{stringliteral}{'Gather'}):}
\DoxyCodeLine{00517\ \ \ \ \ \textcolor{keywordflow}{if}\ len(indices.shape.as\_list())\ !=\ 1:}
\DoxyCodeLine{00518\ \ \ \ \ \ \ \textcolor{keywordflow}{raise}\ ValueError(\textcolor{stringliteral}{'indices\ should\ have\ rank\ 1'})}
\DoxyCodeLine{00519\ \ \ \ \ \textcolor{keywordflow}{if}\ indices.dtype\ !=\ tf.int32\ \textcolor{keywordflow}{and}\ indices.dtype\ !=\ tf.int64:}
\DoxyCodeLine{00520\ \ \ \ \ \ \ \textcolor{keywordflow}{raise}\ ValueError(\textcolor{stringliteral}{'indices\ should\ be\ an\ int32\ /\ int64\ tensor'})}
\DoxyCodeLine{00521\ \ \ \ \ gather\_op\ =\ tf.gather}
\DoxyCodeLine{00522\ \ \ \ \ \textcolor{keywordflow}{if}\ use\_static\_shapes:}
\DoxyCodeLine{00523\ \ \ \ \ \ \ gather\_op\ =\ ops.matmul\_gather\_on\_zeroth\_axis}
\DoxyCodeLine{00524\ \ \ \ \ subboxlist\ =\ box\_list.BoxList(gather\_op(boxlist.get(),\ indices))}
\DoxyCodeLine{00525\ \ \ \ \ \textcolor{keywordflow}{if}\ fields\ \textcolor{keywordflow}{is}\ \textcolor{keywordtype}{None}:}
\DoxyCodeLine{00526\ \ \ \ \ \ \ fields\ =\ boxlist.get\_extra\_fields()}
\DoxyCodeLine{00527\ \ \ \ \ fields\ +=\ [\textcolor{stringliteral}{'boxes'}]}
\DoxyCodeLine{00528\ \ \ \ \ \textcolor{keywordflow}{for}\ field\ \textcolor{keywordflow}{in}\ fields:}
\DoxyCodeLine{00529\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ \textcolor{keywordflow}{not}\ boxlist.has\_field(field):}
\DoxyCodeLine{00530\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{raise}\ ValueError(\textcolor{stringliteral}{'boxlist\ must\ contain\ all\ specified\ fields'})}
\DoxyCodeLine{00531\ \ \ \ \ \ \ subfieldlist\ =\ gather\_op(boxlist.get\_field(field),\ indices)}
\DoxyCodeLine{00532\ \ \ \ \ \ \ subboxlist.add\_field(field,\ subfieldlist)}
\DoxyCodeLine{00533\ \ \ \ \ \textcolor{keywordflow}{return}\ subboxlist}
\DoxyCodeLine{00534\ }
\DoxyCodeLine{00535\ }

\end{DoxyCode}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d9/da1/namespacedetection__utils_1_1core_1_1box__list__ops_ab935f3907c57be324fe3e04a553aad0b_icgraph}
\end{center}
\end{figure}
\Hypertarget{namespacedetection__utils_1_1core_1_1box__list__ops_ab20486b60634ec258c5e24dbc5f64e52}\label{namespacedetection__utils_1_1core_1_1box__list__ops_ab20486b60634ec258c5e24dbc5f64e52} 
\index{detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}!get\_minimal\_coverage\_box@{get\_minimal\_coverage\_box}}
\index{get\_minimal\_coverage\_box@{get\_minimal\_coverage\_box}!detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}}
\doxysubsubsection{\texorpdfstring{get\_minimal\_coverage\_box()}{get\_minimal\_coverage\_box()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+core.\+box\+\_\+list\+\_\+ops.\+get\+\_\+minimal\+\_\+coverage\+\_\+box (\begin{DoxyParamCaption}\item[{}]{boxlist,  }\item[{}]{default\+\_\+box = {\ttfamily None},  }\item[{}]{scope = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Creates a single bounding box which covers all boxes in the boxlist.

Args:
  boxlist: A Boxlist.
  default_box: A [1, 4] float32 tensor. If no boxes are present in `boxlist`,
    this default box will be returned. If None, will use a default box of
    [[0., 0., 1., 1.]].
  scope: Name scope.

Returns:
  A [1, 4] float32 tensor with a bounding box that tightly covers all the
  boxes in the box list. If the boxlist does not contain any boxes, the
  default box is returned.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{box__list__ops_8py_source_l01058}{1058}} of file \mbox{\hyperlink{box__list__ops_8py_source}{box\+\_\+list\+\_\+ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{01060\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ scope=\textcolor{keywordtype}{None}):}
\DoxyCodeLine{01061\ \ \ \textcolor{stringliteral}{"{}"{}"{}Creates\ a\ single\ bounding\ box\ which\ covers\ all\ boxes\ in\ the\ boxlist.}}
\DoxyCodeLine{01062\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01063\ \textcolor{stringliteral}{\ \ Args:}}
\DoxyCodeLine{01064\ \textcolor{stringliteral}{\ \ \ \ boxlist:\ A\ Boxlist.}}
\DoxyCodeLine{01065\ \textcolor{stringliteral}{\ \ \ \ default\_box:\ A\ [1,\ 4]\ float32\ tensor.\ If\ no\ boxes\ are\ present\ }\textcolor{keywordflow}{in}\ \`{}boxlist\`{},}
\DoxyCodeLine{01066\ \ \ \ \ \ \ this\ default\ box\ will\ be\ returned.\ If\ \textcolor{keywordtype}{None},\ will\ use\ a\ default\ box\ of}
\DoxyCodeLine{01067\ \ \ \ \ \ \ [[0.,\ 0.,\ 1.,\ 1.]].}
\DoxyCodeLine{01068\ \ \ \ \ scope:\ Name\ scope.}
\DoxyCodeLine{01069\ }
\DoxyCodeLine{01070\ \ \ Returns:}
\DoxyCodeLine{01071\ \ \ \ \ A\ [1,\ 4]\ float32\ tensor\ \textcolor{keyword}{with}\ a\ bounding\ box\ that\ tightly\ covers\ all\ the}
\DoxyCodeLine{01072\ \ \ \ \ boxes\ \textcolor{keywordflow}{in}\ the\ box\ list.\ If\ the\ boxlist\ does\ \textcolor{keywordflow}{not}\ contain\ any\ boxes,\ the}
\DoxyCodeLine{01073\ \ \ \ \ default\ box\ \textcolor{keywordflow}{is}\ returned.}
\DoxyCodeLine{01074\ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{01075\ \textcolor{stringliteral}{\ \ }\textcolor{keyword}{with}\ tf.name\_scope(scope,\ \textcolor{stringliteral}{'CreateCoverageBox'}):}
\DoxyCodeLine{01076\ \ \ \ \ num\_boxes\ =\ boxlist.num\_boxes()}
\DoxyCodeLine{01077\ }
\DoxyCodeLine{01078\ \ \ \ \ \textcolor{keyword}{def\ }coverage\_box(bboxes):}
\DoxyCodeLine{01079\ \ \ \ \ \ \ y\_min,\ x\_min,\ y\_max,\ x\_max\ =\ tf.split(}
\DoxyCodeLine{01080\ \ \ \ \ \ \ \ \ \ \ value=bboxes,\ num\_or\_size\_splits=4,\ axis=1)}
\DoxyCodeLine{01081\ \ \ \ \ \ \ y\_min\_coverage\ =\ tf.reduce\_min(y\_min,\ axis=0)}
\DoxyCodeLine{01082\ \ \ \ \ \ \ x\_min\_coverage\ =\ tf.reduce\_min(x\_min,\ axis=0)}
\DoxyCodeLine{01083\ \ \ \ \ \ \ y\_max\_coverage\ =\ tf.reduce\_max(y\_max,\ axis=0)}
\DoxyCodeLine{01084\ \ \ \ \ \ \ x\_max\_coverage\ =\ tf.reduce\_max(x\_max,\ axis=0)}
\DoxyCodeLine{01085\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ tf.stack(}
\DoxyCodeLine{01086\ \ \ \ \ \ \ \ \ \ \ [y\_min\_coverage,\ x\_min\_coverage,\ y\_max\_coverage,\ x\_max\_coverage],}
\DoxyCodeLine{01087\ \ \ \ \ \ \ \ \ \ \ axis=1)}
\DoxyCodeLine{01088\ }
\DoxyCodeLine{01089\ \ \ \ \ default\_box\ =\ default\_box\ \textcolor{keywordflow}{or}\ tf.constant([[0.,\ 0.,\ 1.,\ 1.]])}
\DoxyCodeLine{01090\ \ \ \ \ \textcolor{keywordflow}{return}\ tf.cond(}
\DoxyCodeLine{01091\ \ \ \ \ \ \ \ \ tf.greater\_equal(num\_boxes,\ 1),}
\DoxyCodeLine{01092\ \ \ \ \ \ \ \ \ true\_fn=\textcolor{keyword}{lambda}:\ coverage\_box(boxlist.get()),}
\DoxyCodeLine{01093\ \ \ \ \ \ \ \ \ false\_fn=\textcolor{keyword}{lambda}:\ default\_box)}
\DoxyCodeLine{01094\ }
\DoxyCodeLine{01095\ }

\end{DoxyCode}
\Hypertarget{namespacedetection__utils_1_1core_1_1box__list__ops_a30d8f8a23a3ee1a92ed2aded0b20b761}\label{namespacedetection__utils_1_1core_1_1box__list__ops_a30d8f8a23a3ee1a92ed2aded0b20b761} 
\index{detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}!height\_width@{height\_width}}
\index{height\_width@{height\_width}!detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}}
\doxysubsubsection{\texorpdfstring{height\_width()}{height\_width()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+core.\+box\+\_\+list\+\_\+ops.\+height\+\_\+width (\begin{DoxyParamCaption}\item[{}]{boxlist,  }\item[{}]{scope = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Computes height and width of boxes in boxlist.

Args:
  boxlist: BoxList holding N boxes
  scope: name scope.

Returns:
  Height: A tensor with shape [N] representing box heights.
  Width: A tensor with shape [N] representing box widths.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{box__list__ops_8py_source_l00065}{65}} of file \mbox{\hyperlink{box__list__ops_8py_source}{box\+\_\+list\+\_\+ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00065\ \textcolor{keyword}{def\ }height\_width(boxlist,\ scope=None):}
\DoxyCodeLine{00066\ \ \ \textcolor{stringliteral}{"{}"{}"{}Computes\ height\ and\ width\ of\ boxes\ in\ boxlist.}}
\DoxyCodeLine{00067\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00068\ \textcolor{stringliteral}{\ \ Args:}}
\DoxyCodeLine{00069\ \textcolor{stringliteral}{\ \ \ \ boxlist:\ BoxList\ holding\ N\ boxes}}
\DoxyCodeLine{00070\ \textcolor{stringliteral}{\ \ \ \ scope:\ name\ scope.}}
\DoxyCodeLine{00071\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00072\ \textcolor{stringliteral}{\ \ Returns:}}
\DoxyCodeLine{00073\ \textcolor{stringliteral}{\ \ \ \ Height:\ A\ tensor\ }\textcolor{keyword}{with}\ shape\ [N]\ representing\ box\ heights.}
\DoxyCodeLine{00074\ \ \ \ \ Width:\ A\ tensor\ \textcolor{keyword}{with}\ shape\ [N]\ representing\ box\ widths.}
\DoxyCodeLine{00075\ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{00076\ \textcolor{stringliteral}{\ \ }\textcolor{keyword}{with}\ tf.name\_scope(scope,\ \textcolor{stringliteral}{'HeightWidth'}):}
\DoxyCodeLine{00077\ \ \ \ \ y\_min,\ x\_min,\ y\_max,\ x\_max\ =\ tf.split(}
\DoxyCodeLine{00078\ \ \ \ \ \ \ \ \ value=boxlist.get(),\ num\_or\_size\_splits=4,\ axis=1)}
\DoxyCodeLine{00079\ \ \ \ \ \textcolor{keywordflow}{return}\ tf.squeeze(y\_max\ -\/\ y\_min,\ [1]),\ tf.squeeze(x\_max\ -\/\ x\_min,\ [1])}
\DoxyCodeLine{00080\ }
\DoxyCodeLine{00081\ }

\end{DoxyCode}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d9/da1/namespacedetection__utils_1_1core_1_1box__list__ops_a30d8f8a23a3ee1a92ed2aded0b20b761_icgraph}
\end{center}
\end{figure}
\Hypertarget{namespacedetection__utils_1_1core_1_1box__list__ops_afd15da7dda22daae6756580f198e34da}\label{namespacedetection__utils_1_1core_1_1box__list__ops_afd15da7dda22daae6756580f198e34da} 
\index{detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}!intersection@{intersection}}
\index{intersection@{intersection}!detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}}
\doxysubsubsection{\texorpdfstring{intersection()}{intersection()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+core.\+box\+\_\+list\+\_\+ops.\+intersection (\begin{DoxyParamCaption}\item[{}]{boxlist1,  }\item[{}]{boxlist2,  }\item[{}]{scope = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute pairwise intersection areas between boxes.

Args:
  boxlist1: BoxList holding N boxes
  boxlist2: BoxList holding M boxes
  scope: name scope.

Returns:
  a tensor with shape [N, M] representing pairwise intersections
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{box__list__ops_8py_source_l00210}{210}} of file \mbox{\hyperlink{box__list__ops_8py_source}{box\+\_\+list\+\_\+ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00210\ \textcolor{keyword}{def\ }intersection(boxlist1,\ boxlist2,\ scope=None):}
\DoxyCodeLine{00211\ \ \ \textcolor{stringliteral}{"{}"{}"{}Compute\ pairwise\ intersection\ areas\ between\ boxes.}}
\DoxyCodeLine{00212\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00213\ \textcolor{stringliteral}{\ \ Args:}}
\DoxyCodeLine{00214\ \textcolor{stringliteral}{\ \ \ \ boxlist1:\ BoxList\ holding\ N\ boxes}}
\DoxyCodeLine{00215\ \textcolor{stringliteral}{\ \ \ \ boxlist2:\ BoxList\ holding\ M\ boxes}}
\DoxyCodeLine{00216\ \textcolor{stringliteral}{\ \ \ \ scope:\ name\ scope.}}
\DoxyCodeLine{00217\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00218\ \textcolor{stringliteral}{\ \ Returns:}}
\DoxyCodeLine{00219\ \textcolor{stringliteral}{\ \ \ \ a\ tensor\ }\textcolor{keyword}{with}\ shape\ [N,\ M]\ representing\ pairwise\ intersections}
\DoxyCodeLine{00220\ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{00221\ \textcolor{stringliteral}{\ \ }\textcolor{keyword}{with}\ tf.name\_scope(scope,\ \textcolor{stringliteral}{'Intersection'}):}
\DoxyCodeLine{00222\ \ \ \ \ y\_min1,\ x\_min1,\ y\_max1,\ x\_max1\ =\ tf.split(}
\DoxyCodeLine{00223\ \ \ \ \ \ \ \ \ value=boxlist1.get(),\ num\_or\_size\_splits=4,\ axis=1)}
\DoxyCodeLine{00224\ \ \ \ \ y\_min2,\ x\_min2,\ y\_max2,\ x\_max2\ =\ tf.split(}
\DoxyCodeLine{00225\ \ \ \ \ \ \ \ \ value=boxlist2.get(),\ num\_or\_size\_splits=4,\ axis=1)}
\DoxyCodeLine{00226\ \ \ \ \ all\_pairs\_min\_ymax\ =\ tf.minimum(y\_max1,\ tf.transpose(y\_max2))}
\DoxyCodeLine{00227\ \ \ \ \ all\_pairs\_max\_ymin\ =\ tf.maximum(y\_min1,\ tf.transpose(y\_min2))}
\DoxyCodeLine{00228\ \ \ \ \ intersect\_heights\ =\ tf.maximum(0.0,\ all\_pairs\_min\_ymax\ -\/\ all\_pairs\_max\_ymin)}
\DoxyCodeLine{00229\ \ \ \ \ all\_pairs\_min\_xmax\ =\ tf.minimum(x\_max1,\ tf.transpose(x\_max2))}
\DoxyCodeLine{00230\ \ \ \ \ all\_pairs\_max\_xmin\ =\ tf.maximum(x\_min1,\ tf.transpose(x\_min2))}
\DoxyCodeLine{00231\ \ \ \ \ intersect\_widths\ =\ tf.maximum(0.0,\ all\_pairs\_min\_xmax\ -\/\ all\_pairs\_max\_xmin)}
\DoxyCodeLine{00232\ \ \ \ \ \textcolor{keywordflow}{return}\ intersect\_heights\ *\ intersect\_widths}
\DoxyCodeLine{00233\ }
\DoxyCodeLine{00234\ }

\end{DoxyCode}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d9/da1/namespacedetection__utils_1_1core_1_1box__list__ops_afd15da7dda22daae6756580f198e34da_icgraph}
\end{center}
\end{figure}
\Hypertarget{namespacedetection__utils_1_1core_1_1box__list__ops_a9e0ac719b5e09ec7392954a9c9fe4174}\label{namespacedetection__utils_1_1core_1_1box__list__ops_a9e0ac719b5e09ec7392954a9c9fe4174} 
\index{detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}!ioa@{ioa}}
\index{ioa@{ioa}!detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}}
\doxysubsubsection{\texorpdfstring{ioa()}{ioa()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+core.\+box\+\_\+list\+\_\+ops.\+ioa (\begin{DoxyParamCaption}\item[{}]{boxlist1,  }\item[{}]{boxlist2,  }\item[{}]{scope = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Computes pairwise intersection-over-area between box collections.

intersection-over-area (IOA) between two boxes box1 and box2 is defined as
their intersection area over box2's area. Note that ioa is not symmetric,
that is, ioa(box1, box2) != ioa(box2, box1).

Args:
  boxlist1: BoxList holding N boxes
  boxlist2: BoxList holding M boxes
  scope: name scope.

Returns:
  a tensor with shape [N, M] representing pairwise ioa scores.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{box__list__ops_8py_source_l00303}{303}} of file \mbox{\hyperlink{box__list__ops_8py_source}{box\+\_\+list\+\_\+ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00303\ \textcolor{keyword}{def\ }ioa(boxlist1,\ boxlist2,\ scope=None):}
\DoxyCodeLine{00304\ \ \ \textcolor{stringliteral}{"{}"{}"{}Computes\ pairwise\ intersection-\/over-\/area\ between\ box\ collections.}}
\DoxyCodeLine{00305\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00306\ \textcolor{stringliteral}{\ \ intersection-\/over-\/area\ (IOA)\ between\ two\ boxes\ box1\ }\textcolor{keywordflow}{and}\ box2\ \textcolor{keywordflow}{is}\ defined\ \textcolor{keyword}{as}}
\DoxyCodeLine{00307\ \ \ their\ intersection\ area\ over\ box2\textcolor{stringliteral}{'s\ area.\ Note\ that\ ioa\ is\ not\ symmetric,}}
\DoxyCodeLine{00308\ \textcolor{stringliteral}{\ \ that\ }\textcolor{keywordflow}{is},\ ioa(box1,\ box2)\ !=\ ioa(box2,\ box1).}
\DoxyCodeLine{00309\ }
\DoxyCodeLine{00310\ \ \ Args:}
\DoxyCodeLine{00311\ \ \ \ \ boxlist1:\ BoxList\ holding\ N\ boxes}
\DoxyCodeLine{00312\ \ \ \ \ boxlist2:\ BoxList\ holding\ M\ boxes}
\DoxyCodeLine{00313\ \ \ \ \ scope:\ name\ scope.}
\DoxyCodeLine{00314\ }
\DoxyCodeLine{00315\ \ \ Returns:}
\DoxyCodeLine{00316\ \ \ \ \ a\ tensor\ \textcolor{keyword}{with}\ shape\ [N,\ M]\ representing\ pairwise\ ioa\ scores.}
\DoxyCodeLine{00317\ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{00318\ \textcolor{stringliteral}{\ \ }\textcolor{keyword}{with}\ tf.name\_scope(scope,\ \textcolor{stringliteral}{'IOA'}):}
\DoxyCodeLine{00319\ \ \ \ \ intersections\ =\ intersection(boxlist1,\ boxlist2)}
\DoxyCodeLine{00320\ \ \ \ \ areas\ =\ tf.expand\_dims(area(boxlist2),\ 0)}
\DoxyCodeLine{00321\ \ \ \ \ \textcolor{keywordflow}{return}\ tf.truediv(intersections,\ areas)}
\DoxyCodeLine{00322\ }
\DoxyCodeLine{00323\ }

\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d9/da1/namespacedetection__utils_1_1core_1_1box__list__ops_a9e0ac719b5e09ec7392954a9c9fe4174_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d9/da1/namespacedetection__utils_1_1core_1_1box__list__ops_a9e0ac719b5e09ec7392954a9c9fe4174_icgraph}
\end{center}
\end{figure}
\Hypertarget{namespacedetection__utils_1_1core_1_1box__list__ops_a0c3ceb43da9213d701fe159dd5ab3b16}\label{namespacedetection__utils_1_1core_1_1box__list__ops_a0c3ceb43da9213d701fe159dd5ab3b16} 
\index{detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}!iou@{iou}}
\index{iou@{iou}!detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}}
\doxysubsubsection{\texorpdfstring{iou()}{iou()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+core.\+box\+\_\+list\+\_\+ops.\+iou (\begin{DoxyParamCaption}\item[{}]{boxlist1,  }\item[{}]{boxlist2,  }\item[{}]{scope = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Computes pairwise intersection-over-union between box collections.

Args:
  boxlist1: BoxList holding N boxes
  boxlist2: BoxList holding M boxes
  scope: name scope.

Returns:
  a tensor with shape [N, M] representing pairwise iou scores.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{box__list__ops_8py_source_l00260}{260}} of file \mbox{\hyperlink{box__list__ops_8py_source}{box\+\_\+list\+\_\+ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00260\ \textcolor{keyword}{def\ }iou(boxlist1,\ boxlist2,\ scope=None):}
\DoxyCodeLine{00261\ \ \ \textcolor{stringliteral}{"{}"{}"{}Computes\ pairwise\ intersection-\/over-\/union\ between\ box\ collections.}}
\DoxyCodeLine{00262\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00263\ \textcolor{stringliteral}{\ \ Args:}}
\DoxyCodeLine{00264\ \textcolor{stringliteral}{\ \ \ \ boxlist1:\ BoxList\ holding\ N\ boxes}}
\DoxyCodeLine{00265\ \textcolor{stringliteral}{\ \ \ \ boxlist2:\ BoxList\ holding\ M\ boxes}}
\DoxyCodeLine{00266\ \textcolor{stringliteral}{\ \ \ \ scope:\ name\ scope.}}
\DoxyCodeLine{00267\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00268\ \textcolor{stringliteral}{\ \ Returns:}}
\DoxyCodeLine{00269\ \textcolor{stringliteral}{\ \ \ \ a\ tensor\ }\textcolor{keyword}{with}\ shape\ [N,\ M]\ representing\ pairwise\ iou\ scores.}
\DoxyCodeLine{00270\ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{00271\ \textcolor{stringliteral}{\ \ }\textcolor{keyword}{with}\ tf.name\_scope(scope,\ \textcolor{stringliteral}{'IOU'}):}
\DoxyCodeLine{00272\ \ \ \ \ intersections\ =\ intersection(boxlist1,\ boxlist2)}
\DoxyCodeLine{00273\ \ \ \ \ areas1\ =\ area(boxlist1)}
\DoxyCodeLine{00274\ \ \ \ \ areas2\ =\ area(boxlist2)}
\DoxyCodeLine{00275\ \ \ \ \ unions\ =\ (}
\DoxyCodeLine{00276\ \ \ \ \ \ \ \ \ tf.expand\_dims(areas1,\ 1)\ +\ tf.expand\_dims(areas2,\ 0)\ -\/\ intersections)}
\DoxyCodeLine{00277\ \ \ \ \ \textcolor{keywordflow}{return}\ tf.where(}
\DoxyCodeLine{00278\ \ \ \ \ \ \ \ \ tf.equal(intersections,\ 0.0),}
\DoxyCodeLine{00279\ \ \ \ \ \ \ \ \ tf.zeros\_like(intersections),\ tf.truediv(intersections,\ unions))}
\DoxyCodeLine{00280\ }
\DoxyCodeLine{00281\ }

\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d9/da1/namespacedetection__utils_1_1core_1_1box__list__ops_a0c3ceb43da9213d701fe159dd5ab3b16_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d9/da1/namespacedetection__utils_1_1core_1_1box__list__ops_a0c3ceb43da9213d701fe159dd5ab3b16_icgraph}
\end{center}
\end{figure}
\Hypertarget{namespacedetection__utils_1_1core_1_1box__list__ops_afdde2971529ea91174efe09af9202c05}\label{namespacedetection__utils_1_1core_1_1box__list__ops_afdde2971529ea91174efe09af9202c05} 
\index{detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}!matched\_intersection@{matched\_intersection}}
\index{matched\_intersection@{matched\_intersection}!detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}}
\doxysubsubsection{\texorpdfstring{matched\_intersection()}{matched\_intersection()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+core.\+box\+\_\+list\+\_\+ops.\+matched\+\_\+intersection (\begin{DoxyParamCaption}\item[{}]{boxlist1,  }\item[{}]{boxlist2,  }\item[{}]{scope = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute intersection areas between corresponding boxes in two boxlists.

Args:
  boxlist1: BoxList holding N boxes
  boxlist2: BoxList holding N boxes
  scope: name scope.

Returns:
  a tensor with shape [N] representing pairwise intersections
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{box__list__ops_8py_source_l00235}{235}} of file \mbox{\hyperlink{box__list__ops_8py_source}{box\+\_\+list\+\_\+ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00235\ \textcolor{keyword}{def\ }matched\_intersection(boxlist1,\ boxlist2,\ scope=None):}
\DoxyCodeLine{00236\ \ \ \textcolor{stringliteral}{"{}"{}"{}Compute\ intersection\ areas\ between\ corresponding\ boxes\ in\ two\ boxlists.}}
\DoxyCodeLine{00237\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00238\ \textcolor{stringliteral}{\ \ Args:}}
\DoxyCodeLine{00239\ \textcolor{stringliteral}{\ \ \ \ boxlist1:\ BoxList\ holding\ N\ boxes}}
\DoxyCodeLine{00240\ \textcolor{stringliteral}{\ \ \ \ boxlist2:\ BoxList\ holding\ N\ boxes}}
\DoxyCodeLine{00241\ \textcolor{stringliteral}{\ \ \ \ scope:\ name\ scope.}}
\DoxyCodeLine{00242\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00243\ \textcolor{stringliteral}{\ \ Returns:}}
\DoxyCodeLine{00244\ \textcolor{stringliteral}{\ \ \ \ a\ tensor\ }\textcolor{keyword}{with}\ shape\ [N]\ representing\ pairwise\ intersections}
\DoxyCodeLine{00245\ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{00246\ \textcolor{stringliteral}{\ \ }\textcolor{keyword}{with}\ tf.name\_scope(scope,\ \textcolor{stringliteral}{'MatchedIntersection'}):}
\DoxyCodeLine{00247\ \ \ \ \ y\_min1,\ x\_min1,\ y\_max1,\ x\_max1\ =\ tf.split(}
\DoxyCodeLine{00248\ \ \ \ \ \ \ \ \ value=boxlist1.get(),\ num\_or\_size\_splits=4,\ axis=1)}
\DoxyCodeLine{00249\ \ \ \ \ y\_min2,\ x\_min2,\ y\_max2,\ x\_max2\ =\ tf.split(}
\DoxyCodeLine{00250\ \ \ \ \ \ \ \ \ value=boxlist2.get(),\ num\_or\_size\_splits=4,\ axis=1)}
\DoxyCodeLine{00251\ \ \ \ \ min\_ymax\ =\ tf.minimum(y\_max1,\ y\_max2)}
\DoxyCodeLine{00252\ \ \ \ \ max\_ymin\ =\ tf.maximum(y\_min1,\ y\_min2)}
\DoxyCodeLine{00253\ \ \ \ \ intersect\_heights\ =\ tf.maximum(0.0,\ min\_ymax\ -\/\ max\_ymin)}
\DoxyCodeLine{00254\ \ \ \ \ min\_xmax\ =\ tf.minimum(x\_max1,\ x\_max2)}
\DoxyCodeLine{00255\ \ \ \ \ max\_xmin\ =\ tf.maximum(x\_min1,\ x\_min2)}
\DoxyCodeLine{00256\ \ \ \ \ intersect\_widths\ =\ tf.maximum(0.0,\ min\_xmax\ -\/\ max\_xmin)}
\DoxyCodeLine{00257\ \ \ \ \ \textcolor{keywordflow}{return}\ tf.reshape(intersect\_heights\ *\ intersect\_widths,\ [-\/1])}
\DoxyCodeLine{00258\ }
\DoxyCodeLine{00259\ }

\end{DoxyCode}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d9/da1/namespacedetection__utils_1_1core_1_1box__list__ops_afdde2971529ea91174efe09af9202c05_icgraph}
\end{center}
\end{figure}
\Hypertarget{namespacedetection__utils_1_1core_1_1box__list__ops_a9fad601f99641baf7fda27235c4723a0}\label{namespacedetection__utils_1_1core_1_1box__list__ops_a9fad601f99641baf7fda27235c4723a0} 
\index{detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}!matched\_iou@{matched\_iou}}
\index{matched\_iou@{matched\_iou}!detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}}
\doxysubsubsection{\texorpdfstring{matched\_iou()}{matched\_iou()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+core.\+box\+\_\+list\+\_\+ops.\+matched\+\_\+iou (\begin{DoxyParamCaption}\item[{}]{boxlist1,  }\item[{}]{boxlist2,  }\item[{}]{scope = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute intersection-over-union between corresponding boxes in boxlists.

Args:
  boxlist1: BoxList holding N boxes
  boxlist2: BoxList holding N boxes
  scope: name scope.

Returns:
  a tensor with shape [N] representing pairwise iou scores.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{box__list__ops_8py_source_l00282}{282}} of file \mbox{\hyperlink{box__list__ops_8py_source}{box\+\_\+list\+\_\+ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00282\ \textcolor{keyword}{def\ }matched\_iou(boxlist1,\ boxlist2,\ scope=None):}
\DoxyCodeLine{00283\ \ \ \textcolor{stringliteral}{"{}"{}"{}Compute\ intersection-\/over-\/union\ between\ corresponding\ boxes\ in\ boxlists.}}
\DoxyCodeLine{00284\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00285\ \textcolor{stringliteral}{\ \ Args:}}
\DoxyCodeLine{00286\ \textcolor{stringliteral}{\ \ \ \ boxlist1:\ BoxList\ holding\ N\ boxes}}
\DoxyCodeLine{00287\ \textcolor{stringliteral}{\ \ \ \ boxlist2:\ BoxList\ holding\ N\ boxes}}
\DoxyCodeLine{00288\ \textcolor{stringliteral}{\ \ \ \ scope:\ name\ scope.}}
\DoxyCodeLine{00289\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00290\ \textcolor{stringliteral}{\ \ Returns:}}
\DoxyCodeLine{00291\ \textcolor{stringliteral}{\ \ \ \ a\ tensor\ }\textcolor{keyword}{with}\ shape\ [N]\ representing\ pairwise\ iou\ scores.}
\DoxyCodeLine{00292\ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{00293\ \textcolor{stringliteral}{\ \ }\textcolor{keyword}{with}\ tf.name\_scope(scope,\ \textcolor{stringliteral}{'MatchedIOU'}):}
\DoxyCodeLine{00294\ \ \ \ \ intersections\ =\ matched\_intersection(boxlist1,\ boxlist2)}
\DoxyCodeLine{00295\ \ \ \ \ areas1\ =\ area(boxlist1)}
\DoxyCodeLine{00296\ \ \ \ \ areas2\ =\ area(boxlist2)}
\DoxyCodeLine{00297\ \ \ \ \ unions\ =\ areas1\ +\ areas2\ -\/\ intersections}
\DoxyCodeLine{00298\ \ \ \ \ \textcolor{keywordflow}{return}\ tf.where(}
\DoxyCodeLine{00299\ \ \ \ \ \ \ \ \ tf.equal(intersections,\ 0.0),}
\DoxyCodeLine{00300\ \ \ \ \ \ \ \ \ tf.zeros\_like(intersections),\ tf.truediv(intersections,\ unions))}
\DoxyCodeLine{00301\ }
\DoxyCodeLine{00302\ }

\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d9/da1/namespacedetection__utils_1_1core_1_1box__list__ops_a9fad601f99641baf7fda27235c4723a0_cgraph}
\end{center}
\end{figure}
\Hypertarget{namespacedetection__utils_1_1core_1_1box__list__ops_a4f53127d0876cf0b4ab378bf7d2e2ef1}\label{namespacedetection__utils_1_1core_1_1box__list__ops_a4f53127d0876cf0b4ab378bf7d2e2ef1} 
\index{detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}!non\_max\_suppression@{non\_max\_suppression}}
\index{non\_max\_suppression@{non\_max\_suppression}!detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}}
\doxysubsubsection{\texorpdfstring{non\_max\_suppression()}{non\_max\_suppression()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+core.\+box\+\_\+list\+\_\+ops.\+non\+\_\+max\+\_\+suppression (\begin{DoxyParamCaption}\item[{}]{boxlist,  }\item[{}]{thresh,  }\item[{}]{max\+\_\+output\+\_\+size,  }\item[{}]{scope = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Non maximum suppression.

This op greedily selects a subset of detection bounding boxes, pruning
away boxes that have high IOU (intersection over union) overlap (> thresh)
with already selected boxes.  Note that this only works for a single class ---
to apply NMS to multi-class predictions, use MultiClassNonMaxSuppression.

Args:
  boxlist: BoxList holding N boxes.  Must contain a 'scores' field
    representing detection scores.
  thresh: scalar threshold
  max_output_size: maximum number of retained boxes
  scope: name scope.

Returns:
  a BoxList holding M boxes where M <= max_output_size
Raises:
  ValueError: if thresh is not in [0, 1]
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{box__list__ops_8py_source_l00724}{724}} of file \mbox{\hyperlink{box__list__ops_8py_source}{box\+\_\+list\+\_\+ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00724\ \textcolor{keyword}{def\ }non\_max\_suppression(boxlist,\ thresh,\ max\_output\_size,\ scope=None):}
\DoxyCodeLine{00725\ \ \ \textcolor{stringliteral}{"{}"{}"{}Non\ maximum\ suppression.}}
\DoxyCodeLine{00726\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00727\ \textcolor{stringliteral}{\ \ This\ op\ greedily\ selects\ a\ subset\ of\ detection\ bounding\ boxes,\ pruning}}
\DoxyCodeLine{00728\ \textcolor{stringliteral}{\ \ away\ boxes\ that\ have\ high\ IOU\ (intersection\ over\ union)\ overlap\ (>\ thresh)}}
\DoxyCodeLine{00729\ \textcolor{stringliteral}{\ \ }\textcolor{keyword}{with}\ already\ selected\ boxes.\ \ Note\ that\ this\ only\ works\ \textcolor{keywordflow}{for}\ a\ single\ \textcolor{keyword}{class\ }-\/-\/-\/}
\DoxyCodeLine{00730\ \ \ to\ apply\ NMS\ to\ multi-\/\textcolor{keyword}{class\ }predictions,\ use\ MultiClassNonMaxSuppression.}
\DoxyCodeLine{00731\ }
\DoxyCodeLine{00732\ \ \ Args:}
\DoxyCodeLine{00733\ \ \ \ \ boxlist:\ BoxList\ holding\ N\ boxes.\ \ Must\ contain\ a\ \textcolor{stringliteral}{'scores'}\ field}
\DoxyCodeLine{00734\ \ \ \ \ \ \ representing\ detection\ scores.}
\DoxyCodeLine{00735\ \ \ \ \ thresh:\ scalar\ threshold}
\DoxyCodeLine{00736\ \ \ \ \ max\_output\_size:\ maximum\ number\ of\ retained\ boxes}
\DoxyCodeLine{00737\ \ \ \ \ scope:\ name\ scope.}
\DoxyCodeLine{00738\ }
\DoxyCodeLine{00739\ \ \ Returns:}
\DoxyCodeLine{00740\ \ \ \ \ a\ BoxList\ holding\ M\ boxes\ where\ M\ <=\ max\_output\_size}
\DoxyCodeLine{00741\ \ \ Raises:}
\DoxyCodeLine{00742\ \ \ \ \ ValueError:\ \textcolor{keywordflow}{if}\ thresh\ \textcolor{keywordflow}{is}\ \textcolor{keywordflow}{not}\ \textcolor{keywordflow}{in}\ [0,\ 1]}
\DoxyCodeLine{00743\ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{00744\ \textcolor{stringliteral}{\ \ }\textcolor{keyword}{with}\ tf.name\_scope(scope,\ \textcolor{stringliteral}{'NonMaxSuppression'}):}
\DoxyCodeLine{00745\ \ \ \ \ \textcolor{keywordflow}{if}\ \textcolor{keywordflow}{not}\ 0\ <=\ thresh\ <=\ 1.0:}
\DoxyCodeLine{00746\ \ \ \ \ \ \ \textcolor{keywordflow}{raise}\ ValueError(\textcolor{stringliteral}{'thresh\ must\ be\ between\ 0\ and\ 1'})}
\DoxyCodeLine{00747\ \ \ \ \ \textcolor{keywordflow}{if}\ \textcolor{keywordflow}{not}\ isinstance(boxlist,\ box\_list.BoxList):}
\DoxyCodeLine{00748\ \ \ \ \ \ \ \textcolor{keywordflow}{raise}\ ValueError(\textcolor{stringliteral}{'boxlist\ must\ be\ a\ BoxList'})}
\DoxyCodeLine{00749\ \ \ \ \ \textcolor{keywordflow}{if}\ \textcolor{keywordflow}{not}\ boxlist.has\_field(\textcolor{stringliteral}{'scores'}):}
\DoxyCodeLine{00750\ \ \ \ \ \ \ \textcolor{keywordflow}{raise}\ ValueError(\textcolor{stringliteral}{'input\ boxlist\ must\ have\ \(\backslash\)'scores\(\backslash\)'\ field'})}
\DoxyCodeLine{00751\ \ \ \ \ selected\_indices\ =\ tf.image.non\_max\_suppression(}
\DoxyCodeLine{00752\ \ \ \ \ \ \ \ \ boxlist.get(),\ boxlist.get\_field(\textcolor{stringliteral}{'scores'}),}
\DoxyCodeLine{00753\ \ \ \ \ \ \ \ \ max\_output\_size,\ iou\_threshold=thresh)}
\DoxyCodeLine{00754\ \ \ \ \ \textcolor{keywordflow}{return}\ gather(boxlist,\ selected\_indices)}
\DoxyCodeLine{00755\ }
\DoxyCodeLine{00756\ }

\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d9/da1/namespacedetection__utils_1_1core_1_1box__list__ops_a4f53127d0876cf0b4ab378bf7d2e2ef1_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d9/da1/namespacedetection__utils_1_1core_1_1box__list__ops_a4f53127d0876cf0b4ab378bf7d2e2ef1_icgraph}
\end{center}
\end{figure}
\Hypertarget{namespacedetection__utils_1_1core_1_1box__list__ops_ad7ee814b54c928c4600ce5f111e6b51b}\label{namespacedetection__utils_1_1core_1_1box__list__ops_ad7ee814b54c928c4600ce5f111e6b51b} 
\index{detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}!pad\_or\_clip\_box\_list@{pad\_or\_clip\_box\_list}}
\index{pad\_or\_clip\_box\_list@{pad\_or\_clip\_box\_list}!detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}}
\doxysubsubsection{\texorpdfstring{pad\_or\_clip\_box\_list()}{pad\_or\_clip\_box\_list()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+core.\+box\+\_\+list\+\_\+ops.\+pad\+\_\+or\+\_\+clip\+\_\+box\+\_\+list (\begin{DoxyParamCaption}\item[{}]{boxlist,  }\item[{}]{num\+\_\+boxes,  }\item[{}]{scope = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Pads or clips all fields of a BoxList.

Args:
  boxlist: A BoxList with arbitrary of number of boxes.
  num_boxes: First num_boxes in boxlist are kept.
    The fields are zero-padded if num_boxes is bigger than the
    actual number of boxes.
  scope: name scope.

Returns:
  BoxList with all fields padded or clipped.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{box__list__ops_8py_source_l00997}{997}} of file \mbox{\hyperlink{box__list__ops_8py_source}{box\+\_\+list\+\_\+ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00997\ \textcolor{keyword}{def\ }pad\_or\_clip\_box\_list(boxlist,\ num\_boxes,\ scope=None):}
\DoxyCodeLine{00998\ \ \ \textcolor{stringliteral}{"{}"{}"{}Pads\ or\ clips\ all\ fields\ of\ a\ BoxList.}}
\DoxyCodeLine{00999\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01000\ \textcolor{stringliteral}{\ \ Args:}}
\DoxyCodeLine{01001\ \textcolor{stringliteral}{\ \ \ \ boxlist:\ A\ BoxList\ }\textcolor{keyword}{with}\ arbitrary\ of\ number\ of\ boxes.}
\DoxyCodeLine{01002\ \ \ \ \ num\_boxes:\ First\ num\_boxes\ \textcolor{keywordflow}{in}\ boxlist\ are\ kept.}
\DoxyCodeLine{01003\ \ \ \ \ \ \ The\ fields\ are\ zero-\/padded\ \textcolor{keywordflow}{if}\ num\_boxes\ \textcolor{keywordflow}{is}\ bigger\ than\ the}
\DoxyCodeLine{01004\ \ \ \ \ \ \ actual\ number\ of\ boxes.}
\DoxyCodeLine{01005\ \ \ \ \ scope:\ name\ scope.}
\DoxyCodeLine{01006\ }
\DoxyCodeLine{01007\ \ \ Returns:}
\DoxyCodeLine{01008\ \ \ \ \ BoxList\ \textcolor{keyword}{with}\ all\ fields\ padded\ \textcolor{keywordflow}{or}\ clipped.}
\DoxyCodeLine{01009\ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{01010\ \textcolor{stringliteral}{\ \ }\textcolor{keyword}{with}\ tf.name\_scope(scope,\ \textcolor{stringliteral}{'PadOrClipBoxList'}):}
\DoxyCodeLine{01011\ \ \ \ \ subboxlist\ =\ box\_list.BoxList(shape\_utils.pad\_or\_clip\_tensor(}
\DoxyCodeLine{01012\ \ \ \ \ \ \ \ \ boxlist.get(),\ num\_boxes))}
\DoxyCodeLine{01013\ \ \ \ \ \textcolor{keywordflow}{for}\ field\ \textcolor{keywordflow}{in}\ boxlist.get\_extra\_fields():}
\DoxyCodeLine{01014\ \ \ \ \ \ \ subfield\ =\ shape\_utils.pad\_or\_clip\_tensor(}
\DoxyCodeLine{01015\ \ \ \ \ \ \ \ \ \ \ boxlist.get\_field(field),\ num\_boxes)}
\DoxyCodeLine{01016\ \ \ \ \ \ \ subboxlist.add\_field(field,\ subfield)}
\DoxyCodeLine{01017\ \ \ \ \ \textcolor{keywordflow}{return}\ subboxlist}
\DoxyCodeLine{01018\ }
\DoxyCodeLine{01019\ }

\end{DoxyCode}
\Hypertarget{namespacedetection__utils_1_1core_1_1box__list__ops_ac97746ffdde0c48bd2bad8c439c6bd3c}\label{namespacedetection__utils_1_1core_1_1box__list__ops_ac97746ffdde0c48bd2bad8c439c6bd3c} 
\index{detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}!prune\_completely\_outside\_window@{prune\_completely\_outside\_window}}
\index{prune\_completely\_outside\_window@{prune\_completely\_outside\_window}!detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}}
\doxysubsubsection{\texorpdfstring{prune\_completely\_outside\_window()}{prune\_completely\_outside\_window()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+core.\+box\+\_\+list\+\_\+ops.\+prune\+\_\+completely\+\_\+outside\+\_\+window (\begin{DoxyParamCaption}\item[{}]{boxlist,  }\item[{}]{window,  }\item[{}]{scope = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Prunes bounding boxes that fall completely outside of the given window.

The function clip_to_window prunes bounding boxes that fall
completely outside the window, but also clips any bounding boxes that
partially overflow. This function does not clip partially overflowing boxes.

Args:
  boxlist: a BoxList holding M_in boxes.
  window: a float tensor of shape [4] representing [ymin, xmin, ymax, xmax]
    of the window
  scope: name scope.

Returns:
  pruned_boxlist: a new BoxList with all bounding boxes partially or fully in
    the window.
  valid_indices: a tensor with shape [M_out] indexing the valid bounding boxes
   in the input tensor.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{box__list__ops_8py_source_l00178}{178}} of file \mbox{\hyperlink{box__list__ops_8py_source}{box\+\_\+list\+\_\+ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00178\ \textcolor{keyword}{def\ }prune\_completely\_outside\_window(boxlist,\ window,\ scope=None):}
\DoxyCodeLine{00179\ \ \ \textcolor{stringliteral}{"{}"{}"{}Prunes\ bounding\ boxes\ that\ fall\ completely\ outside\ of\ the\ given\ window.}}
\DoxyCodeLine{00180\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00181\ \textcolor{stringliteral}{\ \ The\ function\ clip\_to\_window\ prunes\ bounding\ boxes\ that\ fall}}
\DoxyCodeLine{00182\ \textcolor{stringliteral}{\ \ completely\ outside\ the\ window,\ but\ also\ clips\ any\ bounding\ boxes\ that}}
\DoxyCodeLine{00183\ \textcolor{stringliteral}{\ \ partially\ overflow.\ This\ function\ does\ }\textcolor{keywordflow}{not}\ clip\ partially\ overflowing\ boxes.}
\DoxyCodeLine{00184\ }
\DoxyCodeLine{00185\ \ \ Args:}
\DoxyCodeLine{00186\ \ \ \ \ boxlist:\ a\ BoxList\ holding\ M\_in\ boxes.}
\DoxyCodeLine{00187\ \ \ \ \ window:\ a\ float\ tensor\ of\ shape\ [4]\ representing\ [ymin,\ xmin,\ ymax,\ xmax]}
\DoxyCodeLine{00188\ \ \ \ \ \ \ of\ the\ window}
\DoxyCodeLine{00189\ \ \ \ \ scope:\ name\ scope.}
\DoxyCodeLine{00190\ }
\DoxyCodeLine{00191\ \ \ Returns:}
\DoxyCodeLine{00192\ \ \ \ \ pruned\_boxlist:\ a\ new\ BoxList\ \textcolor{keyword}{with}\ all\ bounding\ boxes\ partially\ \textcolor{keywordflow}{or}\ fully\ \textcolor{keywordflow}{in}}
\DoxyCodeLine{00193\ \ \ \ \ \ \ the\ window.}
\DoxyCodeLine{00194\ \ \ \ \ valid\_indices:\ a\ tensor\ \textcolor{keyword}{with}\ shape\ [M\_out]\ indexing\ the\ valid\ bounding\ boxes}
\DoxyCodeLine{00195\ \ \ \ \ \ \textcolor{keywordflow}{in}\ the\ input\ tensor.}
\DoxyCodeLine{00196\ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{00197\ \textcolor{stringliteral}{\ \ }\textcolor{keyword}{with}\ tf.name\_scope(scope,\ \textcolor{stringliteral}{'PruneCompleteleyOutsideWindow'}):}
\DoxyCodeLine{00198\ \ \ \ \ y\_min,\ x\_min,\ y\_max,\ x\_max\ =\ tf.split(}
\DoxyCodeLine{00199\ \ \ \ \ \ \ \ \ value=boxlist.get(),\ num\_or\_size\_splits=4,\ axis=1)}
\DoxyCodeLine{00200\ \ \ \ \ win\_y\_min,\ win\_x\_min,\ win\_y\_max,\ win\_x\_max\ =\ tf.unstack(window)}
\DoxyCodeLine{00201\ \ \ \ \ coordinate\_violations\ =\ tf.concat([}
\DoxyCodeLine{00202\ \ \ \ \ \ \ \ \ tf.greater\_equal(y\_min,\ win\_y\_max),\ tf.greater\_equal(x\_min,\ win\_x\_max),}
\DoxyCodeLine{00203\ \ \ \ \ \ \ \ \ tf.less\_equal(y\_max,\ win\_y\_min),\ tf.less\_equal(x\_max,\ win\_x\_min)}
\DoxyCodeLine{00204\ \ \ \ \ ],\ 1)}
\DoxyCodeLine{00205\ \ \ \ \ valid\_indices\ =\ tf.reshape(}
\DoxyCodeLine{00206\ \ \ \ \ \ \ \ \ tf.where(tf.logical\_not(tf.reduce\_any(coordinate\_violations,\ 1))),\ [-\/1])}
\DoxyCodeLine{00207\ \ \ \ \ \textcolor{keywordflow}{return}\ gather(boxlist,\ valid\_indices),\ valid\_indices}
\DoxyCodeLine{00208\ }
\DoxyCodeLine{00209\ }

\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d9/da1/namespacedetection__utils_1_1core_1_1box__list__ops_ac97746ffdde0c48bd2bad8c439c6bd3c_cgraph}
\end{center}
\end{figure}
\Hypertarget{namespacedetection__utils_1_1core_1_1box__list__ops_a71b57b4bfadf9a8c24875f06c894ec79}\label{namespacedetection__utils_1_1core_1_1box__list__ops_a71b57b4bfadf9a8c24875f06c894ec79} 
\index{detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}!prune\_non\_overlapping\_boxes@{prune\_non\_overlapping\_boxes}}
\index{prune\_non\_overlapping\_boxes@{prune\_non\_overlapping\_boxes}!detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}}
\doxysubsubsection{\texorpdfstring{prune\_non\_overlapping\_boxes()}{prune\_non\_overlapping\_boxes()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+core.\+box\+\_\+list\+\_\+ops.\+prune\+\_\+non\+\_\+overlapping\+\_\+boxes (\begin{DoxyParamCaption}\item[{}]{boxlist1,  }\item[{}]{boxlist2,  }\item[{}]{min\+\_\+overlap = {\ttfamily 0.0},  }\item[{}]{scope = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Prunes the boxes in boxlist1 that overlap less than thresh with boxlist2.

For each box in boxlist1, we want its IOA to be more than minoverlap with
at least one of the boxes in boxlist2. If it does not, we remove it.

Args:
  boxlist1: BoxList holding N boxes.
  boxlist2: BoxList holding M boxes.
  min_overlap: Minimum required overlap between boxes, to count them as
              overlapping.
  scope: name scope.

Returns:
  new_boxlist1: A pruned boxlist with size [N', 4].
  keep_inds: A tensor with shape [N'] indexing kept bounding boxes in the
    first input BoxList `boxlist1`.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{box__list__ops_8py_source_l00324}{324}} of file \mbox{\hyperlink{box__list__ops_8py_source}{box\+\_\+list\+\_\+ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00325\ \ \ \ \ boxlist1,\ boxlist2,\ min\_overlap=0.0,\ scope=\textcolor{keywordtype}{None}):}
\DoxyCodeLine{00326\ \ \ \textcolor{stringliteral}{"{}"{}"{}Prunes\ the\ boxes\ in\ boxlist1\ that\ overlap\ less\ than\ thresh\ with\ boxlist2.}}
\DoxyCodeLine{00327\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00328\ \textcolor{stringliteral}{\ \ For\ each\ box\ }\textcolor{keywordflow}{in}\ boxlist1,\ we\ want\ its\ IOA\ to\ be\ more\ than\ minoverlap\ \textcolor{keyword}{with}}
\DoxyCodeLine{00329\ \ \ at\ least\ one\ of\ the\ boxes\ \textcolor{keywordflow}{in}\ boxlist2.\ If\ it\ does\ \textcolor{keywordflow}{not},\ we\ remove\ it.}
\DoxyCodeLine{00330\ }
\DoxyCodeLine{00331\ \ \ Args:}
\DoxyCodeLine{00332\ \ \ \ \ boxlist1:\ BoxList\ holding\ N\ boxes.}
\DoxyCodeLine{00333\ \ \ \ \ boxlist2:\ BoxList\ holding\ M\ boxes.}
\DoxyCodeLine{00334\ \ \ \ \ min\_overlap:\ Minimum\ required\ overlap\ between\ boxes,\ to\ count\ them\ \textcolor{keyword}{as}}
\DoxyCodeLine{00335\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ overlapping.}
\DoxyCodeLine{00336\ \ \ \ \ scope:\ name\ scope.}
\DoxyCodeLine{00337\ }
\DoxyCodeLine{00338\ \ \ Returns:}
\DoxyCodeLine{00339\ \ \ \ \ new\_boxlist1:\ A\ pruned\ boxlist\ \textcolor{keyword}{with}\ size\ [N\textcolor{stringliteral}{',\ 4].}}
\DoxyCodeLine{00340\ \textcolor{stringliteral}{\ \ \ \ keep\_inds:\ A\ tensor\ }\textcolor{keyword}{with}\ shape\ [N\textcolor{stringliteral}{']\ indexing\ kept\ bounding\ boxes\ in\ the}}
\DoxyCodeLine{00341\ \textcolor{stringliteral}{\ \ \ \ \ \ first\ input\ BoxList\ \`{}boxlist1\`{}.}}
\DoxyCodeLine{00342\ \textcolor{stringliteral}{\ \ "{}"{}"{}}}
\DoxyCodeLine{00343\ \textcolor{stringliteral}{\ \ }\textcolor{keyword}{with}\ tf.name\_scope(scope,\ \textcolor{stringliteral}{'PruneNonOverlappingBoxes'}):}
\DoxyCodeLine{00344\ \ \ \ \ ioa\_\ =\ ioa(boxlist2,\ boxlist1)\ \ \textcolor{comment}{\#\ [M,\ N]\ tensor}}
\DoxyCodeLine{00345\ \ \ \ \ ioa\_\ =\ tf.reduce\_max(ioa\_,\ reduction\_indices=[0])\ \ \textcolor{comment}{\#\ [N]\ tensor}}
\DoxyCodeLine{00346\ \ \ \ \ keep\_bool\ =\ tf.greater\_equal(ioa\_,\ tf.constant(min\_overlap))}
\DoxyCodeLine{00347\ \ \ \ \ keep\_inds\ =\ tf.squeeze(tf.where(keep\_bool),\ axis=[1])}
\DoxyCodeLine{00348\ \ \ \ \ new\_boxlist1\ =\ gather(boxlist1,\ keep\_inds)}
\DoxyCodeLine{00349\ \ \ \ \ \textcolor{keywordflow}{return}\ new\_boxlist1,\ keep\_inds}
\DoxyCodeLine{00350\ }
\DoxyCodeLine{00351\ }

\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d9/da1/namespacedetection__utils_1_1core_1_1box__list__ops_a71b57b4bfadf9a8c24875f06c894ec79_cgraph}
\end{center}
\end{figure}
\Hypertarget{namespacedetection__utils_1_1core_1_1box__list__ops_a8cce2ae473046db81897506796042133}\label{namespacedetection__utils_1_1core_1_1box__list__ops_a8cce2ae473046db81897506796042133} 
\index{detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}!prune\_outside\_window@{prune\_outside\_window}}
\index{prune\_outside\_window@{prune\_outside\_window}!detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}}
\doxysubsubsection{\texorpdfstring{prune\_outside\_window()}{prune\_outside\_window()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+core.\+box\+\_\+list\+\_\+ops.\+prune\+\_\+outside\+\_\+window (\begin{DoxyParamCaption}\item[{}]{boxlist,  }\item[{}]{window,  }\item[{}]{scope = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Prunes bounding boxes that fall outside a given window.

This function prunes bounding boxes that even partially fall outside the given
window. See also clip_to_window which only prunes bounding boxes that fall
completely outside the window, and clips any bounding boxes that partially
overflow.

Args:
  boxlist: a BoxList holding M_in boxes.
  window: a float tensor of shape [4] representing [ymin, xmin, ymax, xmax]
    of the window
  scope: name scope.

Returns:
  pruned_corners: a tensor with shape [M_out, 4] where M_out <= M_in
  valid_indices: a tensor with shape [M_out] indexing the valid bounding boxes
   in the input tensor.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{box__list__ops_8py_source_l00146}{146}} of file \mbox{\hyperlink{box__list__ops_8py_source}{box\+\_\+list\+\_\+ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00146\ \textcolor{keyword}{def\ }prune\_outside\_window(boxlist,\ window,\ scope=None):}
\DoxyCodeLine{00147\ \ \ \textcolor{stringliteral}{"{}"{}"{}Prunes\ bounding\ boxes\ that\ fall\ outside\ a\ given\ window.}}
\DoxyCodeLine{00148\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00149\ \textcolor{stringliteral}{\ \ This\ function\ prunes\ bounding\ boxes\ that\ even\ partially\ fall\ outside\ the\ given}}
\DoxyCodeLine{00150\ \textcolor{stringliteral}{\ \ window.\ See\ also\ clip\_to\_window\ which\ only\ prunes\ bounding\ boxes\ that\ fall}}
\DoxyCodeLine{00151\ \textcolor{stringliteral}{\ \ completely\ outside\ the\ window,\ }\textcolor{keywordflow}{and}\ clips\ any\ bounding\ boxes\ that\ partially}
\DoxyCodeLine{00152\ \ \ overflow.}
\DoxyCodeLine{00153\ }
\DoxyCodeLine{00154\ \ \ Args:}
\DoxyCodeLine{00155\ \ \ \ \ boxlist:\ a\ BoxList\ holding\ M\_in\ boxes.}
\DoxyCodeLine{00156\ \ \ \ \ window:\ a\ float\ tensor\ of\ shape\ [4]\ representing\ [ymin,\ xmin,\ ymax,\ xmax]}
\DoxyCodeLine{00157\ \ \ \ \ \ \ of\ the\ window}
\DoxyCodeLine{00158\ \ \ \ \ scope:\ name\ scope.}
\DoxyCodeLine{00159\ }
\DoxyCodeLine{00160\ \ \ Returns:}
\DoxyCodeLine{00161\ \ \ \ \ pruned\_corners:\ a\ tensor\ \textcolor{keyword}{with}\ shape\ [M\_out,\ 4]\ where\ M\_out\ <=\ M\_in}
\DoxyCodeLine{00162\ \ \ \ \ valid\_indices:\ a\ tensor\ \textcolor{keyword}{with}\ shape\ [M\_out]\ indexing\ the\ valid\ bounding\ boxes}
\DoxyCodeLine{00163\ \ \ \ \ \ \textcolor{keywordflow}{in}\ the\ input\ tensor.}
\DoxyCodeLine{00164\ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{00165\ \textcolor{stringliteral}{\ \ }\textcolor{keyword}{with}\ tf.name\_scope(scope,\ \textcolor{stringliteral}{'PruneOutsideWindow'}):}
\DoxyCodeLine{00166\ \ \ \ \ y\_min,\ x\_min,\ y\_max,\ x\_max\ =\ tf.split(}
\DoxyCodeLine{00167\ \ \ \ \ \ \ \ \ value=boxlist.get(),\ num\_or\_size\_splits=4,\ axis=1)}
\DoxyCodeLine{00168\ \ \ \ \ win\_y\_min,\ win\_x\_min,\ win\_y\_max,\ win\_x\_max\ =\ tf.unstack(window)}
\DoxyCodeLine{00169\ \ \ \ \ coordinate\_violations\ =\ tf.concat([}
\DoxyCodeLine{00170\ \ \ \ \ \ \ \ \ tf.less(y\_min,\ win\_y\_min),\ tf.less(x\_min,\ win\_x\_min),}
\DoxyCodeLine{00171\ \ \ \ \ \ \ \ \ tf.greater(y\_max,\ win\_y\_max),\ tf.greater(x\_max,\ win\_x\_max)}
\DoxyCodeLine{00172\ \ \ \ \ ],\ 1)}
\DoxyCodeLine{00173\ \ \ \ \ valid\_indices\ =\ tf.reshape(}
\DoxyCodeLine{00174\ \ \ \ \ \ \ \ \ tf.where(tf.logical\_not(tf.reduce\_any(coordinate\_violations,\ 1))),\ [-\/1])}
\DoxyCodeLine{00175\ \ \ \ \ \textcolor{keywordflow}{return}\ gather(boxlist,\ valid\_indices),\ valid\_indices}
\DoxyCodeLine{00176\ }
\DoxyCodeLine{00177\ }

\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d9/da1/namespacedetection__utils_1_1core_1_1box__list__ops_a8cce2ae473046db81897506796042133_cgraph}
\end{center}
\end{figure}
\Hypertarget{namespacedetection__utils_1_1core_1_1box__list__ops_a121943718c068c50e17a0dbbde02b17e}\label{namespacedetection__utils_1_1core_1_1box__list__ops_a121943718c068c50e17a0dbbde02b17e} 
\index{detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}!prune\_small\_boxes@{prune\_small\_boxes}}
\index{prune\_small\_boxes@{prune\_small\_boxes}!detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}}
\doxysubsubsection{\texorpdfstring{prune\_small\_boxes()}{prune\_small\_boxes()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+core.\+box\+\_\+list\+\_\+ops.\+prune\+\_\+small\+\_\+boxes (\begin{DoxyParamCaption}\item[{}]{boxlist,  }\item[{}]{min\+\_\+side,  }\item[{}]{scope = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Prunes small boxes in the boxlist which have a side smaller than min_side.

Args:
  boxlist: BoxList holding N boxes.
  min_side: Minimum width AND height of box to survive pruning.
  scope: name scope.

Returns:
  A pruned boxlist.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{box__list__ops_8py_source_l00352}{352}} of file \mbox{\hyperlink{box__list__ops_8py_source}{box\+\_\+list\+\_\+ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00352\ \textcolor{keyword}{def\ }prune\_small\_boxes(boxlist,\ min\_side,\ scope=None):}
\DoxyCodeLine{00353\ \ \ \textcolor{stringliteral}{"{}"{}"{}Prunes\ small\ boxes\ in\ the\ boxlist\ which\ have\ a\ side\ smaller\ than\ min\_side.}}
\DoxyCodeLine{00354\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00355\ \textcolor{stringliteral}{\ \ Args:}}
\DoxyCodeLine{00356\ \textcolor{stringliteral}{\ \ \ \ boxlist:\ BoxList\ holding\ N\ boxes.}}
\DoxyCodeLine{00357\ \textcolor{stringliteral}{\ \ \ \ min\_side:\ Minimum\ width\ AND\ height\ of\ box\ to\ survive\ pruning.}}
\DoxyCodeLine{00358\ \textcolor{stringliteral}{\ \ \ \ scope:\ name\ scope.}}
\DoxyCodeLine{00359\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00360\ \textcolor{stringliteral}{\ \ Returns:}}
\DoxyCodeLine{00361\ \textcolor{stringliteral}{\ \ \ \ A\ pruned\ boxlist.}}
\DoxyCodeLine{00362\ \textcolor{stringliteral}{\ \ "{}"{}"{}}}
\DoxyCodeLine{00363\ \textcolor{stringliteral}{\ \ }\textcolor{keyword}{with}\ tf.name\_scope(scope,\ \textcolor{stringliteral}{'PruneSmallBoxes'}):}
\DoxyCodeLine{00364\ \ \ \ \ height,\ width\ =\ height\_width(boxlist)}
\DoxyCodeLine{00365\ \ \ \ \ is\_valid\ =\ tf.logical\_and(tf.greater\_equal(width,\ min\_side),}
\DoxyCodeLine{00366\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ tf.greater\_equal(height,\ min\_side))}
\DoxyCodeLine{00367\ \ \ \ \ \textcolor{keywordflow}{return}\ gather(boxlist,\ tf.reshape(tf.where(is\_valid),\ [-\/1]))}
\DoxyCodeLine{00368\ }
\DoxyCodeLine{00369\ }

\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d9/da1/namespacedetection__utils_1_1core_1_1box__list__ops_a121943718c068c50e17a0dbbde02b17e_cgraph}
\end{center}
\end{figure}
\Hypertarget{namespacedetection__utils_1_1core_1_1box__list__ops_a7763ebbaf43a4450d6ae5d0fe88398a7}\label{namespacedetection__utils_1_1core_1_1box__list__ops_a7763ebbaf43a4450d6ae5d0fe88398a7} 
\index{detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}!refine\_boxes@{refine\_boxes}}
\index{refine\_boxes@{refine\_boxes}!detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}}
\doxysubsubsection{\texorpdfstring{refine\_boxes()}{refine\_boxes()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+core.\+box\+\_\+list\+\_\+ops.\+refine\+\_\+boxes (\begin{DoxyParamCaption}\item[{}]{pool\+\_\+boxes,  }\item[{}]{nms\+\_\+iou\+\_\+thresh,  }\item[{}]{nms\+\_\+max\+\_\+detections,  }\item[{}]{voting\+\_\+iou\+\_\+thresh = {\ttfamily 0.5} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Refines a pool of boxes using non max suppression and box voting.

Args:
  pool_boxes: (BoxList) A collection of boxes to be refined. pool_boxes must
    have a rank 1 'scores' field.
  nms_iou_thresh: (float scalar) iou threshold for non max suppression (NMS).
  nms_max_detections: (int scalar) maximum output size for NMS.
  voting_iou_thresh: (float scalar) iou threshold for box voting.

Returns:
  BoxList of refined boxes.

Raises:
  ValueError: if
    a) nms_iou_thresh or voting_iou_thresh is not in [0, 1].
    b) pool_boxes is not a BoxList.
    c) pool_boxes does not have a scores field.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{box__list__ops_8py_source_l00897}{897}} of file \mbox{\hyperlink{box__list__ops_8py_source}{box\+\_\+list\+\_\+ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00900\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ voting\_iou\_thresh=0.5):}
\DoxyCodeLine{00901\ \ \ \textcolor{stringliteral}{"{}"{}"{}Refines\ a\ pool\ of\ boxes\ using\ non\ max\ suppression\ and\ box\ voting.}}
\DoxyCodeLine{00902\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00903\ \textcolor{stringliteral}{\ \ Args:}}
\DoxyCodeLine{00904\ \textcolor{stringliteral}{\ \ \ \ pool\_boxes:\ (BoxList)\ A\ collection\ of\ boxes\ to\ be\ refined.\ pool\_boxes\ must}}
\DoxyCodeLine{00905\ \textcolor{stringliteral}{\ \ \ \ \ \ have\ a\ rank\ 1\ 'scores'}\ field.}
\DoxyCodeLine{00906\ \ \ \ \ nms\_iou\_thresh:\ (float\ scalar)\ iou\ threshold\ \textcolor{keywordflow}{for}\ non\ max\ suppression\ (NMS).}
\DoxyCodeLine{00907\ \ \ \ \ nms\_max\_detections:\ (int\ scalar)\ maximum\ output\ size\ \textcolor{keywordflow}{for}\ NMS.}
\DoxyCodeLine{00908\ \ \ \ \ voting\_iou\_thresh:\ (float\ scalar)\ iou\ threshold\ \textcolor{keywordflow}{for}\ box\ voting.}
\DoxyCodeLine{00909\ }
\DoxyCodeLine{00910\ \ \ Returns:}
\DoxyCodeLine{00911\ \ \ \ \ BoxList\ of\ refined\ boxes.}
\DoxyCodeLine{00912\ }
\DoxyCodeLine{00913\ \ \ Raises:}
\DoxyCodeLine{00914\ \ \ \ \ ValueError:\ \textcolor{keywordflow}{if}}
\DoxyCodeLine{00915\ \ \ \ \ \ \ a)\ nms\_iou\_thresh\ \textcolor{keywordflow}{or}\ voting\_iou\_thresh\ \textcolor{keywordflow}{is}\ \textcolor{keywordflow}{not}\ \textcolor{keywordflow}{in}\ [0,\ 1].}
\DoxyCodeLine{00916\ \ \ \ \ \ \ b)\ pool\_boxes\ \textcolor{keywordflow}{is}\ \textcolor{keywordflow}{not}\ a\ BoxList.}
\DoxyCodeLine{00917\ \ \ \ \ \ \ c)\ pool\_boxes\ does\ \textcolor{keywordflow}{not}\ have\ a\ scores\ field.}
\DoxyCodeLine{00918\ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{00919\ \textcolor{stringliteral}{\ \ }\textcolor{keywordflow}{if}\ \textcolor{keywordflow}{not}\ 0.0\ <=\ nms\_iou\_thresh\ <=\ 1.0:}
\DoxyCodeLine{00920\ \ \ \ \ \textcolor{keywordflow}{raise}\ ValueError(\textcolor{stringliteral}{'nms\_iou\_thresh\ must\ be\ between\ 0\ and\ 1'})}
\DoxyCodeLine{00921\ \ \ \textcolor{keywordflow}{if}\ \textcolor{keywordflow}{not}\ 0.0\ <=\ voting\_iou\_thresh\ <=\ 1.0:}
\DoxyCodeLine{00922\ \ \ \ \ \textcolor{keywordflow}{raise}\ ValueError(\textcolor{stringliteral}{'voting\_iou\_thresh\ must\ be\ between\ 0\ and\ 1'})}
\DoxyCodeLine{00923\ \ \ \textcolor{keywordflow}{if}\ \textcolor{keywordflow}{not}\ isinstance(pool\_boxes,\ box\_list.BoxList):}
\DoxyCodeLine{00924\ \ \ \ \ \textcolor{keywordflow}{raise}\ ValueError(\textcolor{stringliteral}{'pool\_boxes\ must\ be\ a\ BoxList'})}
\DoxyCodeLine{00925\ \ \ \textcolor{keywordflow}{if}\ \textcolor{keywordflow}{not}\ pool\_boxes.has\_field(\textcolor{stringliteral}{'scores'}):}
\DoxyCodeLine{00926\ \ \ \ \ \textcolor{keywordflow}{raise}\ ValueError(\textcolor{stringliteral}{'pool\_boxes\ must\ have\ a\ \(\backslash\)'scores\(\backslash\)'\ field'})}
\DoxyCodeLine{00927\ }
\DoxyCodeLine{00928\ \ \ nms\_boxes\ =\ non\_max\_suppression(}
\DoxyCodeLine{00929\ \ \ \ \ \ \ pool\_boxes,\ nms\_iou\_thresh,\ nms\_max\_detections)}
\DoxyCodeLine{00930\ \ \ \textcolor{keywordflow}{return}\ box\_voting(nms\_boxes,\ pool\_boxes,\ voting\_iou\_thresh)}
\DoxyCodeLine{00931\ }
\DoxyCodeLine{00932\ }

\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d9/da1/namespacedetection__utils_1_1core_1_1box__list__ops_a7763ebbaf43a4450d6ae5d0fe88398a7_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d9/da1/namespacedetection__utils_1_1core_1_1box__list__ops_a7763ebbaf43a4450d6ae5d0fe88398a7_icgraph}
\end{center}
\end{figure}
\Hypertarget{namespacedetection__utils_1_1core_1_1box__list__ops_a94cd2ba48717a3b24c2889ac73e749f9}\label{namespacedetection__utils_1_1core_1_1box__list__ops_a94cd2ba48717a3b24c2889ac73e749f9} 
\index{detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}!refine\_boxes\_multi\_class@{refine\_boxes\_multi\_class}}
\index{refine\_boxes\_multi\_class@{refine\_boxes\_multi\_class}!detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}}
\doxysubsubsection{\texorpdfstring{refine\_boxes\_multi\_class()}{refine\_boxes\_multi\_class()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+core.\+box\+\_\+list\+\_\+ops.\+refine\+\_\+boxes\+\_\+multi\+\_\+class (\begin{DoxyParamCaption}\item[{}]{pool\+\_\+boxes,  }\item[{}]{num\+\_\+classes,  }\item[{}]{nms\+\_\+iou\+\_\+thresh,  }\item[{}]{nms\+\_\+max\+\_\+detections,  }\item[{}]{voting\+\_\+iou\+\_\+thresh = {\ttfamily 0.5} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Refines a pool of boxes using non max suppression and box voting.

Box refinement is done independently for each class.

Args:
  pool_boxes: (BoxList) A collection of boxes to be refined. pool_boxes must
    have a rank 1 'scores' field and a rank 1 'classes' field.
  num_classes: (int scalar) Number of classes.
  nms_iou_thresh: (float scalar) iou threshold for non max suppression (NMS).
  nms_max_detections: (int scalar) maximum output size for NMS.
  voting_iou_thresh: (float scalar) iou threshold for box voting.

Returns:
  BoxList of refined boxes.

Raises:
  ValueError: if
    a) nms_iou_thresh or voting_iou_thresh is not in [0, 1].
    b) pool_boxes is not a BoxList.
    c) pool_boxes does not have a scores and classes field.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{box__list__ops_8py_source_l00851}{851}} of file \mbox{\hyperlink{box__list__ops_8py_source}{box\+\_\+list\+\_\+ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00855\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ voting\_iou\_thresh=0.5):}
\DoxyCodeLine{00856\ \ \ \textcolor{stringliteral}{"{}"{}"{}Refines\ a\ pool\ of\ boxes\ using\ non\ max\ suppression\ and\ box\ voting.}}
\DoxyCodeLine{00857\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00858\ \textcolor{stringliteral}{\ \ Box\ refinement\ }\textcolor{keywordflow}{is}\ done\ independently\ \textcolor{keywordflow}{for}\ each\ \textcolor{keyword}{class}.}
\DoxyCodeLine{00859\ }
\DoxyCodeLine{00860\ \ \ Args:}
\DoxyCodeLine{00861\ \ \ \ \ pool\_boxes:\ (BoxList)\ A\ collection\ of\ boxes\ to\ be\ refined.\ pool\_boxes\ must}
\DoxyCodeLine{00862\ \ \ \ \ \ \ have\ a\ rank\ 1\ \textcolor{stringliteral}{'scores'}\ field\ \textcolor{keywordflow}{and}\ a\ rank\ 1\ \textcolor{stringliteral}{'classes'}\ field.}
\DoxyCodeLine{00863\ \ \ \ \ num\_classes:\ (int\ scalar)\ Number\ of\ classes.}
\DoxyCodeLine{00864\ \ \ \ \ nms\_iou\_thresh:\ (float\ scalar)\ iou\ threshold\ \textcolor{keywordflow}{for}\ non\ max\ suppression\ (NMS).}
\DoxyCodeLine{00865\ \ \ \ \ nms\_max\_detections:\ (int\ scalar)\ maximum\ output\ size\ \textcolor{keywordflow}{for}\ NMS.}
\DoxyCodeLine{00866\ \ \ \ \ voting\_iou\_thresh:\ (float\ scalar)\ iou\ threshold\ \textcolor{keywordflow}{for}\ box\ voting.}
\DoxyCodeLine{00867\ }
\DoxyCodeLine{00868\ \ \ Returns:}
\DoxyCodeLine{00869\ \ \ \ \ BoxList\ of\ refined\ boxes.}
\DoxyCodeLine{00870\ }
\DoxyCodeLine{00871\ \ \ Raises:}
\DoxyCodeLine{00872\ \ \ \ \ ValueError:\ \textcolor{keywordflow}{if}}
\DoxyCodeLine{00873\ \ \ \ \ \ \ a)\ nms\_iou\_thresh\ \textcolor{keywordflow}{or}\ voting\_iou\_thresh\ \textcolor{keywordflow}{is}\ \textcolor{keywordflow}{not}\ \textcolor{keywordflow}{in}\ [0,\ 1].}
\DoxyCodeLine{00874\ \ \ \ \ \ \ b)\ pool\_boxes\ \textcolor{keywordflow}{is}\ \textcolor{keywordflow}{not}\ a\ BoxList.}
\DoxyCodeLine{00875\ \ \ \ \ \ \ c)\ pool\_boxes\ does\ \textcolor{keywordflow}{not}\ have\ a\ scores\ \textcolor{keywordflow}{and}\ classes\ field.}
\DoxyCodeLine{00876\ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{00877\ \textcolor{stringliteral}{\ \ }\textcolor{keywordflow}{if}\ \textcolor{keywordflow}{not}\ 0.0\ <=\ nms\_iou\_thresh\ <=\ 1.0:}
\DoxyCodeLine{00878\ \ \ \ \ \textcolor{keywordflow}{raise}\ ValueError(\textcolor{stringliteral}{'nms\_iou\_thresh\ must\ be\ between\ 0\ and\ 1'})}
\DoxyCodeLine{00879\ \ \ \textcolor{keywordflow}{if}\ \textcolor{keywordflow}{not}\ 0.0\ <=\ voting\_iou\_thresh\ <=\ 1.0:}
\DoxyCodeLine{00880\ \ \ \ \ \textcolor{keywordflow}{raise}\ ValueError(\textcolor{stringliteral}{'voting\_iou\_thresh\ must\ be\ between\ 0\ and\ 1'})}
\DoxyCodeLine{00881\ \ \ \textcolor{keywordflow}{if}\ \textcolor{keywordflow}{not}\ isinstance(pool\_boxes,\ box\_list.BoxList):}
\DoxyCodeLine{00882\ \ \ \ \ \textcolor{keywordflow}{raise}\ ValueError(\textcolor{stringliteral}{'pool\_boxes\ must\ be\ a\ BoxList'})}
\DoxyCodeLine{00883\ \ \ \textcolor{keywordflow}{if}\ \textcolor{keywordflow}{not}\ pool\_boxes.has\_field(\textcolor{stringliteral}{'scores'}):}
\DoxyCodeLine{00884\ \ \ \ \ \textcolor{keywordflow}{raise}\ ValueError(\textcolor{stringliteral}{'pool\_boxes\ must\ have\ a\ \(\backslash\)'scores\(\backslash\)'\ field'})}
\DoxyCodeLine{00885\ \ \ \textcolor{keywordflow}{if}\ \textcolor{keywordflow}{not}\ pool\_boxes.has\_field(\textcolor{stringliteral}{'classes'}):}
\DoxyCodeLine{00886\ \ \ \ \ \textcolor{keywordflow}{raise}\ ValueError(\textcolor{stringliteral}{'pool\_boxes\ must\ have\ a\ \(\backslash\)'classes\(\backslash\)'\ field'})}
\DoxyCodeLine{00887\ }
\DoxyCodeLine{00888\ \ \ refined\_boxes\ =\ []}
\DoxyCodeLine{00889\ \ \ \textcolor{keywordflow}{for}\ i\ \textcolor{keywordflow}{in}\ range(num\_classes):}
\DoxyCodeLine{00890\ \ \ \ \ boxes\_class\ =\ filter\_field\_value\_equals(pool\_boxes,\ \textcolor{stringliteral}{'classes'},\ i)}
\DoxyCodeLine{00891\ \ \ \ \ refined\_boxes\_class\ =\ refine\_boxes(boxes\_class,\ nms\_iou\_thresh,}
\DoxyCodeLine{00892\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ nms\_max\_detections,\ voting\_iou\_thresh)}
\DoxyCodeLine{00893\ \ \ \ \ refined\_boxes.append(refined\_boxes\_class)}
\DoxyCodeLine{00894\ \ \ \textcolor{keywordflow}{return}\ sort\_by\_field(concatenate(refined\_boxes),\ \textcolor{stringliteral}{'scores'})}
\DoxyCodeLine{00895\ }
\DoxyCodeLine{00896\ }

\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d9/da1/namespacedetection__utils_1_1core_1_1box__list__ops_a94cd2ba48717a3b24c2889ac73e749f9_cgraph}
\end{center}
\end{figure}
\Hypertarget{namespacedetection__utils_1_1core_1_1box__list__ops_a15808676e298dede166cab386896e46c}\label{namespacedetection__utils_1_1core_1_1box__list__ops_a15808676e298dede166cab386896e46c} 
\index{detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}!sample\_boxes\_by\_jittering@{sample\_boxes\_by\_jittering}}
\index{sample\_boxes\_by\_jittering@{sample\_boxes\_by\_jittering}!detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}}
\doxysubsubsection{\texorpdfstring{sample\_boxes\_by\_jittering()}{sample\_boxes\_by\_jittering()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+core.\+box\+\_\+list\+\_\+ops.\+sample\+\_\+boxes\+\_\+by\+\_\+jittering (\begin{DoxyParamCaption}\item[{}]{boxlist,  }\item[{}]{num\+\_\+boxes\+\_\+to\+\_\+sample,  }\item[{}]{stddev = {\ttfamily 0.1},  }\item[{}]{scope = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Samples num_boxes_to_sample boxes by jittering around boxlist boxes.

It is possible that this function might generate boxes with size 0. The larger
the stddev, this is more probable. For a small stddev of 0.1 this probability
is very small.

Args:
  boxlist: A boxlist containing N boxes in normalized coordinates.
  num_boxes_to_sample: A positive integer containing the number of boxes to
    sample.
  stddev: Standard deviation. This is used to draw random offsets for the
    box corners from a normal distribution. The offset is multiplied by the
    box size so will be larger in terms of pixels for larger boxes.
  scope: Name scope.

Returns:
  sampled_boxlist: A boxlist containing num_boxes_to_sample boxes in
    normalized coordinates.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{box__list__ops_8py_source_l01096}{1096}} of file \mbox{\hyperlink{box__list__ops_8py_source}{box\+\_\+list\+\_\+ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{01099\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ scope=\textcolor{keywordtype}{None}):}
\DoxyCodeLine{01100\ \ \ \textcolor{stringliteral}{"{}"{}"{}Samples\ num\_boxes\_to\_sample\ boxes\ by\ jittering\ around\ boxlist\ boxes.}}
\DoxyCodeLine{01101\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01102\ \textcolor{stringliteral}{\ \ It\ }\textcolor{keywordflow}{is}\ possible\ that\ this\ function\ might\ generate\ boxes\ \textcolor{keyword}{with}\ size\ 0.\ The\ larger}
\DoxyCodeLine{01103\ \ \ the\ stddev,\ this\ \textcolor{keywordflow}{is}\ more\ probable.\ For\ a\ small\ stddev\ of\ 0.1\ this\ probability}
\DoxyCodeLine{01104\ \ \ \textcolor{keywordflow}{is}\ very\ small.}
\DoxyCodeLine{01105\ }
\DoxyCodeLine{01106\ \ \ Args:}
\DoxyCodeLine{01107\ \ \ \ \ boxlist:\ A\ boxlist\ containing\ N\ boxes\ \textcolor{keywordflow}{in}\ normalized\ coordinates.}
\DoxyCodeLine{01108\ \ \ \ \ num\_boxes\_to\_sample:\ A\ positive\ integer\ containing\ the\ number\ of\ boxes\ to}
\DoxyCodeLine{01109\ \ \ \ \ \ \ sample.}
\DoxyCodeLine{01110\ \ \ \ \ stddev:\ Standard\ deviation.\ This\ \textcolor{keywordflow}{is}\ used\ to\ draw\ random\ offsets\ \textcolor{keywordflow}{for}\ the}
\DoxyCodeLine{01111\ \ \ \ \ \ \ box\ corners\ \textcolor{keyword}{from}\ a\ normal\ distribution.\ The\ offset\ \textcolor{keywordflow}{is}\ multiplied\ by\ the}
\DoxyCodeLine{01112\ \ \ \ \ \ \ box\ size\ so\ will\ be\ larger\ \textcolor{keywordflow}{in}\ terms\ of\ pixels\ \textcolor{keywordflow}{for}\ larger\ boxes.}
\DoxyCodeLine{01113\ \ \ \ \ scope:\ Name\ scope.}
\DoxyCodeLine{01114\ }
\DoxyCodeLine{01115\ \ \ Returns:}
\DoxyCodeLine{01116\ \ \ \ \ sampled\_boxlist:\ A\ boxlist\ containing\ num\_boxes\_to\_sample\ boxes\ \textcolor{keywordflow}{in}}
\DoxyCodeLine{01117\ \ \ \ \ \ \ normalized\ coordinates.}
\DoxyCodeLine{01118\ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{01119\ \textcolor{stringliteral}{\ \ }\textcolor{keyword}{with}\ tf.name\_scope(scope,\ \textcolor{stringliteral}{'SampleBoxesByJittering'}):}
\DoxyCodeLine{01120\ \ \ \ \ num\_boxes\ =\ boxlist.num\_boxes()}
\DoxyCodeLine{01121\ \ \ \ \ box\_indices\ =\ tf.random\_uniform(}
\DoxyCodeLine{01122\ \ \ \ \ \ \ \ \ [num\_boxes\_to\_sample],}
\DoxyCodeLine{01123\ \ \ \ \ \ \ \ \ minval=0,}
\DoxyCodeLine{01124\ \ \ \ \ \ \ \ \ maxval=num\_boxes,}
\DoxyCodeLine{01125\ \ \ \ \ \ \ \ \ dtype=tf.int32)}
\DoxyCodeLine{01126\ \ \ \ \ sampled\_boxes\ =\ tf.gather(boxlist.get(),\ box\_indices)}
\DoxyCodeLine{01127\ \ \ \ \ sampled\_boxes\_height\ =\ sampled\_boxes[:,\ 2]\ -\/\ sampled\_boxes[:,\ 0]}
\DoxyCodeLine{01128\ \ \ \ \ sampled\_boxes\_width\ =\ sampled\_boxes[:,\ 3]\ -\/\ sampled\_boxes[:,\ 1]}
\DoxyCodeLine{01129\ \ \ \ \ rand\_miny\_gaussian\ =\ tf.random\_normal([num\_boxes\_to\_sample],\ stddev=stddev)}
\DoxyCodeLine{01130\ \ \ \ \ rand\_minx\_gaussian\ =\ tf.random\_normal([num\_boxes\_to\_sample],\ stddev=stddev)}
\DoxyCodeLine{01131\ \ \ \ \ rand\_maxy\_gaussian\ =\ tf.random\_normal([num\_boxes\_to\_sample],\ stddev=stddev)}
\DoxyCodeLine{01132\ \ \ \ \ rand\_maxx\_gaussian\ =\ tf.random\_normal([num\_boxes\_to\_sample],\ stddev=stddev)}
\DoxyCodeLine{01133\ \ \ \ \ miny\ =\ rand\_miny\_gaussian\ *\ sampled\_boxes\_height\ +\ sampled\_boxes[:,\ 0]}
\DoxyCodeLine{01134\ \ \ \ \ minx\ =\ rand\_minx\_gaussian\ *\ sampled\_boxes\_width\ +\ sampled\_boxes[:,\ 1]}
\DoxyCodeLine{01135\ \ \ \ \ maxy\ =\ rand\_maxy\_gaussian\ *\ sampled\_boxes\_height\ +\ sampled\_boxes[:,\ 2]}
\DoxyCodeLine{01136\ \ \ \ \ maxx\ =\ rand\_maxx\_gaussian\ *\ sampled\_boxes\_width\ +\ sampled\_boxes[:,\ 3]}
\DoxyCodeLine{01137\ \ \ \ \ maxy\ =\ tf.maximum(miny,\ maxy)}
\DoxyCodeLine{01138\ \ \ \ \ maxx\ =\ tf.maximum(minx,\ maxx)}
\DoxyCodeLine{01139\ \ \ \ \ sampled\_boxes\ =\ tf.stack([miny,\ minx,\ maxy,\ maxx],\ axis=1)}
\DoxyCodeLine{01140\ \ \ \ \ sampled\_boxes\ =\ tf.maximum(tf.minimum(sampled\_boxes,\ 1.0),\ 0.0)}
\DoxyCodeLine{01141\ \ \ \ \ \textcolor{keywordflow}{return}\ box\_list.BoxList(sampled\_boxes)}

\end{DoxyCode}
\Hypertarget{namespacedetection__utils_1_1core_1_1box__list__ops_a890e93aacb6d9ba7532251c3047d53fd}\label{namespacedetection__utils_1_1core_1_1box__list__ops_a890e93aacb6d9ba7532251c3047d53fd} 
\index{detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}!scale@{scale}}
\index{scale@{scale}!detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}}
\doxysubsubsection{\texorpdfstring{scale()}{scale()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+core.\+box\+\_\+list\+\_\+ops.\+scale (\begin{DoxyParamCaption}\item[{}]{boxlist,  }\item[{}]{y\+\_\+scale,  }\item[{}]{x\+\_\+scale,  }\item[{}]{scope = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}scale box coordinates in x and y dimensions.

Args:
  boxlist: BoxList holding N boxes
  y_scale: (float) scalar tensor
  x_scale: (float) scalar tensor
  scope: name scope.

Returns:
  boxlist: BoxList holding N boxes
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{box__list__ops_8py_source_l00082}{82}} of file \mbox{\hyperlink{box__list__ops_8py_source}{box\+\_\+list\+\_\+ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00082\ \textcolor{keyword}{def\ }scale(boxlist,\ y\_scale,\ x\_scale,\ scope=None):}
\DoxyCodeLine{00083\ \ \ \textcolor{stringliteral}{"{}"{}"{}scale\ box\ coordinates\ in\ x\ and\ y\ dimensions.}}
\DoxyCodeLine{00084\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00085\ \textcolor{stringliteral}{\ \ Args:}}
\DoxyCodeLine{00086\ \textcolor{stringliteral}{\ \ \ \ boxlist:\ BoxList\ holding\ N\ boxes}}
\DoxyCodeLine{00087\ \textcolor{stringliteral}{\ \ \ \ y\_scale:\ (float)\ scalar\ tensor}}
\DoxyCodeLine{00088\ \textcolor{stringliteral}{\ \ \ \ x\_scale:\ (float)\ scalar\ tensor}}
\DoxyCodeLine{00089\ \textcolor{stringliteral}{\ \ \ \ scope:\ name\ scope.}}
\DoxyCodeLine{00090\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00091\ \textcolor{stringliteral}{\ \ Returns:}}
\DoxyCodeLine{00092\ \textcolor{stringliteral}{\ \ \ \ boxlist:\ BoxList\ holding\ N\ boxes}}
\DoxyCodeLine{00093\ \textcolor{stringliteral}{\ \ "{}"{}"{}}}
\DoxyCodeLine{00094\ \textcolor{stringliteral}{\ \ }\textcolor{keyword}{with}\ tf.name\_scope(scope,\ \textcolor{stringliteral}{'Scale'}):}
\DoxyCodeLine{00095\ \ \ \ \ y\_scale\ =\ tf.cast(y\_scale,\ tf.float32)}
\DoxyCodeLine{00096\ \ \ \ \ x\_scale\ =\ tf.cast(x\_scale,\ tf.float32)}
\DoxyCodeLine{00097\ \ \ \ \ y\_min,\ x\_min,\ y\_max,\ x\_max\ =\ tf.split(}
\DoxyCodeLine{00098\ \ \ \ \ \ \ \ \ value=boxlist.get(),\ num\_or\_size\_splits=4,\ axis=1)}
\DoxyCodeLine{00099\ \ \ \ \ y\_min\ =\ y\_scale\ *\ y\_min}
\DoxyCodeLine{00100\ \ \ \ \ y\_max\ =\ y\_scale\ *\ y\_max}
\DoxyCodeLine{00101\ \ \ \ \ x\_min\ =\ x\_scale\ *\ x\_min}
\DoxyCodeLine{00102\ \ \ \ \ x\_max\ =\ x\_scale\ *\ x\_max}
\DoxyCodeLine{00103\ \ \ \ \ scaled\_boxlist\ =\ box\_list.BoxList(}
\DoxyCodeLine{00104\ \ \ \ \ \ \ \ \ tf.concat([y\_min,\ x\_min,\ y\_max,\ x\_max],\ 1))}
\DoxyCodeLine{00105\ \ \ \ \ \textcolor{keywordflow}{return}\ \_copy\_extra\_fields(scaled\_boxlist,\ boxlist)}
\DoxyCodeLine{00106\ }
\DoxyCodeLine{00107\ }

\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d9/da1/namespacedetection__utils_1_1core_1_1box__list__ops_a890e93aacb6d9ba7532251c3047d53fd_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d9/da1/namespacedetection__utils_1_1core_1_1box__list__ops_a890e93aacb6d9ba7532251c3047d53fd_icgraph}
\end{center}
\end{figure}
\Hypertarget{namespacedetection__utils_1_1core_1_1box__list__ops_a4bce696e11d0578132e9c0e56ab93167}\label{namespacedetection__utils_1_1core_1_1box__list__ops_a4bce696e11d0578132e9c0e56ab93167} 
\index{detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}!select\_random\_box@{select\_random\_box}}
\index{select\_random\_box@{select\_random\_box}!detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}}
\doxysubsubsection{\texorpdfstring{select\_random\_box()}{select\_random\_box()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+core.\+box\+\_\+list\+\_\+ops.\+select\+\_\+random\+\_\+box (\begin{DoxyParamCaption}\item[{}]{boxlist,  }\item[{}]{default\+\_\+box = {\ttfamily None},  }\item[{}]{seed = {\ttfamily None},  }\item[{}]{scope = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Selects a random bounding box from a `BoxList`.

Args:
  boxlist: A BoxList.
  default_box: A [1, 4] float32 tensor. If no boxes are present in `boxlist`,
    this default box will be returned. If None, will use a default box of
    [[-1., -1., -1., -1.]].
  seed: Random seed.
  scope: Name scope.

Returns:
  bbox: A [1, 4] tensor with a random bounding box.
  valid: A bool tensor indicating whether a valid bounding box is returned
    (True) or whether the default box is returned (False).
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{box__list__ops_8py_source_l01020}{1020}} of file \mbox{\hyperlink{box__list__ops_8py_source}{box\+\_\+list\+\_\+ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{01023\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ scope=\textcolor{keywordtype}{None}):}
\DoxyCodeLine{01024\ \ \ \textcolor{stringliteral}{"{}"{}"{}Selects\ a\ random\ bounding\ box\ from\ a\ \`{}BoxList\`{}.}}
\DoxyCodeLine{01025\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01026\ \textcolor{stringliteral}{\ \ Args:}}
\DoxyCodeLine{01027\ \textcolor{stringliteral}{\ \ \ \ boxlist:\ A\ BoxList.}}
\DoxyCodeLine{01028\ \textcolor{stringliteral}{\ \ \ \ default\_box:\ A\ [1,\ 4]\ float32\ tensor.\ If\ no\ boxes\ are\ present\ }\textcolor{keywordflow}{in}\ \`{}boxlist\`{},}
\DoxyCodeLine{01029\ \ \ \ \ \ \ this\ default\ box\ will\ be\ returned.\ If\ \textcolor{keywordtype}{None},\ will\ use\ a\ default\ box\ of}
\DoxyCodeLine{01030\ \ \ \ \ \ \ [[-\/1.,\ -\/1.,\ -\/1.,\ -\/1.]].}
\DoxyCodeLine{01031\ \ \ \ \ seed:\ Random\ seed.}
\DoxyCodeLine{01032\ \ \ \ \ scope:\ Name\ scope.}
\DoxyCodeLine{01033\ }
\DoxyCodeLine{01034\ \ \ Returns:}
\DoxyCodeLine{01035\ \ \ \ \ bbox:\ A\ [1,\ 4]\ tensor\ \textcolor{keyword}{with}\ a\ random\ bounding\ box.}
\DoxyCodeLine{01036\ \ \ \ \ valid:\ A\ bool\ tensor\ indicating\ whether\ a\ valid\ bounding\ box\ \textcolor{keywordflow}{is}\ returned}
\DoxyCodeLine{01037\ \ \ \ \ \ \ (\textcolor{keyword}{True})\ \textcolor{keywordflow}{or}\ whether\ the\ default\ box\ \textcolor{keywordflow}{is}\ returned\ (\textcolor{keyword}{False}).}
\DoxyCodeLine{01038\ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{01039\ \textcolor{stringliteral}{\ \ }\textcolor{keyword}{with}\ tf.name\_scope(scope,\ \textcolor{stringliteral}{'SelectRandomBox'}):}
\DoxyCodeLine{01040\ \ \ \ \ bboxes\ =\ boxlist.get()}
\DoxyCodeLine{01041\ \ \ \ \ combined\_shape\ =\ shape\_utils.combined\_static\_and\_dynamic\_shape(bboxes)}
\DoxyCodeLine{01042\ \ \ \ \ number\_of\_boxes\ =\ combined\_shape[0]}
\DoxyCodeLine{01043\ \ \ \ \ default\_box\ =\ default\_box\ \textcolor{keywordflow}{or}\ tf.constant([[-\/1.,\ -\/1.,\ -\/1.,\ -\/1.]])}
\DoxyCodeLine{01044\ }
\DoxyCodeLine{01045\ \ \ \ \ \textcolor{keyword}{def\ }select\_box():}
\DoxyCodeLine{01046\ \ \ \ \ \ \ random\_index\ =\ tf.random\_uniform([],}
\DoxyCodeLine{01047\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ maxval=number\_of\_boxes,}
\DoxyCodeLine{01048\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ dtype=tf.int32,}
\DoxyCodeLine{01049\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ seed=seed)}
\DoxyCodeLine{01050\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ tf.expand\_dims(bboxes[random\_index],\ axis=0),\ tf.constant(\textcolor{keyword}{True})}
\DoxyCodeLine{01051\ }
\DoxyCodeLine{01052\ \ \ \textcolor{keywordflow}{return}\ tf.cond(}
\DoxyCodeLine{01053\ \ \ \ \ \ \ tf.greater\_equal(number\_of\_boxes,\ 1),}
\DoxyCodeLine{01054\ \ \ \ \ \ \ true\_fn=select\_box,}
\DoxyCodeLine{01055\ \ \ \ \ \ \ false\_fn=\textcolor{keyword}{lambda}:\ (default\_box,\ tf.constant(\textcolor{keyword}{False})))}
\DoxyCodeLine{01056\ }
\DoxyCodeLine{01057\ }

\end{DoxyCode}
\Hypertarget{namespacedetection__utils_1_1core_1_1box__list__ops_a103f0e0e0eeb3193514895e6b2c9ba94}\label{namespacedetection__utils_1_1core_1_1box__list__ops_a103f0e0e0eeb3193514895e6b2c9ba94} 
\index{detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}!sort\_by\_field@{sort\_by\_field}}
\index{sort\_by\_field@{sort\_by\_field}!detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}}
\doxysubsubsection{\texorpdfstring{sort\_by\_field()}{sort\_by\_field()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+core.\+box\+\_\+list\+\_\+ops.\+sort\+\_\+by\+\_\+field (\begin{DoxyParamCaption}\item[{}]{boxlist,  }\item[{}]{field,  }\item[{}]{order = {\ttfamily \mbox{\hyperlink{classdetection__utils_1_1core_1_1box__list__ops_1_1_sort_order_a50eb8b077a78822f0085d91664f9226d}{Sort\+Order.\+descend}}},  }\item[{}]{scope = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Sort boxes and associated fields according to a scalar field.

A common use case is reordering the boxes according to descending scores.

Args:
  boxlist: BoxList holding N boxes.
  field: A BoxList field for sorting and reordering the BoxList.
  order: (Optional) descend or ascend. Default is descend.
  scope: name scope.

Returns:
  sorted_boxlist: A sorted BoxList with the field in the specified order.

Raises:
  ValueError: if specified field does not exist
  ValueError: if the order is not either descend or ascend
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{box__list__ops_8py_source_l00590}{590}} of file \mbox{\hyperlink{box__list__ops_8py_source}{box\+\_\+list\+\_\+ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00590\ \textcolor{keyword}{def\ }sort\_by\_field(boxlist,\ field,\ order=SortOrder.descend,\ scope=None):}
\DoxyCodeLine{00591\ \ \ \textcolor{stringliteral}{"{}"{}"{}Sort\ boxes\ and\ associated\ fields\ according\ to\ a\ scalar\ field.}}
\DoxyCodeLine{00592\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00593\ \textcolor{stringliteral}{\ \ A\ common\ use\ case\ }\textcolor{keywordflow}{is}\ reordering\ the\ boxes\ according\ to\ descending\ scores.}
\DoxyCodeLine{00594\ }
\DoxyCodeLine{00595\ \ \ Args:}
\DoxyCodeLine{00596\ \ \ \ \ boxlist:\ BoxList\ holding\ N\ boxes.}
\DoxyCodeLine{00597\ \ \ \ \ field:\ A\ BoxList\ field\ \textcolor{keywordflow}{for}\ sorting\ \textcolor{keywordflow}{and}\ reordering\ the\ BoxList.}
\DoxyCodeLine{00598\ \ \ \ \ order:\ (Optional)\ descend\ \textcolor{keywordflow}{or}\ ascend.\ Default\ \textcolor{keywordflow}{is}\ descend.}
\DoxyCodeLine{00599\ \ \ \ \ scope:\ name\ scope.}
\DoxyCodeLine{00600\ }
\DoxyCodeLine{00601\ \ \ Returns:}
\DoxyCodeLine{00602\ \ \ \ \ sorted\_boxlist:\ A\ sorted\ BoxList\ \textcolor{keyword}{with}\ the\ field\ \textcolor{keywordflow}{in}\ the\ specified\ order.}
\DoxyCodeLine{00603\ }
\DoxyCodeLine{00604\ \ \ Raises:}
\DoxyCodeLine{00605\ \ \ \ \ ValueError:\ \textcolor{keywordflow}{if}\ specified\ field\ does\ \textcolor{keywordflow}{not}\ exist}
\DoxyCodeLine{00606\ \ \ \ \ ValueError:\ \textcolor{keywordflow}{if}\ the\ order\ \textcolor{keywordflow}{is}\ \textcolor{keywordflow}{not}\ either\ descend\ \textcolor{keywordflow}{or}\ ascend}
\DoxyCodeLine{00607\ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{00608\ \textcolor{stringliteral}{\ \ }\textcolor{keyword}{with}\ tf.name\_scope(scope,\ \textcolor{stringliteral}{'SortByField'}):}
\DoxyCodeLine{00609\ \ \ \ \ \textcolor{keywordflow}{if}\ order\ !=\ SortOrder.descend\ \textcolor{keywordflow}{and}\ order\ !=\ SortOrder.ascend:}
\DoxyCodeLine{00610\ \ \ \ \ \ \ \textcolor{keywordflow}{raise}\ ValueError(\textcolor{stringliteral}{'Invalid\ sort\ order'})}
\DoxyCodeLine{00611\ }
\DoxyCodeLine{00612\ \ \ \ \ field\_to\_sort\ =\ boxlist.get\_field(field)}
\DoxyCodeLine{00613\ \ \ \ \ \textcolor{keywordflow}{if}\ len(field\_to\_sort.shape.as\_list())\ !=\ 1:}
\DoxyCodeLine{00614\ \ \ \ \ \ \ \textcolor{keywordflow}{raise}\ ValueError(\textcolor{stringliteral}{'Field\ should\ have\ rank\ 1'})}
\DoxyCodeLine{00615\ }
\DoxyCodeLine{00616\ \ \ \ \ num\_boxes\ =\ boxlist.num\_boxes()}
\DoxyCodeLine{00617\ \ \ \ \ num\_entries\ =\ tf.size(field\_to\_sort)}
\DoxyCodeLine{00618\ \ \ \ \ length\_assert\ =\ tf.Assert(}
\DoxyCodeLine{00619\ \ \ \ \ \ \ \ \ tf.equal(num\_boxes,\ num\_entries),}
\DoxyCodeLine{00620\ \ \ \ \ \ \ \ \ [\textcolor{stringliteral}{'Incorrect\ field\ size:\ actual\ vs\ expected.'},\ num\_entries,\ num\_boxes])}
\DoxyCodeLine{00621\ }
\DoxyCodeLine{00622\ \ \ \ \ \textcolor{keyword}{with}\ tf.control\_dependencies([length\_assert]):}
\DoxyCodeLine{00623\ \ \ \ \ \ \ \_,\ sorted\_indices\ =\ tf.nn.top\_k(field\_to\_sort,\ num\_boxes,\ sorted=\textcolor{keyword}{True})}
\DoxyCodeLine{00624\ }
\DoxyCodeLine{00625\ \ \ \ \ \textcolor{keywordflow}{if}\ order\ ==\ SortOrder.ascend:}
\DoxyCodeLine{00626\ \ \ \ \ \ \ sorted\_indices\ =\ tf.reverse\_v2(sorted\_indices,\ [0])}
\DoxyCodeLine{00627\ }
\DoxyCodeLine{00628\ \ \ \ \ \textcolor{keywordflow}{return}\ gather(boxlist,\ sorted\_indices)}
\DoxyCodeLine{00629\ }
\DoxyCodeLine{00630\ }

\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d9/da1/namespacedetection__utils_1_1core_1_1box__list__ops_a103f0e0e0eeb3193514895e6b2c9ba94_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d9/da1/namespacedetection__utils_1_1core_1_1box__list__ops_a103f0e0e0eeb3193514895e6b2c9ba94_icgraph}
\end{center}
\end{figure}
\Hypertarget{namespacedetection__utils_1_1core_1_1box__list__ops_a2e9b6ea6358fa09ac69ff5f20e6696ee}\label{namespacedetection__utils_1_1core_1_1box__list__ops_a2e9b6ea6358fa09ac69ff5f20e6696ee} 
\index{detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}!sq\_dist@{sq\_dist}}
\index{sq\_dist@{sq\_dist}!detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}}
\doxysubsubsection{\texorpdfstring{sq\_dist()}{sq\_dist()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+core.\+box\+\_\+list\+\_\+ops.\+sq\+\_\+dist (\begin{DoxyParamCaption}\item[{}]{boxlist1,  }\item[{}]{boxlist2,  }\item[{}]{scope = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Computes the pairwise squared distances between box corners.

This op treats each box as if it were a point in a 4d Euclidean space and
computes pairwise squared distances.

Mathematically, we are given two matrices of box coordinates X and Y,
where X(i,:) is the i'th row of X, containing the 4 numbers defining the
corners of the i'th box in boxlist1. Similarly Y(j,:) corresponds to
boxlist2.  We compute
Z(i,j) = ||X(i,:) - Y(j,:)||^2
       = ||X(i,:)||^2 + ||Y(j,:)||^2 - 2 X(i,:)' * Y(j,:),

Args:
  boxlist1: BoxList holding N boxes
  boxlist2: BoxList holding M boxes
  scope: name scope.

Returns:
  a tensor with shape [N, M] representing pairwise distances
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{box__list__ops_8py_source_l00400}{400}} of file \mbox{\hyperlink{box__list__ops_8py_source}{box\+\_\+list\+\_\+ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00400\ \textcolor{keyword}{def\ }sq\_dist(boxlist1,\ boxlist2,\ scope=None):}
\DoxyCodeLine{00401\ \ \ \textcolor{stringliteral}{"{}"{}"{}Computes\ the\ pairwise\ squared\ distances\ between\ box\ corners.}}
\DoxyCodeLine{00402\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00403\ \textcolor{stringliteral}{\ \ This\ op\ treats\ each\ box\ }\textcolor{keyword}{as}\ \textcolor{keywordflow}{if}\ it\ were\ a\ point\ \textcolor{keywordflow}{in}\ a\ 4d\ Euclidean\ space\ \textcolor{keywordflow}{and}}
\DoxyCodeLine{00404\ \ \ computes\ pairwise\ squared\ distances.}
\DoxyCodeLine{00405\ }
\DoxyCodeLine{00406\ \ \ Mathematically,\ we\ are\ given\ two\ matrices\ of\ box\ coordinates\ X\ \textcolor{keywordflow}{and}\ Y,}
\DoxyCodeLine{00407\ \ \ where\ X(i,:)\ \textcolor{keywordflow}{is}\ the\ i\textcolor{stringliteral}{'th\ row\ of\ X,\ containing\ the\ 4\ numbers\ defining\ the}}
\DoxyCodeLine{00408\ \textcolor{stringliteral}{\ \ corners\ of\ the\ i'th\ box\ in\ boxlist1.\ Similarly\ Y(j,:)\ corresponds\ to}}
\DoxyCodeLine{00409\ \textcolor{stringliteral}{\ \ boxlist2.\ \ We\ compute}}
\DoxyCodeLine{00410\ \textcolor{stringliteral}{\ \ Z(i,j)\ =\ ||X(i,:)\ -\/\ Y(j,:)||\string^2}}
\DoxyCodeLine{00411\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ =\ ||X(i,:)||\string^2\ +\ ||Y(j,:)||\string^2\ -\/\ 2\ X(i,:)'\ *\ Y(j,:),}}
\DoxyCodeLine{00412\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00413\ \textcolor{stringliteral}{\ \ Args:}}
\DoxyCodeLine{00414\ \textcolor{stringliteral}{\ \ \ \ boxlist1:\ BoxList\ holding\ N\ boxes}}
\DoxyCodeLine{00415\ \textcolor{stringliteral}{\ \ \ \ boxlist2:\ BoxList\ holding\ M\ boxes}}
\DoxyCodeLine{00416\ \textcolor{stringliteral}{\ \ \ \ scope:\ name\ scope.}}
\DoxyCodeLine{00417\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00418\ \textcolor{stringliteral}{\ \ Returns:}}
\DoxyCodeLine{00419\ \textcolor{stringliteral}{\ \ \ \ a\ tensor\ }\textcolor{keyword}{with}\ shape\ [N,\ M]\ representing\ pairwise\ distances}
\DoxyCodeLine{00420\ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{00421\ \textcolor{stringliteral}{\ \ }\textcolor{keyword}{with}\ tf.name\_scope(scope,\ \textcolor{stringliteral}{'SqDist'}):}
\DoxyCodeLine{00422\ \ \ \ \ sqnorm1\ =\ tf.reduce\_sum(tf.square(boxlist1.get()),\ 1,\ keep\_dims=\textcolor{keyword}{True})}
\DoxyCodeLine{00423\ \ \ \ \ sqnorm2\ =\ tf.reduce\_sum(tf.square(boxlist2.get()),\ 1,\ keep\_dims=\textcolor{keyword}{True})}
\DoxyCodeLine{00424\ \ \ \ \ innerprod\ =\ tf.matmul(boxlist1.get(),\ boxlist2.get(),}
\DoxyCodeLine{00425\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ transpose\_a=\textcolor{keyword}{False},\ transpose\_b=\textcolor{keyword}{True})}
\DoxyCodeLine{00426\ \ \ \ \ \textcolor{keywordflow}{return}\ sqnorm1\ +\ tf.transpose(sqnorm2)\ -\/\ 2.0\ *\ innerprod}
\DoxyCodeLine{00427\ }
\DoxyCodeLine{00428\ }

\end{DoxyCode}
\Hypertarget{namespacedetection__utils_1_1core_1_1box__list__ops_ada89676fbe54301964c23a14e0260a8c}\label{namespacedetection__utils_1_1core_1_1box__list__ops_ada89676fbe54301964c23a14e0260a8c} 
\index{detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}!to\_absolute\_coordinates@{to\_absolute\_coordinates}}
\index{to\_absolute\_coordinates@{to\_absolute\_coordinates}!detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}}
\doxysubsubsection{\texorpdfstring{to\_absolute\_coordinates()}{to\_absolute\_coordinates()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+core.\+box\+\_\+list\+\_\+ops.\+to\+\_\+absolute\+\_\+coordinates (\begin{DoxyParamCaption}\item[{}]{boxlist,  }\item[{}]{height,  }\item[{}]{width,  }\item[{}]{check\+\_\+range = {\ttfamily True},  }\item[{}]{maximum\+\_\+normalized\+\_\+coordinate = {\ttfamily 1.1},  }\item[{}]{scope = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Converts normalized box coordinates to absolute pixel coordinates.

This function raises an assertion failed error when the maximum box coordinate
value is larger than maximum_normalized_coordinate (in which case coordinates
are already absolute).

Args:
  boxlist: BoxList with coordinates in range [0, 1].
  height: Maximum value for height of absolute box coordinates.
  width: Maximum value for width of absolute box coordinates.
  check_range: If True, checks if the coordinates are normalized or not.
  maximum_normalized_coordinate: Maximum coordinate value to be considered
    as normalized, default to 1.1.
  scope: name scope.

Returns:
  boxlist with absolute coordinates in terms of the image size.\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{box__list__ops_8py_source_l00809}{809}} of file \mbox{\hyperlink{box__list__ops_8py_source}{box\+\_\+list\+\_\+ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00814\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ scope=\textcolor{keywordtype}{None}):}
\DoxyCodeLine{00815\ \ \ \textcolor{stringliteral}{"{}"{}"{}Converts\ normalized\ box\ coordinates\ to\ absolute\ pixel\ coordinates.}}
\DoxyCodeLine{00816\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00817\ \textcolor{stringliteral}{\ \ This\ function\ raises\ an\ assertion\ failed\ error\ when\ the\ maximum\ box\ coordinate}}
\DoxyCodeLine{00818\ \textcolor{stringliteral}{\ \ value\ }\textcolor{keywordflow}{is}\ larger\ than\ maximum\_normalized\_coordinate\ (\textcolor{keywordflow}{in}\ which\ case\ coordinates}
\DoxyCodeLine{00819\ \ \ are\ already\ absolute).}
\DoxyCodeLine{00820\ }
\DoxyCodeLine{00821\ \ \ Args:}
\DoxyCodeLine{00822\ \ \ \ \ boxlist:\ BoxList\ \textcolor{keyword}{with}\ coordinates\ \textcolor{keywordflow}{in}\ range\ [0,\ 1].}
\DoxyCodeLine{00823\ \ \ \ \ height:\ Maximum\ value\ \textcolor{keywordflow}{for}\ height\ of\ absolute\ box\ coordinates.}
\DoxyCodeLine{00824\ \ \ \ \ width:\ Maximum\ value\ \textcolor{keywordflow}{for}\ width\ of\ absolute\ box\ coordinates.}
\DoxyCodeLine{00825\ \ \ \ \ check\_range:\ If\ \textcolor{keyword}{True},\ checks\ \textcolor{keywordflow}{if}\ the\ coordinates\ are\ normalized\ \textcolor{keywordflow}{or}\ \textcolor{keywordflow}{not}.}
\DoxyCodeLine{00826\ \ \ \ \ maximum\_normalized\_coordinate:\ Maximum\ coordinate\ value\ to\ be\ considered}
\DoxyCodeLine{00827\ \ \ \ \ \ \ \textcolor{keyword}{as}\ normalized,\ default\ to\ 1.1.}
\DoxyCodeLine{00828\ \ \ \ \ scope:\ name\ scope.}
\DoxyCodeLine{00829\ }
\DoxyCodeLine{00830\ \ \ Returns:}
\DoxyCodeLine{00831\ \ \ \ \ boxlist\ \textcolor{keyword}{with}\ absolute\ coordinates\ \textcolor{keywordflow}{in}\ terms\ of\ the\ image\ size.}
\DoxyCodeLine{00832\ }
\DoxyCodeLine{00833\ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{00834\ \textcolor{stringliteral}{\ \ }\textcolor{keyword}{with}\ tf.name\_scope(scope,\ \textcolor{stringliteral}{'ToAbsoluteCoordinates'}):}
\DoxyCodeLine{00835\ \ \ \ \ height\ =\ tf.cast(height,\ tf.float32)}
\DoxyCodeLine{00836\ \ \ \ \ width\ =\ tf.cast(width,\ tf.float32)}
\DoxyCodeLine{00837\ }
\DoxyCodeLine{00838\ \ \ \ \ \textcolor{comment}{\#\ Ensure\ range\ of\ input\ boxes\ is\ correct.}}
\DoxyCodeLine{00839\ \ \ \ \ \textcolor{keywordflow}{if}\ check\_range:}
\DoxyCodeLine{00840\ \ \ \ \ \ \ box\_maximum\ =\ tf.reduce\_max(boxlist.get())}
\DoxyCodeLine{00841\ \ \ \ \ \ \ max\_assert\ =\ tf.Assert(}
\DoxyCodeLine{00842\ \ \ \ \ \ \ \ \ \ \ tf.greater\_equal(maximum\_normalized\_coordinate,\ box\_maximum),}
\DoxyCodeLine{00843\ \ \ \ \ \ \ \ \ \ \ [\textcolor{stringliteral}{'maximum\ box\ coordinate\ value\ is\ larger\ '}}
\DoxyCodeLine{00844\ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{'than\ \%f:\ '}\ \%\ maximum\_normalized\_coordinate,\ box\_maximum])}
\DoxyCodeLine{00845\ \ \ \ \ \ \ \textcolor{keyword}{with}\ tf.control\_dependencies([max\_assert]):}
\DoxyCodeLine{00846\ \ \ \ \ \ \ \ \ width\ =\ tf.identity(width)}
\DoxyCodeLine{00847\ }
\DoxyCodeLine{00848\ \ \ \ \ \textcolor{keywordflow}{return}\ scale(boxlist,\ height,\ width)}
\DoxyCodeLine{00849\ }
\DoxyCodeLine{00850\ }

\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d9/da1/namespacedetection__utils_1_1core_1_1box__list__ops_ada89676fbe54301964c23a14e0260a8c_cgraph}
\end{center}
\end{figure}
\Hypertarget{namespacedetection__utils_1_1core_1_1box__list__ops_a8a6b7f0a6aa75c518f14f90c8480c146}\label{namespacedetection__utils_1_1core_1_1box__list__ops_a8a6b7f0a6aa75c518f14f90c8480c146} 
\index{detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}!to\_normalized\_coordinates@{to\_normalized\_coordinates}}
\index{to\_normalized\_coordinates@{to\_normalized\_coordinates}!detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}}
\doxysubsubsection{\texorpdfstring{to\_normalized\_coordinates()}{to\_normalized\_coordinates()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+core.\+box\+\_\+list\+\_\+ops.\+to\+\_\+normalized\+\_\+coordinates (\begin{DoxyParamCaption}\item[{}]{boxlist,  }\item[{}]{height,  }\item[{}]{width,  }\item[{}]{check\+\_\+range = {\ttfamily True},  }\item[{}]{scope = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Converts absolute box coordinates to normalized coordinates in [0, 1].

Usually one uses the dynamic shape of the image or conv-layer tensor:
  boxlist = box_list_ops.to_normalized_coordinates(boxlist,
                                                   tf.shape(images)[1],
                                                   tf.shape(images)[2]),

This function raises an assertion failed error at graph execution time when
the maximum coordinate is smaller than 1.01 (which means that coordinates are
already normalized). The value 1.01 is to deal with small rounding errors.

Args:
  boxlist: BoxList with coordinates in terms of pixel-locations.
  height: Maximum value for height of absolute box coordinates.
  width: Maximum value for width of absolute box coordinates.
  check_range: If True, checks if the coordinates are normalized or not.
  scope: name scope.

Returns:
  boxlist with normalized coordinates in [0, 1].
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{box__list__ops_8py_source_l00772}{772}} of file \mbox{\hyperlink{box__list__ops_8py_source}{box\+\_\+list\+\_\+ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00773\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ check\_range=\textcolor{keyword}{True},\ scope=\textcolor{keywordtype}{None}):}
\DoxyCodeLine{00774\ \ \ \textcolor{stringliteral}{"{}"{}"{}Converts\ absolute\ box\ coordinates\ to\ normalized\ coordinates\ in\ [0,\ 1].}}
\DoxyCodeLine{00775\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00776\ \textcolor{stringliteral}{\ \ Usually\ one\ uses\ the\ dynamic\ shape\ of\ the\ image\ }\textcolor{keywordflow}{or}\ conv-\/layer\ tensor:}
\DoxyCodeLine{00777\ \ \ \ \ boxlist\ =\ box\_list\_ops.to\_normalized\_coordinates(boxlist,}
\DoxyCodeLine{00778\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ tf.shape(images)[1],}
\DoxyCodeLine{00779\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ tf.shape(images)[2]),}
\DoxyCodeLine{00780\ }
\DoxyCodeLine{00781\ \ \ This\ function\ raises\ an\ assertion\ failed\ error\ at\ graph\ execution\ time\ when}
\DoxyCodeLine{00782\ \ \ the\ maximum\ coordinate\ \textcolor{keywordflow}{is}\ smaller\ than\ 1.01\ (which\ means\ that\ coordinates\ are}
\DoxyCodeLine{00783\ \ \ already\ normalized).\ The\ value\ 1.01\ \textcolor{keywordflow}{is}\ to\ deal\ \textcolor{keyword}{with}\ small\ rounding\ errors.}
\DoxyCodeLine{00784\ }
\DoxyCodeLine{00785\ \ \ Args:}
\DoxyCodeLine{00786\ \ \ \ \ boxlist:\ BoxList\ \textcolor{keyword}{with}\ coordinates\ \textcolor{keywordflow}{in}\ terms\ of\ pixel-\/locations.}
\DoxyCodeLine{00787\ \ \ \ \ height:\ Maximum\ value\ \textcolor{keywordflow}{for}\ height\ of\ absolute\ box\ coordinates.}
\DoxyCodeLine{00788\ \ \ \ \ width:\ Maximum\ value\ \textcolor{keywordflow}{for}\ width\ of\ absolute\ box\ coordinates.}
\DoxyCodeLine{00789\ \ \ \ \ check\_range:\ If\ \textcolor{keyword}{True},\ checks\ \textcolor{keywordflow}{if}\ the\ coordinates\ are\ normalized\ \textcolor{keywordflow}{or}\ \textcolor{keywordflow}{not}.}
\DoxyCodeLine{00790\ \ \ \ \ scope:\ name\ scope.}
\DoxyCodeLine{00791\ }
\DoxyCodeLine{00792\ \ \ Returns:}
\DoxyCodeLine{00793\ \ \ \ \ boxlist\ \textcolor{keyword}{with}\ normalized\ coordinates\ \textcolor{keywordflow}{in}\ [0,\ 1].}
\DoxyCodeLine{00794\ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{00795\ \textcolor{stringliteral}{\ \ }\textcolor{keyword}{with}\ tf.name\_scope(scope,\ \textcolor{stringliteral}{'ToNormalizedCoordinates'}):}
\DoxyCodeLine{00796\ \ \ \ \ height\ =\ tf.cast(height,\ tf.float32)}
\DoxyCodeLine{00797\ \ \ \ \ width\ =\ tf.cast(width,\ tf.float32)}
\DoxyCodeLine{00798\ }
\DoxyCodeLine{00799\ \ \ \ \ \textcolor{keywordflow}{if}\ check\_range:}
\DoxyCodeLine{00800\ \ \ \ \ \ \ max\_val\ =\ tf.reduce\_max(boxlist.get())}
\DoxyCodeLine{00801\ \ \ \ \ \ \ max\_assert\ =\ tf.Assert(tf.greater(max\_val,\ 1.01),}
\DoxyCodeLine{00802\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ [\textcolor{stringliteral}{'max\ value\ is\ lower\ than\ 1.01:\ '},\ max\_val])}
\DoxyCodeLine{00803\ \ \ \ \ \ \ \textcolor{keyword}{with}\ tf.control\_dependencies([max\_assert]):}
\DoxyCodeLine{00804\ \ \ \ \ \ \ \ \ width\ =\ tf.identity(width)}
\DoxyCodeLine{00805\ }
\DoxyCodeLine{00806\ \ \ \ \ \textcolor{keywordflow}{return}\ scale(boxlist,\ 1\ /\ height,\ 1\ /\ width)}
\DoxyCodeLine{00807\ }
\DoxyCodeLine{00808\ }

\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d9/da1/namespacedetection__utils_1_1core_1_1box__list__ops_a8a6b7f0a6aa75c518f14f90c8480c146_cgraph}
\end{center}
\end{figure}
\Hypertarget{namespacedetection__utils_1_1core_1_1box__list__ops_ab18840a73551ff7a36605bc8e53552e4}\label{namespacedetection__utils_1_1core_1_1box__list__ops_ab18840a73551ff7a36605bc8e53552e4} 
\index{detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}!visualize\_boxes\_in\_image@{visualize\_boxes\_in\_image}}
\index{visualize\_boxes\_in\_image@{visualize\_boxes\_in\_image}!detection\_utils.core.box\_list\_ops@{detection\_utils.core.box\_list\_ops}}
\doxysubsubsection{\texorpdfstring{visualize\_boxes\_in\_image()}{visualize\_boxes\_in\_image()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+core.\+box\+\_\+list\+\_\+ops.\+visualize\+\_\+boxes\+\_\+in\+\_\+image (\begin{DoxyParamCaption}\item[{}]{image,  }\item[{}]{boxlist,  }\item[{}]{normalized = {\ttfamily False},  }\item[{}]{scope = {\ttfamily None} }\end{DoxyParamCaption})}

\begin{DoxyVerb}Overlay bounding box list on image.

Currently this visualization plots a 1 pixel thick red bounding box on top
of the image.  Note that tf.image.draw_bounding_boxes essentially is
1 indexed.

Args:
  image: an image tensor with shape [height, width, 3]
  boxlist: a BoxList
  normalized: (boolean) specify whether corners are to be interpreted
    as absolute coordinates in image space or normalized with respect to the
    image size.
  scope: name scope.

Returns:
  image_and_boxes: an image tensor with shape [height, width, 3]
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{box__list__ops_8py_source_l00631}{631}} of file \mbox{\hyperlink{box__list__ops_8py_source}{box\+\_\+list\+\_\+ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00631\ \textcolor{keyword}{def\ }visualize\_boxes\_in\_image(image,\ boxlist,\ normalized=False,\ scope=None):}
\DoxyCodeLine{00632\ \ \ \textcolor{stringliteral}{"{}"{}"{}Overlay\ bounding\ box\ list\ on\ image.}}
\DoxyCodeLine{00633\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00634\ \textcolor{stringliteral}{\ \ Currently\ this\ visualization\ plots\ a\ 1\ pixel\ thick\ red\ bounding\ box\ on\ top}}
\DoxyCodeLine{00635\ \textcolor{stringliteral}{\ \ of\ the\ image.\ \ Note\ that\ tf.image.draw\_bounding\_boxes\ essentially\ }\textcolor{keywordflow}{is}}
\DoxyCodeLine{00636\ \ \ 1\ indexed.}
\DoxyCodeLine{00637\ }
\DoxyCodeLine{00638\ \ \ Args:}
\DoxyCodeLine{00639\ \ \ \ \ image:\ an\ image\ tensor\ \textcolor{keyword}{with}\ shape\ [height,\ width,\ 3]}
\DoxyCodeLine{00640\ \ \ \ \ boxlist:\ a\ BoxList}
\DoxyCodeLine{00641\ \ \ \ \ normalized:\ (boolean)\ specify\ whether\ corners\ are\ to\ be\ interpreted}
\DoxyCodeLine{00642\ \ \ \ \ \ \ \textcolor{keyword}{as}\ absolute\ coordinates\ \textcolor{keywordflow}{in}\ image\ space\ \textcolor{keywordflow}{or}\ normalized\ \textcolor{keyword}{with}\ respect\ to\ the}
\DoxyCodeLine{00643\ \ \ \ \ \ \ image\ size.}
\DoxyCodeLine{00644\ \ \ \ \ scope:\ name\ scope.}
\DoxyCodeLine{00645\ }
\DoxyCodeLine{00646\ \ \ Returns:}
\DoxyCodeLine{00647\ \ \ \ \ image\_and\_boxes:\ an\ image\ tensor\ \textcolor{keyword}{with}\ shape\ [height,\ width,\ 3]}
\DoxyCodeLine{00648\ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{00649\ \textcolor{stringliteral}{\ \ }\textcolor{keyword}{with}\ tf.name\_scope(scope,\ \textcolor{stringliteral}{'VisualizeBoxesInImage'}):}
\DoxyCodeLine{00650\ \ \ \ \ \textcolor{keywordflow}{if}\ \textcolor{keywordflow}{not}\ normalized:}
\DoxyCodeLine{00651\ \ \ \ \ \ \ height,\ width,\ \_\ =\ tf.unstack(tf.shape(image))}
\DoxyCodeLine{00652\ \ \ \ \ \ \ boxlist\ =\ scale(boxlist,}
\DoxyCodeLine{00653\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 1.0\ /\ tf.cast(height,\ tf.float32),}
\DoxyCodeLine{00654\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 1.0\ /\ tf.cast(width,\ tf.float32))}
\DoxyCodeLine{00655\ \ \ \ \ corners\ =\ tf.expand\_dims(boxlist.get(),\ 0)}
\DoxyCodeLine{00656\ \ \ \ \ image\ =\ tf.expand\_dims(image,\ 0)}
\DoxyCodeLine{00657\ \ \ \ \ \textcolor{keywordflow}{return}\ tf.squeeze(tf.image.draw\_bounding\_boxes(image,\ corners),\ [0])}
\DoxyCodeLine{00658\ }
\DoxyCodeLine{00659\ }

\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{d9/da1/namespacedetection__utils_1_1core_1_1box__list__ops_ab18840a73551ff7a36605bc8e53552e4_cgraph}
\end{center}
\end{figure}
