\doxysection{detection\+\_\+utils.\+utils.\+np\+\_\+mask\+\_\+ops Namespace Reference}
\hypertarget{namespacedetection__utils_1_1utils_1_1np__mask__ops}{}\label{namespacedetection__utils_1_1utils_1_1np__mask__ops}\index{detection\_utils.utils.np\_mask\_ops@{detection\_utils.utils.np\_mask\_ops}}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1utils_1_1np__mask__ops_aa5c1487c101278072b308d1e13dfa940}{area}} (masks)
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1utils_1_1np__mask__ops_ab86e490066a2b28d2e92a85905b4a305}{intersection}} (masks1, masks2)
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1utils_1_1np__mask__ops_a107f42821711fe2a709f68e04dac9f3a}{iou}} (masks1, masks2)
\item 
\mbox{\hyperlink{namespacedetection__utils_1_1utils_1_1np__mask__ops_a4feda1393eb4662d346d10343dccb8f7}{ioa}} (masks1, masks2)
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
int \mbox{\hyperlink{namespacedetection__utils_1_1utils_1_1np__mask__ops_abc83c73bff64f225994ad3e3059b4f8a}{EPSILON}} = 1e-\/7
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\begin{DoxyVerb}Operations for [N, height, width] numpy arrays representing masks.

Example mask operations that are supported:
  * Areas: compute mask areas
  * IOU: pairwise intersection-over-union scores
\end{DoxyVerb}
 

\doxysubsection{Function Documentation}
\Hypertarget{namespacedetection__utils_1_1utils_1_1np__mask__ops_aa5c1487c101278072b308d1e13dfa940}\label{namespacedetection__utils_1_1utils_1_1np__mask__ops_aa5c1487c101278072b308d1e13dfa940} 
\index{detection\_utils.utils.np\_mask\_ops@{detection\_utils.utils.np\_mask\_ops}!area@{area}}
\index{area@{area}!detection\_utils.utils.np\_mask\_ops@{detection\_utils.utils.np\_mask\_ops}}
\doxysubsubsection{\texorpdfstring{area()}{area()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+utils.\+np\+\_\+mask\+\_\+ops.\+area (\begin{DoxyParamCaption}\item[{}]{masks }\end{DoxyParamCaption})}

\begin{DoxyVerb}Computes area of masks.

Args:
  masks: Numpy array with shape [N, height, width] holding N masks. Masks
    values are of type np.uint8 and values are in {0,1}.

Returns:
  a numpy array with shape [N*1] representing mask areas.

Raises:
  ValueError: If masks.dtype is not np.uint8
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{np__mask__ops_8py_source_l00032}{32}} of file \mbox{\hyperlink{np__mask__ops_8py_source}{np\+\_\+mask\+\_\+ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00032\ \textcolor{keyword}{def\ }area(masks):}
\DoxyCodeLine{00033\ \ \ \textcolor{stringliteral}{"{}"{}"{}Computes\ area\ of\ masks.}}
\DoxyCodeLine{00034\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00035\ \textcolor{stringliteral}{\ \ Args:}}
\DoxyCodeLine{00036\ \textcolor{stringliteral}{\ \ \ \ masks:\ Numpy\ array\ }\textcolor{keyword}{with}\ shape\ [N,\ height,\ width]\ holding\ N\ masks.\ Masks}
\DoxyCodeLine{00037\ \ \ \ \ \ \ values\ are\ of\ type\ np.uint8\ \textcolor{keywordflow}{and}\ values\ are\ \textcolor{keywordflow}{in}\ \{0,1\}.}
\DoxyCodeLine{00038\ }
\DoxyCodeLine{00039\ \ \ Returns:}
\DoxyCodeLine{00040\ \ \ \ \ a\ numpy\ array\ \textcolor{keyword}{with}\ shape\ [N*1]\ representing\ mask\ areas.}
\DoxyCodeLine{00041\ }
\DoxyCodeLine{00042\ \ \ Raises:}
\DoxyCodeLine{00043\ \ \ \ \ ValueError:\ If\ masks.dtype\ \textcolor{keywordflow}{is}\ \textcolor{keywordflow}{not}\ np.uint8}
\DoxyCodeLine{00044\ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{00045\ \textcolor{stringliteral}{\ \ }\textcolor{keywordflow}{if}\ masks.dtype\ !=\ np.uint8:}
\DoxyCodeLine{00046\ \ \ \ \ \textcolor{keywordflow}{raise}\ ValueError(\textcolor{stringliteral}{'Masks\ type\ should\ be\ np.uint8'})}
\DoxyCodeLine{00047\ \ \ \textcolor{keywordflow}{return}\ np.sum(masks,\ axis=(1,\ 2),\ dtype=np.float32)}
\DoxyCodeLine{00048\ }
\DoxyCodeLine{00049\ }

\end{DoxyCode}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=344pt]{df/d95/namespacedetection__utils_1_1utils_1_1np__mask__ops_aa5c1487c101278072b308d1e13dfa940_icgraph}
\end{center}
\end{figure}
\Hypertarget{namespacedetection__utils_1_1utils_1_1np__mask__ops_ab86e490066a2b28d2e92a85905b4a305}\label{namespacedetection__utils_1_1utils_1_1np__mask__ops_ab86e490066a2b28d2e92a85905b4a305} 
\index{detection\_utils.utils.np\_mask\_ops@{detection\_utils.utils.np\_mask\_ops}!intersection@{intersection}}
\index{intersection@{intersection}!detection\_utils.utils.np\_mask\_ops@{detection\_utils.utils.np\_mask\_ops}}
\doxysubsubsection{\texorpdfstring{intersection()}{intersection()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+utils.\+np\+\_\+mask\+\_\+ops.\+intersection (\begin{DoxyParamCaption}\item[{}]{masks1,  }\item[{}]{masks2 }\end{DoxyParamCaption})}

\begin{DoxyVerb}Compute pairwise intersection areas between masks.

Args:
  masks1: a numpy array with shape [N, height, width] holding N masks. Masks
    values are of type np.uint8 and values are in {0,1}.
  masks2: a numpy array with shape [M, height, width] holding M masks. Masks
    values are of type np.uint8 and values are in {0,1}.

Returns:
  a numpy array with shape [N*M] representing pairwise intersection area.

Raises:
  ValueError: If masks1 and masks2 are not of type np.uint8.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{np__mask__ops_8py_source_l00050}{50}} of file \mbox{\hyperlink{np__mask__ops_8py_source}{np\+\_\+mask\+\_\+ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00050\ \textcolor{keyword}{def\ }intersection(masks1,\ masks2):}
\DoxyCodeLine{00051\ \ \ \textcolor{stringliteral}{"{}"{}"{}Compute\ pairwise\ intersection\ areas\ between\ masks.}}
\DoxyCodeLine{00052\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00053\ \textcolor{stringliteral}{\ \ Args:}}
\DoxyCodeLine{00054\ \textcolor{stringliteral}{\ \ \ \ masks1:\ a\ numpy\ array\ }\textcolor{keyword}{with}\ shape\ [N,\ height,\ width]\ holding\ N\ masks.\ Masks}
\DoxyCodeLine{00055\ \ \ \ \ \ \ values\ are\ of\ type\ np.uint8\ \textcolor{keywordflow}{and}\ values\ are\ \textcolor{keywordflow}{in}\ \{0,1\}.}
\DoxyCodeLine{00056\ \ \ \ \ masks2:\ a\ numpy\ array\ \textcolor{keyword}{with}\ shape\ [M,\ height,\ width]\ holding\ M\ masks.\ Masks}
\DoxyCodeLine{00057\ \ \ \ \ \ \ values\ are\ of\ type\ np.uint8\ \textcolor{keywordflow}{and}\ values\ are\ \textcolor{keywordflow}{in}\ \{0,1\}.}
\DoxyCodeLine{00058\ }
\DoxyCodeLine{00059\ \ \ Returns:}
\DoxyCodeLine{00060\ \ \ \ \ a\ numpy\ array\ \textcolor{keyword}{with}\ shape\ [N*M]\ representing\ pairwise\ intersection\ area.}
\DoxyCodeLine{00061\ }
\DoxyCodeLine{00062\ \ \ Raises:}
\DoxyCodeLine{00063\ \ \ \ \ ValueError:\ If\ masks1\ \textcolor{keywordflow}{and}\ masks2\ are\ \textcolor{keywordflow}{not}\ of\ type\ np.uint8.}
\DoxyCodeLine{00064\ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{00065\ \textcolor{stringliteral}{\ \ }\textcolor{keywordflow}{if}\ masks1.dtype\ !=\ np.uint8\ \textcolor{keywordflow}{or}\ masks2.dtype\ !=\ np.uint8:}
\DoxyCodeLine{00066\ \ \ \ \ \textcolor{keywordflow}{raise}\ ValueError(\textcolor{stringliteral}{'masks1\ and\ masks2\ should\ be\ of\ type\ np.uint8'})}
\DoxyCodeLine{00067\ \ \ n\ =\ masks1.shape[0]}
\DoxyCodeLine{00068\ \ \ m\ =\ masks2.shape[0]}
\DoxyCodeLine{00069\ \ \ answer\ =\ np.zeros([n,\ m],\ dtype=np.float32)}
\DoxyCodeLine{00070\ \ \ \textcolor{keywordflow}{for}\ i\ \textcolor{keywordflow}{in}\ np.arange(n):}
\DoxyCodeLine{00071\ \ \ \ \ \textcolor{keywordflow}{for}\ j\ \textcolor{keywordflow}{in}\ np.arange(m):}
\DoxyCodeLine{00072\ \ \ \ \ \ \ answer[i,\ j]\ =\ np.sum(np.minimum(masks1[i],\ masks2[j]),\ dtype=np.float32)}
\DoxyCodeLine{00073\ \ \ \textcolor{keywordflow}{return}\ answer}
\DoxyCodeLine{00074\ }
\DoxyCodeLine{00075\ }

\end{DoxyCode}
Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{df/d95/namespacedetection__utils_1_1utils_1_1np__mask__ops_ab86e490066a2b28d2e92a85905b4a305_icgraph}
\end{center}
\end{figure}
\Hypertarget{namespacedetection__utils_1_1utils_1_1np__mask__ops_a4feda1393eb4662d346d10343dccb8f7}\label{namespacedetection__utils_1_1utils_1_1np__mask__ops_a4feda1393eb4662d346d10343dccb8f7} 
\index{detection\_utils.utils.np\_mask\_ops@{detection\_utils.utils.np\_mask\_ops}!ioa@{ioa}}
\index{ioa@{ioa}!detection\_utils.utils.np\_mask\_ops@{detection\_utils.utils.np\_mask\_ops}}
\doxysubsubsection{\texorpdfstring{ioa()}{ioa()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+utils.\+np\+\_\+mask\+\_\+ops.\+ioa (\begin{DoxyParamCaption}\item[{}]{masks1,  }\item[{}]{masks2 }\end{DoxyParamCaption})}

\begin{DoxyVerb}Computes pairwise intersection-over-area between box collections.

Intersection-over-area (ioa) between two masks, mask1 and mask2 is defined as
their intersection area over mask2's area. Note that ioa is not symmetric,
that is, IOA(mask1, mask2) != IOA(mask2, mask1).

Args:
  masks1: a numpy array with shape [N, height, width] holding N masks. Masks
    values are of type np.uint8 and values are in {0,1}.
  masks2: a numpy array with shape [M, height, width] holding N masks. Masks
    values are of type np.uint8 and values are in {0,1}.

Returns:
  a numpy array with shape [N, M] representing pairwise ioa scores.

Raises:
  ValueError: If masks1 and masks2 are not of type np.uint8.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{np__mask__ops_8py_source_l00101}{101}} of file \mbox{\hyperlink{np__mask__ops_8py_source}{np\+\_\+mask\+\_\+ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00101\ \textcolor{keyword}{def\ }ioa(masks1,\ masks2):}
\DoxyCodeLine{00102\ \ \ \textcolor{stringliteral}{"{}"{}"{}Computes\ pairwise\ intersection-\/over-\/area\ between\ box\ collections.}}
\DoxyCodeLine{00103\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00104\ \textcolor{stringliteral}{\ \ Intersection-\/over-\/area\ (ioa)\ between\ two\ masks,\ mask1\ }\textcolor{keywordflow}{and}\ mask2\ \textcolor{keywordflow}{is}\ defined\ \textcolor{keyword}{as}}
\DoxyCodeLine{00105\ \ \ their\ intersection\ area\ over\ mask2\textcolor{stringliteral}{'s\ area.\ Note\ that\ ioa\ is\ not\ symmetric,}}
\DoxyCodeLine{00106\ \textcolor{stringliteral}{\ \ that\ }\textcolor{keywordflow}{is},\ IOA(mask1,\ mask2)\ !=\ IOA(mask2,\ mask1).}
\DoxyCodeLine{00107\ }
\DoxyCodeLine{00108\ \ \ Args:}
\DoxyCodeLine{00109\ \ \ \ \ masks1:\ a\ numpy\ array\ \textcolor{keyword}{with}\ shape\ [N,\ height,\ width]\ holding\ N\ masks.\ Masks}
\DoxyCodeLine{00110\ \ \ \ \ \ \ values\ are\ of\ type\ np.uint8\ \textcolor{keywordflow}{and}\ values\ are\ \textcolor{keywordflow}{in}\ \{0,1\}.}
\DoxyCodeLine{00111\ \ \ \ \ masks2:\ a\ numpy\ array\ \textcolor{keyword}{with}\ shape\ [M,\ height,\ width]\ holding\ N\ masks.\ Masks}
\DoxyCodeLine{00112\ \ \ \ \ \ \ values\ are\ of\ type\ np.uint8\ \textcolor{keywordflow}{and}\ values\ are\ \textcolor{keywordflow}{in}\ \{0,1\}.}
\DoxyCodeLine{00113\ }
\DoxyCodeLine{00114\ \ \ Returns:}
\DoxyCodeLine{00115\ \ \ \ \ a\ numpy\ array\ \textcolor{keyword}{with}\ shape\ [N,\ M]\ representing\ pairwise\ ioa\ scores.}
\DoxyCodeLine{00116\ }
\DoxyCodeLine{00117\ \ \ Raises:}
\DoxyCodeLine{00118\ \ \ \ \ ValueError:\ If\ masks1\ \textcolor{keywordflow}{and}\ masks2\ are\ \textcolor{keywordflow}{not}\ of\ type\ np.uint8.}
\DoxyCodeLine{00119\ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{00120\ \textcolor{stringliteral}{\ \ }\textcolor{keywordflow}{if}\ masks1.dtype\ !=\ np.uint8\ \textcolor{keywordflow}{or}\ masks2.dtype\ !=\ np.uint8:}
\DoxyCodeLine{00121\ \ \ \ \ \textcolor{keywordflow}{raise}\ ValueError(\textcolor{stringliteral}{'masks1\ and\ masks2\ should\ be\ of\ type\ np.uint8'})}
\DoxyCodeLine{00122\ \ \ intersect\ =\ intersection(masks1,\ masks2)}
\DoxyCodeLine{00123\ \ \ areas\ =\ np.expand\_dims(area(masks2),\ axis=0)}
\DoxyCodeLine{00124\ \ \ \textcolor{keywordflow}{return}\ intersect\ /\ (areas\ +\ EPSILON)}

\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{df/d95/namespacedetection__utils_1_1utils_1_1np__mask__ops_a4feda1393eb4662d346d10343dccb8f7_cgraph}
\end{center}
\end{figure}
\Hypertarget{namespacedetection__utils_1_1utils_1_1np__mask__ops_a107f42821711fe2a709f68e04dac9f3a}\label{namespacedetection__utils_1_1utils_1_1np__mask__ops_a107f42821711fe2a709f68e04dac9f3a} 
\index{detection\_utils.utils.np\_mask\_ops@{detection\_utils.utils.np\_mask\_ops}!iou@{iou}}
\index{iou@{iou}!detection\_utils.utils.np\_mask\_ops@{detection\_utils.utils.np\_mask\_ops}}
\doxysubsubsection{\texorpdfstring{iou()}{iou()}}
{\footnotesize\ttfamily detection\+\_\+utils.\+utils.\+np\+\_\+mask\+\_\+ops.\+iou (\begin{DoxyParamCaption}\item[{}]{masks1,  }\item[{}]{masks2 }\end{DoxyParamCaption})}

\begin{DoxyVerb}Computes pairwise intersection-over-union between mask collections.

Args:
  masks1: a numpy array with shape [N, height, width] holding N masks. Masks
    values are of type np.uint8 and values are in {0,1}.
  masks2: a numpy array with shape [M, height, width] holding N masks. Masks
    values are of type np.uint8 and values are in {0,1}.

Returns:
  a numpy array with shape [N, M] representing pairwise iou scores.

Raises:
  ValueError: If masks1 and masks2 are not of type np.uint8.
\end{DoxyVerb}
 

Definition at line \mbox{\hyperlink{np__mask__ops_8py_source_l00076}{76}} of file \mbox{\hyperlink{np__mask__ops_8py_source}{np\+\_\+mask\+\_\+ops.\+py}}.


\begin{DoxyCode}{0}
\DoxyCodeLine{00076\ \textcolor{keyword}{def\ }iou(masks1,\ masks2):}
\DoxyCodeLine{00077\ \ \ \textcolor{stringliteral}{"{}"{}"{}Computes\ pairwise\ intersection-\/over-\/union\ between\ mask\ collections.}}
\DoxyCodeLine{00078\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00079\ \textcolor{stringliteral}{\ \ Args:}}
\DoxyCodeLine{00080\ \textcolor{stringliteral}{\ \ \ \ masks1:\ a\ numpy\ array\ }\textcolor{keyword}{with}\ shape\ [N,\ height,\ width]\ holding\ N\ masks.\ Masks}
\DoxyCodeLine{00081\ \ \ \ \ \ \ values\ are\ of\ type\ np.uint8\ \textcolor{keywordflow}{and}\ values\ are\ \textcolor{keywordflow}{in}\ \{0,1\}.}
\DoxyCodeLine{00082\ \ \ \ \ masks2:\ a\ numpy\ array\ \textcolor{keyword}{with}\ shape\ [M,\ height,\ width]\ holding\ N\ masks.\ Masks}
\DoxyCodeLine{00083\ \ \ \ \ \ \ values\ are\ of\ type\ np.uint8\ \textcolor{keywordflow}{and}\ values\ are\ \textcolor{keywordflow}{in}\ \{0,1\}.}
\DoxyCodeLine{00084\ }
\DoxyCodeLine{00085\ \ \ Returns:}
\DoxyCodeLine{00086\ \ \ \ \ a\ numpy\ array\ \textcolor{keyword}{with}\ shape\ [N,\ M]\ representing\ pairwise\ iou\ scores.}
\DoxyCodeLine{00087\ }
\DoxyCodeLine{00088\ \ \ Raises:}
\DoxyCodeLine{00089\ \ \ \ \ ValueError:\ If\ masks1\ \textcolor{keywordflow}{and}\ masks2\ are\ \textcolor{keywordflow}{not}\ of\ type\ np.uint8.}
\DoxyCodeLine{00090\ \ \ \textcolor{stringliteral}{"{}"{}"{}}}
\DoxyCodeLine{00091\ \textcolor{stringliteral}{\ \ }\textcolor{keywordflow}{if}\ masks1.dtype\ !=\ np.uint8\ \textcolor{keywordflow}{or}\ masks2.dtype\ !=\ np.uint8:}
\DoxyCodeLine{00092\ \ \ \ \ \textcolor{keywordflow}{raise}\ ValueError(\textcolor{stringliteral}{'masks1\ and\ masks2\ should\ be\ of\ type\ np.uint8'})}
\DoxyCodeLine{00093\ \ \ intersect\ =\ intersection(masks1,\ masks2)}
\DoxyCodeLine{00094\ \ \ area1\ =\ area(masks1)}
\DoxyCodeLine{00095\ \ \ area2\ =\ area(masks2)}
\DoxyCodeLine{00096\ \ \ union\ =\ np.expand\_dims(area1,\ axis=1)\ +\ np.expand\_dims(}
\DoxyCodeLine{00097\ \ \ \ \ \ \ area2,\ axis=0)\ -\/\ intersect}
\DoxyCodeLine{00098\ \ \ \textcolor{keywordflow}{return}\ intersect\ /\ np.maximum(union,\ EPSILON)}
\DoxyCodeLine{00099\ }
\DoxyCodeLine{00100\ }

\end{DoxyCode}
Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{df/d95/namespacedetection__utils_1_1utils_1_1np__mask__ops_a107f42821711fe2a709f68e04dac9f3a_cgraph}
\end{center}
\end{figure}


\doxysubsection{Variable Documentation}
\Hypertarget{namespacedetection__utils_1_1utils_1_1np__mask__ops_abc83c73bff64f225994ad3e3059b4f8a}\label{namespacedetection__utils_1_1utils_1_1np__mask__ops_abc83c73bff64f225994ad3e3059b4f8a} 
\index{detection\_utils.utils.np\_mask\_ops@{detection\_utils.utils.np\_mask\_ops}!EPSILON@{EPSILON}}
\index{EPSILON@{EPSILON}!detection\_utils.utils.np\_mask\_ops@{detection\_utils.utils.np\_mask\_ops}}
\doxysubsubsection{\texorpdfstring{EPSILON}{EPSILON}}
{\footnotesize\ttfamily int detection\+\_\+utils.\+utils.\+np\+\_\+mask\+\_\+ops.\+EPSILON = 1e-\/7}



Definition at line \mbox{\hyperlink{np__mask__ops_8py_source_l00029}{29}} of file \mbox{\hyperlink{np__mask__ops_8py_source}{np\+\_\+mask\+\_\+ops.\+py}}.

